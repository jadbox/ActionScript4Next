Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

        The (Interim) ActionScript 4 Virtual Machine Specification

1. Introduction

1.1 History

1.2 The ActionScript 4 Virtual Machine

This specification describes a virtual machine, which is an abstract
computational platform and thus may run on a variety of concrete
platforms.  It may be implemented entirely in software, entirely in
hardware or a combination of the two.

The ActionScript 4 virtual machine knows nothing of any particular
source language.  Rather, it understands a platform independent binary
format called the abc (historically, the Actionscript ByteCode) file
format.  An abc file contains one or more class or interface
descriptions in the form of a symbol table, constant value definitions
and virtual machine instructions (or bytecode instructions).  The AS
virtual machine borrows concepts from the AS4 language and can run AS4
programs that have been compiled into one or more abc files.  Any
program written in a language whose semantics can be expressed by an
abc file can run on the AS virtual machine.

1.3 Chapter Summary

The rest of this specification is structured as follows:

Chapter 2 gives an overview of the AS virtual machine architecture and
instruction set.

Chapter 3 specifies the abc file format, a binary format that
represents compiled classes and interfaces.

Chapter 4 specifies the startup of the AS virtual machine, including
loading, linking and initialization of classes and interfaces.

Chapter 5 specifies the AS virtual machine's instruction set.

Chapter 6 provides code generation examples and guidelines.

Chapter 7 provides an instruction set opcode map.

1.4 Notation


2. The Structure of the ActionScript 4 Virtual Machine

2.1 The abc File Format

Compiled code to be executed by the AS virtual machine is represented
using a platform independent binary format called the abc file
format.

2.2 Types

The AS virtual machine's type hierarchy is similar to that of the AS4
language.  The '*' (pronounced "star") abstract type is the root of
both the AS4 language's and the virtual machine's type hierarchy, but
this specification additionally defines box and closed-over-variable
(or cov) types as subtypes of '*'.

A type is a name for a set of values.  A struct or class is an
implementation of a type and defines a set of values and operations
(or methods) on and/or using those values.  The type of a struct or
class is respectively termed a struct or class type.  Methods are said
to belong to (or be a member of) of a struct or class or be of a
struct or class type.

A value of a class type (or object) is a collection of homogenously or
heterogenously typed component values with a lifetime independent of
the lexical context in which it was created.  An object thus has a
unique identity (or name) which may be used to refer to it.  Objects,
like methods, are said to belong to (or be members of) a class, or be
of a class type.

A value of a struct type (or struct value) is a collection of
homogenously or heterogenously typed component values which has no
unique identity and thus no name that may be used to refer to it.

A struct value is immutable, though struct value containers such as
object components are usually mutable.

A static method is always invoked without reference to any particular
object, while an instance (or virtual) method is always invoked with
respect to a particular object.  The method targeted by an invocation
of a static method with a given name and signature is always the same.
The method targeted by an invocation of a virtual method with a given
name and signature depends on some object's type.

Struct types may have only static methods, while class types may have
both static and virtual methods.

Scalar types, such as signed integer, are single-component struct
types that are directly supported by the virtual machine instruction
set. Certain class types, such as array, vector and closure types, are
also directly supported by the virtual machine instruction set.

An interface type is a description of the methods of a class type.  A
class type can be said to implement an interface type, while a struct
type cannot.

A box type is a class type whose values are objects that have been
created (or boxed) from struct values in order to give those values an
identity.  Box objects, like the struct values from which they are
made, are immutable.  There exists an unbounded family of box types
parameterized by their struct types.

A closed-over-variable type is the type of a tuple of one or more free
variables (that is, variables local to some lexical scope) that are
bound into a closure object.

Struct types, the AS4 language's Object type and its subtypes, box
types and cov types are all subtypes of '*'.

The eleven scalar types are boolean (or bool), signed and unsigned
byte (or sbyte and ubyte), signed and unsigned short (or short and
ushort), signed and unsigned int (or int and uint), signed and
unsigned long (or long and ulong), float and double.

The Object type and its subtypes include interface, array, vector,
closure and ordinary class types.  Ordinary class types are the Object
type itself and the subtypes of Object that are not interface, array,
vector or closure types.  Correspondingly, ordinary classes are the
Object class and the subclasses of Object that are not array, vector
or closure classes.  An ordinary object is a member of an ordinary
class.

While interface types are subtypes of the Object type, interfaces are
not classes and do not extend the Object class.

There exists an unbounded family of array, vector and closure types
that are respectively parameterized by element type, element type and
signature.

Struct types correspond to the AS4 language's struct types, array
types to the AS4 language's array types, vector types to the AS4
language's bound ArrayList<T> types and closure types to the AS4
language's function types.

Because '*' is an abstract type, only values of '*' subtypes (struct
values and objects) can be created by the virtual machine.

A default value exists for many types.

2.2.1 Scalar Types

Values of scalar type are represented in the virtual machine as either
primitive machine type values, struct values (2.2.2) or scalar box
objects (2.2.8.1).  Primitive machine type values can be thought of as
optimized representations of single-component struct values.  As with
all values of struct type, primitive machine type values and their
corresponding box objects are mutually convertible.  Most of the
virtual machine instructions operate on primitive machine type values.

All eleven scalar types are supported by the virtual machine as
primitive machine types.  Primitive bool values are represented as the
int values 0 for false and 1 for true.  Primitive sbyte, short, int
and long values are respectively 8, 16, 32 and 64 bits wide and are
represented in two's-complement form.  Primitive ubyte, ushort, uint
and ulong values are respectively 8, 16, 32 and 64 bits wide and are
represented as positive values with an assumed sign bit of zero.
Primitive float values are 32-bit IEEE-754 floating point values.
Primitive double values are 64-bit IEEE-754 floating point values.

The scalar floating point types are float and double.  The other nine
scalar types are the integral scalar types.

The default value for primitive integral types is zero, and for
primitive floating point types is positive zero.

2.2.2 Struct Types

A struct type describes a tuple of heterogenously typed, named,
immutable component values (or fields) together with static methods
that compute with them.  Some or all field values may themselves be
struct values (that is, struct values may be nested).  The number of
fields and number of methods of a struct type is fixed.  The number of
fields is the number of tuple components.  For each struct type, there
is a canonical field order, which is the order in which the field type
descriptors appear in a struct type descriptor (3.2).  Struct field
values are indexable in canonical order as well as by name: index
values range from zero to the number of fields minus one.

Struct values and objects of the corresponding box type (2.2.6) are
mutually convertible.

2.2.3 Interface and Ordinary Class Types

An ordinary class type describes a tuple of static or instance,
mutable or immutable, named, heterogenously typed components (or
fields), together with static and instance (or virtual) methods that
compute with and operate on them.  The number of fields and number of
methods of an ordinary class type are fixed.

Interface types are ordinary class types that describe (or declare),
but do not define, only virtual methods and have only static immutable
fields.

2.2.4 Array and Vector Types

An array type describes a dense ordered indexable tuple, all of whose
components (or elements) are mutable and of the same type. The number
of elements in an array object is fixed, but is not given by the array
type.  Array objects with differing numbers of elements are thus of
the same type.  The index type is int, and index values range from
zero to the array length minus one.  The element type of an array type
may itself by an array type, resulting in a multi-dimensional array
type.

A vector type describes a dense ordered indexable tuple, all of whose
components (or elements) are mutable and of the same type. The number
of elements in a vector object is not fixed and is not given by the
vector type.  Vector objects with differing numbers of elements are
thus of the same type.  The index type is int and index values range
from zero to the current vector length minus one.  The element type of
a vector type may itself by a vector type, resulting in a
multi-dimensional vector type.

Array and vector objects whose element type is bool are represented by
array and vector objects whose element type is ubyte.

2.2.5 Closure Types

A closure type is a method signature.  Closure objects encapsulate (or
bind) a target method together with a set of immutable (or bound)
values.  Bound values are values of struct (2.2.2), reference (2.2.7)
or primitive machine (2.2.1) types that are readable from the target
method's code.

2.2.6 Closed-Over-Variable Types

A closed-over-variable (or cov) type describes an ordered indexable
tuple whose components (or elements) are heterogenously typed.  A cov
type is similar to an array type, except that array elements are
homogenously typed.  The number of elements in a cov object is fixed
and is the number of tuple elements.  Index values range from zero to
the number of elements minus one.

Cov objects are used to encapsulate local lexical state for use in
methods bound into closure objects, and can themselves be bound into
closure objects.

2.2.7 Box Types

An box type is a class type that describes encapsulated values of a
struct type, which is a tuple of heterogenously typed, named,
immutable component values (or fields) together with virtual methods
that compute with them.  The number of fields and number of methods of
a box type are fixed.

Certain box types (principally the ones corresponding to the scalar
types) are known to the virtual machine, or it synthesizes them as
needed.

Each static method of the struct type corresponding to a box type has
a corresponding virtual method of the box type.  Because such virtual
methods do not exist in an abc file (3), which contains bytecode only
for always-static struct methods, the virtual machine acts as if it
synthesizes them.

Box objects and values of the corresponding struct type (2.2.2) are
mutually convertible.

2.2.8 Reference Types

Collectively, the class types (the Object type and its subtypes, and
cov and box types) are termed reference types.  Their values are
dynamically created objects of the Object class and its subclasses as
well as objects of classes that implement interfaces.  The identity of
such an object is a reference value.  Reference values are also
referred to as reference type values or reference values of the
corresponding class or class type.

A reference value may be the null reference value.  The type of null
may be cast to any type, thus the null reference value may be assigned
to a reference to any type.

The default value for a reference type is null.

2.2.8.1 The '*' Type, Static and Dynamic Types, and Box Objects

Values of '*' type are reference type values.  Such values are said to
be untyped in the AS4 language, even though their types are known to
the virtual machine at run time.

Every value known to the virtual machine has both a static and a
dynamic type.  A static type is one known to a compiler and verifier.
A dynamic type is one known to the virtual machine at run time.  The
static and dynamic types of all values except those of '*' type are
the same.  The static type of a value of '*' type is '*', but its
dynamic type is known only to the virtual machine at run time.

Because the static type of values of '*' type is '*', virtual methods
of '*' are the only virtual methods that may be invoked on such values
using an invokevirtual instruction (2.2.8).  For other virtual
methods, an invokeprop instruction (2.2.8) must be used.

To be used as '*' values, struct values must first be converted (or
boxed) into box objects.  To be used as struct values, box objects
must first be converted (or unboxed) into struct values.  The static
type of every box object, as for all values of '*' type, is '*'.

A scalar class is a box class with a single primitive machine type
(2.2.1) field.  Scalar objects are the values of scalar classes.  To
be used as a '*' value, a primitive machine type value must first be
boxed into a scalar object, and, to be used as a primitive machine
type value, the value in a box object must first be unboxed.  There
exists a scalar class extending the '*' class (possibly indirectly)
corresponding to each of the scalar types.  When boxing a primitive
machine type value, the virtual machine must create a box object of
the corresponding scalar class.

The standard arithmetic, relational and conversion operations on
scalar types are available as a set of static methods on '*'.  They
all accept and return objects of '*' type, and will throw an exception
if an operand is not convertible to a scalar box type.  The operations
are defined as by the AS4 language, including implicit conversions.
See Appendix ? for the methods defined by the '*' type.

2.2.9 Type Hierarchy Tree

In tree form, with '*' at the root, the AVMS type hierarchy is as
follows.

'*'
    Struct types
        Primitive machine types
        Other struct types
    Class types
        Box types
        The Object type
            Ordinary class types
            Interface types
            Array types
            Vector types
            Closure types
        Closed-Over-Variable types

2.3 Runtime Data Areas

The runtime data areas include the virtual machine and native stacks,
which hold virtual machine and native stack frames, the heap, the
metadata area and pc registers for each virtual machine thread.

The virtual machine may be running many threads of execution at
once. At any given time, each virtual machine thread is executing the
code for a method termed the current method.  The current method's
enclosing class is the current class and its stack frame (2.3.2, 2.4)
is the current frame.

2.3.1 The pc Register

The code for a method is a sequence of bytecode instructions.
Instruction sequences are allocated in the metadata area (2.3.4).

Each virtual machine thread has its own program counter (or pc)
register which contains the metadata area address of the bytecode
instruction currently being executed.

2.3.2 The Virtual Machine and Native Stacks

Each virtual machine thread is associated with a virtual machine
thread execution stack.  A virtual machine method (that is, a method
implemented in bytecode) invocation pushes a virtual machine stack
frame (2.4) onto the virtual machine thread stack and pops the frame
when it returns.  The placement and management of virtual machine
thread stacks in memory is not specified.

Each virtual machine thread is also associated with a native execution
stack.  A native method (that is, a method implemented in native code)
invocation may or may not push a native stack frame onto the native
stack and pop the frame when it returns.  The placement and management
of native thread stacks in memory is not specified, nor is there
necessarily any relationship between virtual machine and native thread
stacks other than through the virtual machine method call chain.

The virtual machine may impose an upper bound on the size of the
virtual machine and native thread stacks.  If an attempt to allocate a
new frame would cause a stack size to exceed that bound, the virtual
machine throws a StackOverFlowError.

If memory for a virtual machine or native thread stack cannot be
allocated at thread startup, or if memory cannot be obtained to
increase the stack size up to some upper bound, the virtual machine
throws an OutOfMemoryError.

2.3.3 The Heap

The virtual machine allocates at startup and maintains during
execution a heap within which all virtual machine threads allocate
objects (2.2), as well as whatever other runtime data the virtual
machine implementation may find convenient such as code areas and
thread stack frames.  The placement and management of the heap in
memory is not specified.

Should an attempt to allocate space from the heap fail, the virtual
machine throws an OutOfMemoryError.

2.3.4 The Metadata Area

The virtual machine allocates at startup and maintains during
execution a metadata area within which it allocates runtime data
(other than objects) necessary to its operation.  Such data includes,
but is not limited to, the internal representation of abc files (3).
The placement and management of the metadata area in memory is not
specified.  In particular, the metadata area may be partly or wholely
allocated in the heap (2.3.3).

Should an attempt to allocate space from the metadata area fail, the
virtual machine throws an OutOfMemoryError.

2.4 Virtual Machine Stack Frames

A virtual machine method invocation (2.4.1, 2.4.2) creates and pushes
a new virtual machine stack frame onto the virtual machine stack, and
method return (2.4.4), whether normal or abrupt, pops and discards it.
Each virtual machine stack frame contains a set of local registers and
an operand stack.  The representation of a virtual machine stack frame
is not specified.

Each stack frame is owned by a virtual machine thread.  Threads other
than the owner cannot access a stack frame.  Only one frame, termed
the current frame, is in active use by a given thread at any given
time during execution.

2.4.1 Local Registers

Local registers are numbered and are referenced by number from
bytecode instructions.  Each method has a fixed number n of local
registers.  The first is numbered zero and the last n - 1.  A local
register can contain any single primitive machine (2.2.1), struct
(2.2.2) or reference (2.2.8) type value.

The virtual machine uses local registers to receive method parameter
values.  The first parameter is received in local register zero and
the rest are passed in succeeding higher numbered registers.  If the
method is virtual, a reference to the object on which the method is
invoked is passed in local register zero, followed by the rest of the
method arguments.

2.4.2 The Operand Stack

The operand stack is a last-in-first-out stack that contains values
pushed and popped by the virtual machine during bytecode instruction
execution.  It has a fixed maximum number of slots for each method.
The total number of allocated stack slots at any given time during
execution is termed the current depth.  The allocated slot on top of
the stack (or tos) at any given time during execution is numbered
zero, the one below it one and so on down to the current depth - 1.  A
stack slot can contain any single primitive machine (2.2.1), struct
(2.2.2) or reference (2.2.8) type value.

During method invocation, arguments are passed in the topmost slots of
the calling method's operand stack.  If there are n arguments
(including, for virtual calls, a reference to the object on which the
callee method is invoked), the first argument is in slot n - 1, the
second in slot n - 2, and so on, with the last argument in tos.

2.4.3 Dynamic Linking

An abc file contains symbolic references to methods to be invoked and
data to be accessed by the current method.  Dynamic linking translates
(or resolves) symbolic references to concrete references as they are
encountered during method execution, loading classes as necessary and
binding them into the virtual machine's runtime environment (4.?).

2.4.4 Method Return

A method may return normally or abruptly.  Methods return normally
unless an exception is thrown, in which case they return abruptly.

Normal return occurs as the result of executing one of the return
instructions.  A result value to be passed back to the calling method
is in tos, which must be the only allocated stack slot at that time.
The calling method's frame is made the current frame, and the result
value, if any, is pushed onto the calling method's operand stack.

Abrupt return occurs as the result of instruction execution throwing
an exception or of executing a throwe instruction, for which there is
no exception handler in the current method.  Abrupt returns never
return a value to the calling method.

2.5 Reference and Object Representation

Struct value, reference value and object binary representations are
not defined by this specification.

2.6 Floating Point Arithmetic

Operations on floating point values are done according to the rules of
the IEEE-754 specification, using round-to-nearest and gradual
underflow, except where otherwise stated.  They do not throw IEEE-754
exceptions, trap or otherwise signal any of the IEEE-754 invalid
operation, division by zero, overflow, underflow or inexact
exceptions.  There is no signalling NaN value nor does are signaling
floating point comparisons supported.  Denormalized numbers are
supported.

2.7 Exceptions

An exception is represented by an exception object.  An exception
object must be an instance of the Error class or one of its
subclasses.  Throwing an exception results in an immediate transfer of
control away from the instruction referenced by the current pc
register value.

An exception may occur synchronously as the result of executing a
throwe instruction or detection of an abnormal condition during
instruction execution, or asynchronously due to an internal error
occuring in the virtual machine.

Synchronous exceptions are thrown immediately after execution of the
instruction causing them.

Some (small) number of instructions may be executed between the
occurance of an asynchronous exception and when it is thrown.

Exceptions are precise.  The effects of all instructions executed
before the point from which the exception is thrown must appear to
have taken place before the exception is thrown.  No instruction after
that point must appear to have executed.

Each method may be associated with zero or more exception handlers.
Each handler specifies the class of exception object (or exception
class) that it will handle, the range of bytecode instruction offsets
from the beginning of the method during which it is active, and the
bytecode instruction offset for the code that will handle the
exception.

When an exception is thrown, the virtual machine searches the current
method for a matching handler (3.3.7.2).  For each method, handlers
are stored in a array (3.3.7).  The virtual machine searches for
handlers in the order in which they appear in the array.

The offset of the instruction previous to the current pc register
value (that is, the instruction that threw the exception) must occur
within the bytecode range specified by the handler and the exception
class must be the exception class specified by the handler or a
subclass thereof.

If a matching handler is found, the operand stack is cleared (all
values are popped), an exception object of the appropriate class is
pushed onto the operand stack, and control is transferred to the code
for the matching handler.  It may be necessary to execute the
equivalent of a newinstance instruction at the throw point in order to
create an exception object, or a virtual machine implementation may
create and cache exception objects before they are needed.

If no handler is found in the current method, the current method
completes abruptly.  The exception is then rethrown in the context of
the calling method's frame and so on until either a handler is found
or the thread's initial method completes abruptly, in which case the
thread is terminated.

2.8 Instruction Set Summary

Instructions consist of a one-byte opcode specifying the operation to
be performed followed by zero or more arguments or data used by the
operation.  The number of one-byte opcode instructions is therefore
capped at 256.  The "wide" one-byte instruction instructs the virtual
machine to interpret the next byte in the instruction stream as the
opcode of an instruction different from the corresponding one-byte
opcode.  There are thus a total of 512 possible instructions.

Ignoring exceptions, instruction execution begins with the initial
thread's pc register pointing to the instruction at bytecode offset
zero of the initial method.  The opcode byte is fetched atomically,
followed by any arguments.  Then, the instruction is executed.  Next,
if the pc register has not been updated by execution of the
instruction, it is updated to point to the next instruction.
Execution continues in this fashion until the initial method returns,
normally or abruptly, or until it invokes a method that otherwise
causes the virtual machine to exit.

2.8.1 Load and Store Instructions

Load and store instructions move values between local registers and
the operand stack, move values between machine-addressed locations
(such as within objects) and the operand stack or local registers, and
push immediate values onto the operand stack.

sbyte, ubyte, bool, short and ushort values are represented in local
registers and the operand stack as int values, thus there are no load
and store instructions that move such values.

There are general load and store forms that specify a local register
number as an explicit argument and short forms that specify the local
register number as part of the opcode.  The latter access the most
commonly used local registers.

Push a local register value onto the operand stack: ldi, ldl, ldf,
ldd, ldr, ldst, ldstf, ldi1, ldi2, ldi3, ldi4, ldi5, ldi6, ldl1, ldl2,
ldl3, ldr0, ldr1, ldr2, ldr3, ldr4, ldr5, ldr6, ldr7.

Pop the value on top of the operand stack and store it into a local
register: sti, stl, std, str, stst, ststf, sti1, sti2, sti3, sti4,
stl1, stl2, stl3, str1, str2, str3, str4, str5.

Load a value from a location specified by a machine address onto the
operand stack: ldmub, ldmus, ldmu, ldmul, ldmf, ldmd.

Store an operand stack value to a location specified by a machine
address: stmub, stmus, stmu, stmul, stmf, stmd.

Push an immediate value onto the operand stack: pushiub, pushius,
pushlub, pushlus, pushi0, pushi1, pushi2, pushi3, pushl0, pushl1,
pushf0, pushf1, pushd0, pushd1, pushnull.

Local register access opcode names are composed of "ld" or "st"
followed by "i", "l", "d", "r" or "st" for int, long, double,
reference and struct types.  The "stf" suffix used for struct value
field access.  Short form opcode names end with a register number.

There are no short form float instructions, as float operations are
relatively uncommon.

Machine location access opcode names are compiles of "ldm" or "stm"
followed by "ub", "us", "u", "ul", "f" or "d" for ubyte, ushort, uint,
ulong, float and double types.

2.8.2 Arithmetic Instructions

Other than the increment and decrement local register instructions,
arithmetic instructions compute the result of a function on one or two
values on the operand stack, pop them, and push the result onto the
operand stack.

sbyte, ubyte, bool, short and ushort values are represented in local
registers and the operand stack as int values, thus there are no
arithmetic instructions on such values.

Add: addi, addl, addf, addd.

Subtract: subi, subl, subf, subd.

Multiply: muli, mull, mulf, muld.

Divide: divi, divl, divul, divf, divd.

Modulus: modi, modl, modul, modf, modd.

Negate: negi, negl, negf, negd.

Shift: shli, shll, shri, shrl, ushri, ushrl.

Bitwise And: andi, andl.

Bitwise Or: ori, orl.

Bitwise Exclusive Or: xori, xorl.

Bitwise Complement: noti, notl.

Local register increment: inci, incl.

Local register decrement: deci, decl.

Comparison: cmpu, cmpl, cmpul, cmpfg, cmpfl, cmpdg, cmpdl.

Opcode names are composed of an operation name followed by a type
specifier of "i", "l", "ul", "f" or "d" for int, long, ulong, float
and double types.

Overflow on integer operations is not detected: the result is the low
order bits of true result.  Only divide and modulus instructions can
throw an exception, which is ArithmeticError if the divisor value is
zero.

2.8.3 Type Conversion Instructions

The virtual machine supports type-specialized and general conversion
operations.  Conversion operations include down conversions from wide
to narrow integral values and up and down conversions to and from
integral and floating point types.  Up-conversions from sbyte, ubyte,
short, ushort and bool to int are unnecessary because object access
instructions widen such values to int.

Type-specialized conversion from integral types: i2sb, i2ub, i2s,
i2us, i2z, i2u, i2l, i2f, i2d, u2i, u2l, l2i, l2ul, l2f, l2d, ul2l,
ul2f, ul2d.

Type-specialized conversion from float types: f2i, f2u, f2l, f2ul,
f2d, d2i, d2u, d2l, d2ul, d2f.

i2sb, i2ub, i2s, i2us and i2z are value preserving with respect to
int.  They sign or zero-extend their operand to 32 bits.

l2i is not value preserving.  It truncates its operand to 32 bits.

i2l and u2l are value preserving.  They sign or zero-extend their
operand to 64 bits.

The names of type-specialized instructions consist of a source type
specifier of "i", "u", "l", "ul", "f" or "d" for int, uint, long,
ulong, float and double types, followed by "2", followed by a
destination type specifier of "sb", "ub", "s", "us", "z" "i", "u",
"l", "ul", "f" or "d" for sbyte, ubyte, short, ushort, bool, int,
uint, long, ulong, float or double types.

Not all potential type-specialized conversion instructions are
directly implemented by the virtual machine.  Hypothetical i2ul, u2ul,
u2f, u2d, l2u and ul2u instructions could be implemented as
compositions of two type-specific conversion instructions.

ul2i is a potential type-specialized conversion instruction which
could be implemented with l2i.

i2u, u2i, l2ul and ul2l reinterpret the type of their operand.  They
do not change its value.

The unbox instruction is a general conversion instruction that
converts an operand value of '*' type to a specified primitive
machine, struct or reference type value.

The coerce instruction is a general conversion instruction that can
replace any type-specialized conversion instruction as well as the
unbox instruction.  It is expected to run more slowly (in some cases,
much more slowly) than the type-specialized conversion instructions or
the unbox instruction.  The use of type-specialized conversion
instructions is therefore preferred.

Only the unbox and coerce instructions can throw an exception, which
is either TypeError or NullPointerError.  The type-specialized
conversion instructions never throw an exception.

2.8.5 Object Creation and Manipulation

These instructions create object instances and access their components.

Loads of sbyte, ubyte, short, ushort and bool values widen to int.
Stores to sbyte, ubyte, short, ushort and bool components truncate int
value high order bits.

Create a new ordinary class object (that is, one that is not an array,
vector, closure, closed-over-variable or box object): newinstance.

Create a new array object: newarray, fillnewarray, cfillnewarray,
multinewarray.

Create a new vector object: newvector, fillnewvector, cfillnewvector,
multinewvector.

Create a new closed-over-variable object: newcov.

Create a new closure object: newclosure.

Create a new box object: newbox, newboxprop.

Access object fields: getfield, getstatic, getprop, putfield,
putstatic, putprop.

Push an array element onto the operand stack: ldasb, ldaub, ldas,
ldaus, ldai, ldal, ldaf, ldad, ldar, ldast, getelement.

Store into an array element from the operand stack: stab, stas, stai,
stal, staf, stad, staf, stast, putelement.

Get the length of an array: arraylen

Push a vector element value onto the operand stack: ldvsb, ldvub,
ldvs, ldvus, ldvi, ldvl, ldvf, ldvd, ldvr, ldvst, getelement.

Store into a vector element from the operand stack: stvb, stvs, stvi,
stvl, stvf, stvd, stvf, stvst, putelement.

Get the current length of a vector: vectorlen

Access closed-over-variable object elements: getcov, putcov.

Load a value that was bound to a closure object: getvalue.

Check instance object properties: checkcast, isinstanceof.

The getprop and getelement instructions respectively load object field
and array or vector object element values, boxing struct (including
primitive machine type (2.2.1)) values into box objects (2.2.7)
(including scalar objects) as needed.  The equivalent of a newbox
instruction (2.8.5) is used to create and initialize scalar objects.
The invokeprop instruction (2.8.8) boxes struct (including primitive
machine type) return values in the same way.

The putprop and putelement instructions store object references
respectively into object fields and array or vector object elements,
unboxing struct (including primitive machine type) values from box
(including scalar) objects as needed.

2.8.6 Struct Creation, Explosion and Manipulation

These instructions create and explode struct values and access their
components.

Create a new struct value: packst.

Explode a struct value into its component values: unpackst.

Access struct fields: getfieldstf, getstaticstf, putfieldstf,
putstaticstf.

Push an array struct element field onto the operand stack: ldastf.

Store an array struct element field from the operand stack: stastf.

Push a vector struct element field onto the operand stack: ldvstf.

Store a vector struct element field from the operand stack: stvstf.

2.8.7 Operand Stack Management Instructions

Operand stack management instructions: swap, swapn, dup, dupn, pop,
ror and rol.

The nop and label instructions perform no operation.

The wide instruction modifies the meaning of the immediately following
instruction.

2.8.8 Control Transfer Instructions

Control transfer instructions conditionally or unconditionally cause
the virtual machine to continue execution at other than the next
sequential instruction.

Conditional branch: ifnull, ifnotnull, ifeqr, ifner, ifzeqi, ifznei,
ifzlei, ifzlsi, ifzgei, ifzgti, ifcmpeqi, ifcmpnei, ifcmplei,
ifcmplsi, ifcmpgei, ifcmpgti.

Multi-way conditional branch: tableswitch, lookupswitch.

Unconditional branch: jump

Conditional branch instructions test or compare int or reference type
values on the operand stack.  Conditional branches on sbyte, ubyte,
short, ushort and bool values are done using int comparison
instructions.  Conditional branches on float or double values are done
by issuing the appropriate compare instruction (2.8.2) followed by an
int comparison instruction.

2.8.9 Method Invocation and Return Instructions

All method invocation instructions take a fixed number of arguments.
Argument values are on the operand stack, left to right with the
right-most argument value on the top of the operand stack.  Method
invocation instructions pop their arguments off the operand stack and
pass them to the target method in the first n local registers, where n
is the number of arguments.  Result values are returned on the top of
the operand stack.

The invokevirtual, invokeinterface, invokesuper, invokeprop and
invokepropv instructions are used to invoke polymorphic methods, while
the calldirect, callindirect, call and callv instructions are used to
invoke non-polymorphic methods.  The invoke* instructions pass a
reference to the object (or receiver object) used to look up the
target method as their first parameter value.  The call* instructions
do not.

invokevirtual invokes an instance method of a receiver object,
dispatching on the receiver object's type.  The target method must not
be static or final, or an instance, class or interface initialization
method.

invokeinterface invokes an interface method on a receiver object whose
concrete type is unknown, searching the methods implemented by the
receiver object class to find the actual method target.

invokesuper invokes an instance method of one of the current class's
(2.3) superclasses rather than the instance method, if any, of the
same name in the current class.  The target method must not be static,
but may be final or an instance initializer method.  The receiver
object must be the first parameter of the current method (the current
method's "this" object reference).  If the target method is an
instance initializer method, the invokesuper instruction must be
located within the bytecode of an instance initializer method.

invokeprop and invokepropv invoke an instance method with a given name
and signature on, or the method bound into a closure object value in a
field with a given name of, a receiver object whose type is unknown at
compile time.  They can be thought of as invokevirtual instructions
that reflect on the receiver object's type to find a target method.
The receiver object's class's methods and fields are both examined.

calldirect invokes a static, or private or final instance method.  The
target method cannot be an instance, class or interface initialization
method.  If the target method is a private or final instance method,
the first argument must be a reference to an object of the class
defining the target method.

callindirect invokes the method bound into a closure object in such a
way that values bound into the closure object can be referenced by
getvalue instructions within the target method.  Closure objects are
created by newclosure instructions.  They encapsulate a target method
and bound values.  Bound values are values or variables referenced
from the target method that exist in the lexical scope that defines
the target method.  Bound values include both constants and
closed-over-variable objects.  Closed-over-variable objects
encapsulate free variables local to that lexical scope.

call and callv invoke the method bound into a closure object just as
does callindirect, except that the type of the target method is
unknown at compile time.

The virtual machine supports type-specialized instructions that return
values to the calling method and a single general return value
instruction.  The type-specialized return instructions are reti, retl,
retf, retd and retr.  They respectively return int, long, float,
double and reference type values.  The ret instruction returns no
value to the calling method.  The rett (return struct) instruction is
a general return instruction that can be used to return any or no
value.

2.8.9.1 Parameter Types

sbyte, ubyte, short, ushort and bool values are represented on the
operand stack as int values.  Actual parameter values of these types
must be within the range of values for the formal parameter type.
Explicit down-conversion instructions on actual parameter values of
these types may thus be necessary.

The type of an actual reference parameter value must be assignment
compatible (...) with its corresponding formal parameter type.
Explicit checkcast instructions on actual parameter values of
reference type may thus be necessary.

2.8.9.2 Return Types

sbyte, ubyte, short, ushort and bool values are represented on the
operand stack as int values.  The reti instruction therefore returns
values of these types as int values, but the returned value must be
within the range of values for the return type.  An explicit
down-conversion instruction on the return value may thus be necessary.

The reti and retl instructions are used to respectively return int and
uint, and long and ulong values.  Since values of each of these type
pairs are the same width, a conversion instruction is optional.

The type of a reference return value must be assignment compatible
(...) with the method return type.  A checkcast instruction on the
return value may thus be necessary.

2.8.10 Throwing Exceptions

Exceptions can be explicitly thrown at any point during execution by
the throwe instruction.

2.8.11 Debug Instructions

Debug information can be provided inline using the debug, debugfile
and debugline instructions.  The first maps names to local registers.
The second two correlate bytecode offsets with file names and line
numbers.


3. The abc File Format

An abc file contains the definitions of a number of classes and
interfaces and an optional entry point.  An abc file need not be
represented as an actual file instance. It can, for example, reside in
a computer system's memory rather than in a file system.

An abc file consists of a stream of 8-bit bytes. Two, four and eight
byte values are constructed by reading in one or more bytes in little
endian order, least significant byte first.

Integral values are represented by both fixed and variable length
encodings.  Signed values are represented in twos-complement form.

The fixed length encodings are

sbyte   signed byte value in the range -128 through 127.

ubyte   unsigned byte value in the range 0 through 255.

short   signed two-byte value in the range -32768 through 32767.

ushort  unsigned two-byte value in the range 0 through 65535.

bool    unsigned byte value in the range 0 through 1.

int     signed four-byte value in the range -2**31 through 2**31 - 1.

uint    unsigned four-byte value in the range 0 through 2**32 - 1.

long    signed eight-byte value in the range -2**63 through 2**63 - 1.

ulong   unsigned eight-byte value in the range 0 through 2**64 - 1.

soff    signed 3-byte value in the range -2**23 through 2**23 - 1.

float   4-byte IEEE-754 single precision floating point numbers.

double  8-byte IEEE-754 double precision floating point numbers.

The variable length encodings use one to ten bytes, depending on the
magnitude of the encoded value.  Each byte contributes its low seven
bits to the value.  If the eighth (high) bit is set, then the next
byte is part of the value.  For signed values, the seventh bit of the
last byte is the sign bit and is extended to fill the rest of the
decoded value.  For unsigned values, the seventh bit of the last byte
is part of the value's magnitude, thus the last byte is zero-extended
to complete the decoded value.

The variable length encodings are

s8      signed up-to-two-byte value in the range -128 through 127.

u8      unsigned up-to-two-byte value in the range 0 through 255.

s16     signed up-to-three-byte value in the range -32768 through 32767.

u16     unsigned up-to-three-byte value in the range 0 through 65535.

u30     unsigned up-to-four-byte value in the range 0 through 2**30 - 1.

s32     signed up-to-five-byte value in the range -2**31 through 2**31 - 1.

u32     unsigned up-to-five-byte value in the range 0 through 2**32 - 1.

s64     signed up-to-ten-byte value in the range -2**63 through 2**63 - 1.

u64     unsigned up-to-ten-byte value in the range 0 through 2**64 - 1.

An abc file is divided into a fixed length header and a set of top
level variable length arrays containing constant integral, floating
point, and string values, method, class, and interface references and
definitions, and literal definitions.  Top level array elements are
referenced by indices embedded in other top level array elements or
bytecode instructions.  Top level array elements may be variable
length and stored successively without padding or alignment, thus such
elements cannot be directly indexed.

abc file structures are represented using C-like structures in
little-endian format for both byte and bitfield sequences.  abc file
structures are termed "items".

3.1 The Internal Form of Names

3.1.1 Fully Qualified Names

Class, interface and struct names that appear in an abc file are
represented in a fully qualified form as a sequence of package names
followed by a class, interface or struct name.  Name components are
separated by the '.'  (dot) code point.  Other than the UTF-8 dot and
';' (semi-colon) code points, or unless otherwise constrained, fully
qualified name components may be composed of any code points in the
UTF-8 code space.

3.1.2 Unqualified Names

Names of methods, fields and local variables (including formal
parameters) are stored as UTF-8 character strings and must not contain
the Unicode code points for '.' (dot), '&' (ampersand), '@' (at sign),
';' (semi-colon), '[' (left square bracket), '{' (left squigly
bracket), '(' (left parenthesis), '<' (left angle bracket) or '>'
(right angle bracket).

3.1.3 Qualified Struct Field Names

Struct (2.2.2) field names that are bytecode instruction arguments are
represented in qualified form as a sequence of unqualified names
(3.1.2) separated by '.' code points.  Each component is a struct
field name.  If there is more than one component, the second and
subsequent components are the names of fields in nested struct values.
A fully qualified struct field name is one where all but the the last
component denotes a struct value.

3.2 Type Descriptors

The types of fields or methods are represented by type descriptor
strings whose code points are drawn from the UTF-8 code space.

3.2.1 Grammar

Type descriptors are specified using a grammar in which terminals are
represented by single characters in quotes, such as 'V' (a single
capital V character is the terminal), and non-terminal names by normal
type.  Zero or more terminals or non-terminals are represented by a
terminal or non-terminal name followed by a '*' character (note that
the '*' character is also a terminal), while one or more terminals or
non-terminals are represented by a terminal or non-terminal name
followed by a "+" character.

Non-terminal definitions consist of a non-terminal name followed by a
':' character, followed on subsequent lines by possible expansions,
one per line.

type-descriptor:
	type

element-type:
	type

type:
	base-type
	class-type
	array-type
	vector-type
	parameter-type
	closure-type
	method-signature
	closed-over-variable-type
	struct-type
	reference-type

base-type:
	'Z'
	'B'
	'b'
	'S'
	's'
	'I'
	'i'
	'J'
	'j'
	'F'
	'D'

class-type:
	'&' class-name ';'

array-type:
	'[' element-type

vector-type:
	'{' element-type

parameter-descriptor:
	type

return-descriptor:
	type
	void-descriptor

void-descriptor:
	'V'

parameter-type:
	'(' parameter-descriptor* ')'

closure-type:
	parameter-type return-descriptor

method-signature:
	closure-type

closed-over-variable-type:
	'C' type+ ';'

struct-type:
	'@' ':' type+ ';'

struct-type:
	'@' struct-name ':' type+ ';'

reference-type:
	'*'

The class-name and struct-name non-terminals are fully qualified names
(3.1.1).

3.2.2 Semantics

The interpretation of type descriptors is as follows.

Descriptor		Interpretation
--------------------------------------
V			void
Z			bool
B			sbyte
b			ubyte
S			short
s			ushort
I			int
i			uint
J			long
j			ulong
F			float
D			double
& class-name ;		ordinary class object reference type
[			one dimension of an array object reference type
{			one dimension of a vector object reference type
(			closure object reference type, method
			signature, and method parameter signature
C type-list ;		cov object reference type
@ struct-name : type-list ;
			struct type
*			one of '&', '[', '{', '(', or 'C': which one is
			unknown at compile time

The ActionScript 4 language's scalar types correspond to type
descriptors as follows.

AS4 Type        Type Descriptor
-------------------------------
byte		b
int		I
uint		i
long		J
ulong		j
float		F
double		D

The 'V' descriptor corresponds to the AS4 pseudo-type "void" and
literally means "no value".  There are no void objects and thus no
references to void objects.

The 'B', 'S' and 's' descriptors represent primitive machine types
(2.2.1) that correspond to scalar types that are not supported by the
AS4 language.

The '&' descriptor is used for all ordinary class types.  That is,
those whose names are not '[', '{', '(' and 'C' descriptors.

A parameter-type descriptor is used in contexts where only a parameter
type list is required, for example by newinstance.  Such contexts are
orthogonal to those in which a full method-signature or closure-type
descriptor is required, thus there is no need to lexically distinguish
their descriptors from each other.

method-signature descriptors for virtual methods do not include a
receiver object reference parameter-descriptor.

There may be no more than 255 parameter-descriptor descriptors in a
parameter-type.  If an implicit receiver object reference is
necessary, the maximum number of parameter-descriptor descriptors is
254.

The '@' descriptor includes both a struct name and a field type list
to allow for the possibility of anonymous struct types.

The '*' descriptor represents the type of a reference to an object of
a class not known at compile time.

3.2.3 Type Names and Class Names

A type name is a type descriptor.  For classes described by class-type
descriptors, the name of a class is not the same as the name of its
type.  Such a class's name is a fully qualified name (a class-name in
the grammar described in 3.2.1), while its type name is a class-type
descriptor.

3.3 abc File

And abc file is laid out as follows.

abc_file
{
	header_info header
	s32 int[int_count]
	u32 uint[uint_count]
	s64 long[long_count]
	u64 ulong[ulong_count]
	f32 float[float_count]
	d64 double[double_count]
	string_info string[string_count]
	string_info type[type_count]
	literal_info literal[literal_count]
	method_info method[method_count]
	class_info class[class_count]
	method_body_info method_body[method_body_count]
}

An abc file consists of a single header_info item followed by twelve
arrays whose lengths and locations in the abc file are given in the
header_info item.

Array elements are referenced by index values embedded in bytecode
instructions and method_info, class_info, literal_info and
method_body_info items.  Index values are one-based: the first element
of an array is referenced using an index value of one, not zero.  An
index value of zero is reserved to mean at least "no value" and may
have another meaning depending on the array being indexed.

The int, uint, long, ulong, float and double arrays contain constant
scalar values.  Integral values are variable-length encoded, while
float and double values are full-width 32- and 64-bit values
respectively.  Zero index values mean the value zero in each encoding.

The string array contains constant UTF-8 strings other than type
descriptor strings.  The type array contains type descriptor strings.
The method array contains symbolic references to methods.  The class
array contains class descriptions.  Symbolic references to classes are
type descriptors.  The literal array contains object literal and
default method argument values.  The method_body array contains method
descriptions, which latter include the bytecode instructions for a
method.

3.3.1 header_info

A header_info item is laid out as follows.

{
	uint		magic		// "abc\n"
	uint		version		// "001\0"
	uint		checksum
	ubyte[20]	signature
	uint		file_size
	uint		header_size
	uint		int_count
	uint		int_offset
	uint		uint_count
	uint		uint_offset
	uint		long_count
	uint		long_offset
	uint		ulong_count
	uint		ulong_offset
	uint		float_count
	uint		float_offset
	uint		double_count
	uint		double_offset
	uint		string_count
	uint		string_offset
	uint		type_count
	uint		type_offset
	uint		method_count
	uint		method_off
	uint		class_count
	uint		class_off
	uint		literal_count
	uint		literal_off
	uint		method_body_count
	uint		method_body_off
	uint		entry
}

3.3.1.1 magic

The magic field always contains the value 0x0a636261, which reads as
the string "abc\n".

3.3.1.2 version

The version field contains an 3-digit ascii-encoded null-terminated
version string.  The first version value was 0x00313030, which reads
as the string "001\0".

3.3.1.3 checksum

The checksum field contains a CRC-32C checksum of the rest of the file
(everything except the magic, version and checksum fields) that can be
used to identify ABC file corruption.  See

http://en.wikipedia.org/wiki/Cyclic_redundancy_check

and

http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=231911

Note that computation of a CRC-32C value is often supported by
hardware, for example the Intel SSE4.2 instruction CRC32.  It is thus
expected to be fast.

3.3.1.4 signature

The signature field contains an SHA-1 hash of the rest of the file
(everything except the magic, version, checksum and signature fields)
that can be used to uniquely identify an abc file.  See

http://en.wikipedia.org/wiki/SHA-1

3.3.1.5 file_size

The file size field contains the byte size of the entire abc file.

3.3.1.6 header_size

The header_size field contains the value 0x8c.

3.3.1.7 The count Fields

The int_count, uint_count, long_count, ulong_count, float_count,
double_count, string_count, type_count, method_count, class_count,
literal_count and method_body_count fields respectively contain the
number of entries in the int, uint, long, ulong, float, double,
string, type, method, class, literal and method_body arrays.

3.3.1.8 The offset Fields

The int_off, uint_off, long_off, ulong_off, float_off, double_off,
string_off, type_off, method_off, class_off, literal_off and
method_body_off fields respectively contain byte offsets from the
beginning of the abc file to the int, uint, long, ulong, float,
double, string, type, method, class, literal and method_body arrays.

3.3.1.9 entry_point

The entry_point field describes the program entry point.  It contains
either an index into the method array, or zero to indicate that there
is no program entry point defined by the abc file.  When the abc file
is run, the referenced method's enclosing class, termed an "entry
point class", is loaded, linked and initialized.  The referenced
method, which is the program entry point, is then invoked by the
virtual machine.  The referenced method must be public, static, have
no arguments and have a void return type.

If no entry point method is otherwise specified to the virtual machine
upon startup, it is an error to attempt to execute an abc file which
contains a value of zero in the header_info entry field.

In AS4, any class may define a static, void, zero-argument method
named "main".  During construction of an abc file, an AS4 compiler
will set the entry_point field to the top level abc file method array
index of such a main method.  More than one class in an abc file may
define a main method, thus it is up to the compiler or program that
executes an abc file to determine which definition is the entry point.

3.3.2 The string Array

String array elements are string_info items, laid out as follows.

string_info
{
	u30 size
	ubyte utf8[size]
}

The UTF-8 characters making up the string are in the utf8 array.
Because UTF-8 uses a variable length code point encoding, individual
characters are not directly indexable.

An index value of zero is a reference to the null string.

3.3.3 The type Array

The type array consists of string_info items that contains all the
type descriptor strings referenced in the abc file.  There are fifteen
predefined entries represented by index values in the range zero to
fourteen.  The entries and their indices are

	        0   // reserved to mean "no type"
"Z"	        1
"B"	        2
"b"	        3
"S"	        4
"s"	        5
"I"	        6
"i"	        7
"J"	        8
"j"	        9
"F"	        10
"D"	        11
'*'	        12
"V"	        13
"&lang.String;" 14

The fifteen predefined entries are not actually present in the type
array.  Type array indices in the abcfile must be offset by negative
fifteen before being used to index the actual type array.

3.3.4 The method Array

The method array consists of method_info items, which are symbolic
references to methods that may not be defined in the abc file
containing the reference.  The method_body array contains method
definitions in the form of method_body_info items (3.3.7).

method_info
{
	u30 sig
	u30 ret
	u30 name
	u30 class
	ubyte flags
	u30 defaults		// optional
	u30 param_names[]	// optional
}

The sig field is an index into the string array for the method's
parameter-type descriptor (3.2).

The ret field is an index into the type array for the method's
return-descriptor descriptor (3.2).

The name field is an index into the string array for the name of the
method.  In the case of a nested method (for example, an AS4 function
defined within an AS4 class method or another function), the name
field is informational, and may be zero (that is, the null string).

The class field is an index into the type array for the class-type
descriptor (3.2) for the method's enclosing class.

The flags field is laid out as follows.  Bit mask values are in
comments.

ubyte flags
{
	is_interface_method : 1,	// 0x01
	is_static	    : 1,	// 0x02
	is_getter	    : 1,	// 0x04
	is_setter	    : 1,	// 0x08
			    : 1,	// 0x10
	native		    : 1,	// 0x20
	has_default_params  : 1,	// 0x40
	has_param_names	    : 1,	// 0x80
}

If is_interface_method is set, the method is an interface method,
which means it is virtual and has no definition.

If is_static is set, the method is static.  That is, it is a class
method and thus non-polymorphic.

If is_getter is set, the method is an AS4 getter method and may be
referenced as if it were a field.  Getter methods may not have
parameters and must have a non-void result.

If is_setter is set, the method is an AS4 setter method and may be
referenced as if it were a field.  Setter methods must have a single
parameter and a void result.

If is_native is set, the method's implementation is in native code.

If has_default_params is set, the defaults field is present.  It is an
index into the top level abc file literal array (3.3.6) for the
literal_info item that supplies the default parameter values.  The
values supplied by the indexed literal_info item are the default
values of the trailing (or rightmost) formal parameters (3.3.6.4)

If has_param_names is set, then the param_names array is present.
Each element in param_names is an index into the string array for a
formal parameter name.  The number of elements in param_names is the
number of formal parameters and is derivable from the sig type
descriptor.  param_names elements appear in source code declaration
order.

3.3.5 The class Array

The class array consists of class_info items, each of which defines a
class, interface or struct.

class_info
{
	u30 name
	u30 super_name
	ubyte flags
	u30 interface_count
	u30 interface[interface_count]
	u30 cinit
	u30 iinit_count
	u30 iinit[iinit_count]
	u30 literal_count
	u30 literal[literal_count]
	u30 trait_count
	traits_info trait[trait_count]
}

The name and super_name fields are indexes into the type array for the
type name strings for the class and its immediate superclass.
The flags field is laid out as follows.  Bit mask values are in
comments.

ubyte flags
{
	is_abstract	: 1,	// 0x01
	is_final	: 1,	// 0x02
	is_interface	: 1,	// 0x04
	is_struct	: 1,	// 0x08
	has_finals	: 1,	// 0x10
			: 3;	// 0xE0
}

If is_abstract is one, an instance of the class cannot be created.
Some or all methods may be interface methods and have no definition.

If is_final is one, the class may not be subclassed.

If is_interface is one, the class may contain only virtual interface
methods (no static methods and no method definitions) and only static
final fields.  interface_count, cinit and iinit_count must be zero.

If is_struct is one, the class_info item describes a struct rather
than a class.  All methods must be static and all fields non-static
and final.  interface_count, cinit and iinit_count must be zero.

If has_finals is one, literal_count must be at least one, and the
first index in the literal array (that is, literal[0]) references a
literal_info item (3.3.6) whose field_items array supplies a value for
each write-once field whose value can be represented by a value_info
item (3.3.6.2).  The literal_info item's type field must be an index
into the top level abc file type array for the class's type name
(3.2.3).  The literal_info item must be invisible to literal object
reflection.

The interface_count field is the number of interfaces the class
implements.  Each interface array element is an index into the type
array for the type name string for an interface type.  Interfaces and
structs do not implement interfaces, thus the interface_count field
must be zero for them.

The cinit field is an index into the method array for the class
initializer method.  The class initializer method must be static and
have no arguments and a void result.  Interfaces and structs have no
class initializer method, thus the cinit field must be zero for them.

The iinit field is the number of instance initializer methods for the
class.  Each iinit array element is an index into the method array for
an instance initializer method.  Interfaces and structs have no
instance initializer method, thus the iinit field must zero for them.

The trait_count field is the number of traits defined by the class.
Each trait array element is a traits_info item (3.3.5.1) that
describes a trait.

The literal_count field is the number of literal values associated
with the class.  Each literal array element is an index into the top
level abc file literal array (3.3.6).

3.3.5.1 Trait

Each trait is described by a traits_info item.

traits_info
{
	u30 name
	ubyte kind
	ubyte data[]
	u30 literal_count
	u30 literal[literal_count]
}

The name field is an index into the string array for the name of the
trait.

The kind field uses one bit for a trait kind discriminant that
describes the content of the data array, two bits for an accessibility
descriptor and the remaining four bits for flags.

The literal_count field is the number of literal values associated
with the trait.  Each literal array element is an index into the top
level abc file literal array (3.3.6).

The trait kind discriminant type is as follows.

enum trait_kind
{
	trait_field	= 0,	// field
	trait_method	= 1 	// method
}

The two-bit accessibility descriptor type is as follows.

enum accessibility
{
	private   = 0,	// Accessible only by the defining class
	public    = 1,	// Accessible by any class in any package
	protected = 2,	// Accessible only by the defining class
	      		// and its subclasses
	internal  = 3	// Accessible only by classes in the
			// defining package
}

The kind field is laid out as follows.  Bit mask values are in
comments.

kind
{
	trait_kind	: 1,	// 0x01
			: 1,	// 0x02
	is_final	: 1,	// 0x04
	is_override	: 1,	// 0x08
	has_literals	: 1,	// 0x10
	accessibility	: 2,	// 0x60
	is_static	: 1	// 0x80
}

is_final is one if either (1) the trait is a method and the method
cannot be overridden in a subclass, or (2) the trait is a write-once
field.  Write-once fields are written exactly once in a class (if
is_static is one) or instance (if is_static is zero) initializer
method.

is_override is one if the trait is a method and overrides a method of
the identical name and signature in a superclass.  Such a method is a
virtual (or instance) method.

If has_literals is one, the literal_count and literal fields are
present.

is_static is one if the trait is a static class trait.  If is_static
is zero, a trait is an instance trait.  Non-static methods are
instance (or virtual) methods.  Non-static fields are instance fields.

If the trait is a field, then the traits_info item's ubyte data array
consists of a trait_field item laid out as follows.

trait_field
{
	u30 type
}

The type field is an index into the type array for the type name
string for the type of the field.

If the trait is a method, then the traits_info item's ubyte data array
consists of a trait_method item laid out as follows:

trait_method
{
	u30 method
}

The method field is an index into the method array for the method_info
item (3.3.4) for the method.

3.3.6 The Literal Array

The literal array consists of literal_info items, each of which
defines two serialized value streams.  A literal_info item supplies
and object literal value or a set of default method parameter values.

The literal_info item is laid out as follows.

literal_info
{
	u30 type
	u30 field_item_count
	item_info field_items[field_item_count]
	u30 init_item_count
	value_info init_items[init_item_count]
}

The type field is an index into the type array for a class-type
descriptor (3.2).  Its value is zero for literal_info items that
define default method parameter values.

The field_item_count field is the number of elements in the
field_items array.

The init_item_count field is the number of elements in the init_items
array.

3.3.6.1 item_info

An item_info item is a name/constant value pair.  It can, for example,
be used to supply an initial constant value for a field of an object
literal's class.

{
	u30 name
	value_info value
}

The name field is an index into the string array for a field name.

The value field is a value_info item describing the field's initial
value.

3.3.6.2 value_info

A value_info item supplies a single constant value of a given type. It
can, for example, be used to describe a single method argument value.

{
	ubyte type
	u30 index
}

The type field is an index into the type array for the value's type
name string.  It cannot be zero and must be one of the predefined type
array indices defined in section 3.3.3.  It is used to select the top
level array which contains constant values of the indexed type.  For
example, if the type field is 14, which is the predefined type array
index for the lang.String type, the selected top level array is the
string array.

The index field is an index into the top level array denoted by the
type field value.

3.3.6.3 Object Literals

If type references a class-type descriptor, each element of the
field_items array describes an initial value for a named field and
each element of the init_items array describes an instance initializer
method argument value.  The init_items array elements are in one of
the class's instance initializer method's formal parameter order.
Thus, a parameter-type descriptor (3.2) can be derived from them.
That descriptor determines which instance initializer method is
referenced.  If init_item_count is zero, then the instance initializer
method has no arguments.

During class initialization (...) a Class object and an Object array
(that is, the array's descriptor is "[&lang.Object;") referenced by
the Class object are created by the virtual machine.  Each array
element is a reference to a literal object (also created by the VM)
whose initial value is specified by a literal_info item.

For each literal object, the equivalent of a newinstance instruction
is executed that invokes an instance initializer method with the
argument values specified by the init_items array.  The first argument
value is supplied by init_items[0], the second by init_items[1], and
so on. The last argument value is supplied by
init_items[init_item_count - 1].  Then, the equivalent of a putfield
instruction is executed for each field and value specified by the
field_items array.

3.3.6.4 Default Method Parameters

If type is zero, then if the literal_info item is referenced by a
method_info item's defaults field (3.3.4), field_item_count must be
zero, the field_items array must be empty and the init_items array
supplies values for the method's default parameters.  init_item_count
is the number of such parameters.  It is not the total number of
method parameters.

Since default parameters are the trailing (rightmost) parameters, the
first potential default argument value is supplied by init_items[0],
the second by init_items[1], and so on.  The last potential default
argument value is supplied by init_items[init_item_count - 1].

3.3.7 The method_body Array

The method_body array consists of method_body_info items, each of
which defines a method.  Methods are always enclosed within a class,
and are class methods (static or instance) or methods defined within
another method.  The latter are represented as class static methods.

method_body_info
{
	u30 method
	u30 box
	u30 max_stack
	u30 local_count
	u30 literal_count
	u30 literal[literal_count]
	u30 exception_count
	exception_info exception[exception_count]
	u30 code_length
	ubyte code[code_length]
}

The method field is an index into the method array for the associated
method_info item.

The box field is an index into the type array for the
closed-over-variable-type descriptor (3.2) that specifies the types of
the values bound to closure objects when they are created.  The value
of box may be, and is always for class methods, zero, in which case
there are no bound values.

Though the box field references a cov-type descriptor, that does not
imply that there exists an actual cov object reference bound into
every closure object.  The cov-type descriptor is simply a convenient
way to specify a bound value type list.

The max_stack field is the maximum depth of the operand stack during
method execution.

The local_count field is the number of local registers.

The literal_count field is the number of literal values associated
with the method body.  Each literal array element is an index into the
top level abc file literal array (3.3.6).

The exception_count field is the number of entries in the exception
array.  Each exception array element (3.3.7.2) describes an exception
handler.

The code_length field is the length, in bytes, of the code array.  The
code array contains the bytecode instructions for the method.

3.3.7.1 AS4 Function Names

AS4 functions defined within AVMS methods are defined in the enclosing
class as static class methods.  They do not require names for correct
virtual machine operation since they are referred to by method array
indices, but a compiler may generate names if desired.

If so, names for named functions should be analogous to fully
qualified names and be strings composed of dot-separated elements
starting with the outermost enclosing method name.  Synthetic names
for anonymous functions can generated if desired, in which case their
text should be bracketed by percent characters.

For example, given the following AS4 code

class foo {
  public function bar() {
    ...
    function g() {
      ...
      var f : (int) => int =
          function (i: int) : int { return 12; }
      ...
      function q() {
      }
      ...
    }
    var d : (double) => double =
      function (d: double) : double { return 12.0; }
    var e : (float) => float =
      function (f: float) : float { return 12.0; }
}

the abc file name of bar() is "bar", of g() is "bar.g", of q() is
"bar.g.q", of the anonymous function assigned to f is "bar.g.%func%0",
of the anonymous function assigned to d is "bar.%func%0" and of the
anonymous function assigned to e is "bar.%func%1".  All except bar()
are static methods of class foo.  Note that since bar() is not
declared with the "static" keyword, it is by default a virtual method.

3.3.7.2 exception_info

An exception_info item defines an exception handler and is laid out as
follows.

{
	u30 from
	u30 to
	u30 target
	u30 exc_type
	u30 var_name
}

The from field is the starting index in the code array from which the
exception is enabled.  The to field is the ending index in the code
array from which the exception is disabled.  The code array index
range over which the exception is enabled is the right side open
interval [from, to).

The target field is the index in the code array to which control is
transferred when an exception of type exc_type is encountered while
executing instructions that lie within the code array index range
[from, to).

The exc_type field is an index into the type array for the type name
string for the exception class for which the handler is enabled.

The var_name field is an index into the string array for the name of
the variable that is to receive the exception object when the
exception is thrown and control is transferred to the target location.
If the value of var_name is zero then there is no name associated with
the exception object.


4 Loading, Linking and Initialization


5 Instruction Set

A virtual machine instruction consists of a one-byte opcode specifying
the operation to be performed, followed by zero or more
compiler-generated arguments.

5.1 Instruction Description Format

Instructions are represented by the following format, in alphabetical
order.

mnemonic

Operation

	A short description of the instruction.

Format

	mnemonic
	operand1
	operand2
	...

Forms

	mnemonic = opcode value

Operand Stack

	..., value1, value2 ->
	..., value3

Description

	A longer description of the instruction, describing its
	operation, argument(s), operand(s) and result(s) in detail.

Linking Exceptions

	Exceptions that may be thrown as a result of linking classes
	referenced by the instruction, one per line in the order in
	which they must be thrown.

Runtime Exceptions

	Exceptions that may be thrown during execution of the
	instruction, one per line in the order in which they must be
	thrown.

Notes

	Clarifying comments not strictly part of the specification.

An instruction's mnemonic is its name.  Each Format line represents a
single 8-bit byte.  Each Form of an instruction is a more particular
name if multiple instructions are represented by an entry, along with
opcode values in both decimal and hexadecimal notation.

Instruction operand values generated by a compiler are termed
"arguments" and appear in the Forms section.  Instruction operand values
on the operand stack are termed "operands".

The effect of an instruction's execution on the operand stack of the
current frame is represented textually by before and after execution
states.  The stack grows from left to right, with each operand value
represented separately.  Thus

	..., value1, value2 ->
	..., value3

means that the instruction pops and consumes two stack operand values,
value1 and value2, and pushes a single result value, value3.  value2
is the top stack element before execution and value3 the top stack
element after execution.  The unaffected portion of the operand stack
is represented by an ellipsis (...).

5.2 Instructions

addd

Operation

	Add double

Format

	addd

Forms

	addd = 163 (0xa3)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type double.  They are
	popped from the operand stack.  The double result is value1 +
	value2.  The result is pushed onto the operand stack.

	The result is governed by the rules of IEEE 754 64-bit
	floating point arithmetic.

	Even though overflow, underflow or loss of precision may
	occur, addd never throws a runtime exception.


addf

Operation

	Add float

Format

	addf

Forms

	addf = 162 (0xa2)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type float.  They are popped
	from the operand stack.  The float result is value1 + value2.
	The result is pushed onto the operand stack.

	The result is governed by the rules of IEEE 754 32-bit
	floating point arithmetic.

	Even though overflow, underflow or loss of precision may
	occur, addf never throws a runtime exception.


addi

Operation

	Add integer

Format

	addi

Forms

	addi = 160 (0xa0)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type int or uint.  They are
	popped from the operand stack.  The int or uint result is
	value1 + value2.  The result is pushed onto the operand stack.

	If both operands are int, the result is the low-order 32 bits
	of the true two's-complement mathematical result, represented
	as an int.  On overflow, the sign of the result may not be the
	same as the sign of the mathematical sum.

	If both operands are uint, the result is the low-order 32 bits
	of the true mathematical result, represented as a uint.  That
	is, the mathematical result is truncated to 32 bits.


addl

Operation

	Add long

Format

	addl

Forms

	addl = 161 (0xa1)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type long or ulong.  They
	are popped from the operand stack.  The long or ulong result
	is value1 + value2.  The result is pushed onto the operand
	stack.

	If both operands are long, the result is the low-order 64 bits
	of the true two's-complement mathematical result, represented
	as a long.  On overflow, the sign of the result may not be the
	same as the sign of the mathematical sum.

	If both operands are ulong, the result is the low-order 64
	bits of the true mathematical result, represented as a ulong.
	That is, the mathematical result is truncated to 64 bits.

	addl never throws a runtime exception.


andi

Operation

	Bitwise AND integer

Format

	andi

Forms

	andi = 198 (0xc6)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type int or uint.  The int
	or uint result is the bitwise AND of value1 and value2.  The
	result is pushed onto the operand stack.


andl

Operation

	Bitwise AND long

Format

	andl

Forms

	andl = 199 (0xc7)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type long or ulong.  The
	long or ulong result is the bitwise AND of value1 and value2.
	The result is pushed onto the operand stack.


arraylen

Operation

	Load array length

Format

	arraylen

Forms

	arraylen = 9 (0x09)

Operand Stack

	..., arrayref ->
	..., length

Description

	arrayref is a reference to an array object on top of the
	operand stack.  Pop it and push the length of the referenced
	array as an int value.


call

Operation

	Invoke a static (non-polymorphic) method indirectly, boxing
	any scalar result

Format

	call
	ubyte	count
	u30	sig

Forms

	call = 231 (0xe7)

Operand Stack

	...[, arg1[, ..., argn]], objectref ->
	..., resultref

Description

	count is the number of stacked argument values arg1 through
	argn.  sig is an index into the top level abc file type array
	of a method-signature descriptor (3.2).  sig is generated by
	the compiler from the types of the stacked argument values.
	sig's return type must be '*'.  objectref's static type
	(2.2.8.1) must be a reference type (2.2.8).

	If objectref is not a reference to a closure object (created
	by a newclosure instruction), a TypeError is thrown.  A target
	method and zero or more values are bound into the closure
	object.  If the target method's signature is not compatible
	(...) with sig, an AbstractMethodError is thrown.

	[ "is compatible with sig" means, for the time being, "has the
	same number of parameters as sig" ]

	The target method's enclosing class is initialized (...) if it
	has not already been initialized.

	The argument values are on the operand stack just below
	objectref.  The number, type and order of the values must be
	consistent with sig.  The value just beneath objectref is the
	last (rightmost) argument value, the value just beneath that
	is the second-to-last argument value, and so on.  arg1 is the
	first (leftmost) argument value.

	The equivalent of a "coerce arg-type formal-type" instruction
	is executed on each argument value, where arg-type is the
	corresponding parameter type in sig and formal-type is the
	corresponding parameter type in the matching method's
	method-signature descriptor.  The order in which argument
	values are coerced is unspecified.

	objectref and the coerced argument values are popped from the
	operand stack.  A new frame is created on the virtual machine
	stack for the target method.  The coerced argument values are
	consecutively written into local registers in the new frame,
	with the coerced value of arg1 in local register 0, and so on,
	with the coerced value of argn in local register n - 1.  The
	values bound into the closure object are passed in such a way
	that they can be obtained in the target method using getvalue
	instructions.  The new frame is then made the current frame
	and the virtual machine PC register set to the opcode of the
	first instruction of the target method.  Execution continues
	at that instruction.

	If the target method is native, the platform-dependent code
	for the native method is bound into the virtual machine if
	that has not already been done.  The argument values are
	passed to the native method and the native code invoked in a
	platform and implementation-dependent fashion.  The values
	bound into the closure object are inaccessible from the native
	code.  If the native method returns a value, it is converted
	in a platform and implementation-dependent fashion to a value
	of the method's return type and pushed onto the operand stack.

	Upon return from the target method, a return value is on top
	of the operand stack.  If the return value is of a reference
	type, it is left on the operand stack unchanged.

	Otherwise, if the return value is a primitive machine type
	(2.2.1) value, the equivalent of a "packst scalar-struct,
	newbox scalar-struct" instruction sequence is executed to box
	the return value, where scalar-struct is the struct-type
	descriptor (3.2) corresponding to the target method's return
	type.  A reference to the resulting scalar object replaces the
	original primitive machine type value on top of the operand
	stack.

	Otherwise, the return value is a struct value and the
	equivalent of a "newbox struct-type" instruction is executed
	to box the return value, where struct-type is the struct-type
	descriptor (3.2) for the target method's return type.  A
	reference to the resulting box object replaces the struct
	value on the operand stack.

Runtime Exceptions

	If objectref is null, a NullPointerError is thrown.

	If objectref does not refer to a closure object, a TypeError
	is thrown.

	If the signature of the method bound into the closure is not
	compatible with sig, an AbstractMethodError is thrown.

	If the method is native and the code that implements it cannot
	be bound into the VM, an UnsatisfiedLinkError is thrown.

	Other runtime exceptions may be thrown during execution of the
	equivalent of the coerce or newbox instructions.

Notes

	The call instruction always returns an object reference (that
	is, the return type is always '*') because the return type
	cannot be known by the compiler.

	For primitive machine (2.2.1) or struct (2.2.2) type return
	values, the equivalent of a newbox instruction is executed to
	produce a reference to a scalar or box object.  Because box
	objects are immutable, the VM is free to implement a caching
	scheme whereby a reference to an existing rather than newly
	created scalar or box object is pushed onto the operand stack.

	Even though primitive machine type return values of byte,
	ubyte, short, ushort and bool type are represented as int
	values on the operand stack, the result is of the
	corresponding scalar class type, not of the scalar class
	corresponding to int.  No type information is lost.

	The call instruction is intended to be used in contexts in
	which a return value is required.  Use the callv instruction
	in contexts where a return value is not required.


calldirect

Operation

	Invoke a static (non-polymorphic) method directly

Format

	calldirect
	u30	method
	ubyte	0

Forms

	calldirect = 238 (0xee)

Operand Stack

	...[, arg1[, ..., argn]] ->
	...

Description

	method is an index into the top level abc file method array.
	The method's enclosing class is referenced by the class field
	in the indexed method_info item.  The referenced method is
	resolved (...).  The resolved method must not be an instance
	method, or an instance, class or interface initialization
	method.  It must be static and not abstract.

	If the method is successfully resolved, its enclosing class is
	initialized (...) if it has not already been initialized.

	The argument values are on top of the operand stack.  The
	number, type and order of the values must be consistent with
	the method's method-signature descriptor (3.2).  The value on
	top of the operand stack is the last (rightmost) argument
	value, the value just beneath it is the second-to-last
	argument value, and so on.  arg1 is the first (leftmost)
	argument value.

	The argument values are popped from the operand stack. A new
	frame is created on the virtual machine stack for the method.
	The argument values are consecutively written into local
	registers in the new frame, with arg1 in local register 0, and
	so on, with argn in local register n - 1.  The new frame is
	then made the current frame and the virtual machine PC
	register set to the opcode of the first instruction of the
	method.  Execution continues at that instruction.

	If the method is native, the platform-dependent code for the
	native method is bound into the virtual machine if that has
	not already been done.  The argument values are passed to the
	native method and the native code invoked in a platform and
	implementation-dependent fashion.  If the native method
	returns a value, it is converted in a platform and
	implementation-dependent fashion to a value of the method's
	return type and pushed onto the operand stack.

Linking Exception

	If the resolved method is an instance method, or an instance,
	class or interface initialization method, or is abstract, an
	IncompatibleClassChangeError is thrown.

Runtime Exception

	If the method is native and the code that implements it cannot
	be bound into the VM, an UnsatisfiedLinkError is thrown.

Notes

	The extra zero ubyte exists so that the VM is guaranteed
	enough space to rewrite the instruction.


callindirect

Operation

	Invoke a static (non-polymorphic) method indirectly

Format

	callindirect
	ubyte	count
	u30	sig

Forms

	callindirect = 239 (0xef)

Operand Stack

	...[, arg1[, ..., argn]], closureref ->
	...

Description

	count is the number of stacked argument values arg1 through
	argn.  sig is an index into the top level abc file type array
	of a method-signature descriptor (3.2).

	closureref is a reference to a closure object (created by a
	newclosure instruction).  A target method and zero or more
	values are bound into the closure object.  The target method's
	enclosing class is initialized (...) if it has not already
	been initialized.

	The argument values are on the operand stack just beneath
	closureref.  The number, type and order of the values must be
	consistent with the target method's method-signature
	descriptor (3.2).  The value just beneath closureref is the
	last (rightmost) argument value, the value just beneath that
	is the second-to-last argument value, and so on.  arg1 is the
	first (leftmost) argument value.

	closureref and the argument values are popped from the operand
	stack. A new frame is created on the virtual machine stack for
	the target method.  The argument values are consecutively
	written into local registers in the new frame, with arg1 in
	local register 0, and so on, with argn in local register n -
	1.  The values bound into the closure object are passed in
	such a way that they can be obtained in the target method
	using getvalue instructions.  The new frame is then made the
	current frame and the virtual machine PC register set to the
	opcode of the first instruction of the target method.
	Execution continues at that instruction.

	If the target method is native, the platform-dependent code
	for the native method is bound into the virtual machine if
	that has not already been done.  The argument values are
	passed to the native method and the native code invoked in a
	platform and implementation-dependent fashion.  The values
	bound into the closure object are inaccessible from the native
	code.  If the native method returns a value, it is converted
	in a platform and implementation-dependent fashion to a value
	of the method's return type and pushed onto the operand stack.

Runtime Exception

	If closureref is null, a NullPointerError is thrown.

	If the target method is native and the code that implements it
	cannot be bound into the VM, an UnsatisfiedLinkError is
	thrown.

Notes

	sig must match closureref's type and is provided only for
	verification purposes.


callv

Operation

	Invoke a static (non-polymorphic) method, discarding any
	return value

Format

	callv
	ubyte	count
	u30	sig

Forms

	callv = 232 (0xe8)

Operand Stack

	...[, arg1[, ..., argn]], closureref ->
	...

Description

	The callv instruction operates exactly as does the call
	instruction, except that:

	1. The matching method's return type may be void.

	2. If the matching method's return type is not void, the
	return value is popped from the operand stack and discarded.
	Because the return value is discarded, callv does not box a
	primitive machine (2.2.1) or struct (2.2.2) type return value.

Notes

	The callv instruction is intended to be used in contexts in
	which a return value is not required.  Use the call
	instruction in contexts where a return value is required.


cfillnewarray

Operation

	Create a new one-dimensional array object from constant values

Format

	cfillnewarray
	u30	type
	u30	length
	[u30	value1[, ..., valuen]]

Forms

	cfillnewarray = 227 (0xe3)

Operand Stack

	... ->
	..., arrayref

Description

	type is an index into the top level abc file type array for
	the array-type descriptor (3.2) for the object to allocate.
	length is the number of elements in the array to be created.
	length must not be negative, but may be zero.

	value1 through valuen are indices into a top level abc file
	constant array that contains initial values for the new
	array's elements.  There must be length index values.  The
	array element type is used to select which constant array
	contains the initial values.  The first index value references
	the initial value for the first array element, the second
	index value references the initial value for the second
	element, and so on.  The last index value references the
	initial value for the last element.  If length is zero, there
	are no index values.

	The array element type must be a primitive machine type
	(2.2.1) or the String class (for which the descriptor is
	"&lang.String;").  If the array element type is sbyte, ubyte,
	short, ushort, int or bool, the selected top level abc file
	constant array is the int array.  If the element type is uint,
	long, ulong, float, double or String, the selected top level
	abc file constant array is respectively the uint, long, ulong,
	float, double or string array.

	The referenced top level abc file array element primitive
	machine type values must all be in range for the specified
	array element type.

	Memory is allocated from the heap (2.3.3) for a new
	uninitialized array of the specified length and type.  Its
	elements are set to the values specified by value1 through
	valuen.

	A reference to the new object is pushed onto the operand
	stack.

Runtime Exception

	An OutOfMemoryError is thrown if there is no space for the new
	object in the heap.


cfillnewvector

Operation

	Create a new one-dimensional vector object from constant
	values

Format

	cfillnewvector
	u30	type
	u30	length
	[u30	value1, ..., valuen]

Forms

	cfillnewvector = 1, 227 (0x01, 0xe3)

Operand Stack

	... ->
	..., vectorref

Description

	type is an index into the top level abc file type array for
	the vector-type descriptor (3.2) for the object to allocate.
	length is the number of elements in the vector to be created.
	length must not be negative, but may be zero.

	value1 through valuen are indices into a top level abc file
	constant array that contains initial values for the new
	vector's elements.  There must be length index values.  The
	vector element type is used to select which constant array
	contains the initial values.  The first index value references
	the initial value for the first vector element, the second
	index value references the initial value for the second
	element, and so on.  The last index value references the
	initial value for the last element.  If length is zero, there
	are no index values.

	The vector element type must be a primitive machine type
	(2.2.1) or the String class (for which the descriptor is
	"&lang.String;").  If the vector element type is sbyte, ubyte,
	short, ushort, int or bool, the selected top level abc file
	constant array is the int array.  If the element type is uint,
	long, ulong, float, double or String, the selected top level
	abc file constant array is respectively the uint, long, ulong,
	float, double or string array.

	The referenced top level abc file array element primitive
	machine type values must all be in range for the specified
	vector element type.

	Memory is allocated from the heap (2.3.3) for a new
	uninitialized vector of the specified length and type.  Its
	elements are set to the values specified by value1 through
	valuen.

	A reference to the new object is pushed onto the operand
	stack.

Runtime Exception

	An OutOfMemoryError is thrown if there is no space for the new
	object in the heap.


checkcast

Operation

	Check whether object is of a given type

Format

	checkcast
	u30	type

Forms

	checkcast = 150 (0x96)

Operand Stack

	..., objectref ->
	..., objectref

Description

	type is an index into the type array for the type name string
	for the target class.  It must denote the Object type or one
	of its subtypes, and thus must index an interface (2.2.3),
	array (2.2.4), vector (2.2.4), closure (2.2.5) or ordinary
	class (2.2.3) type name.

	objectref must be an object reference (2.2.8).  If it is null,
	the operand stack is left unchanged.

	Otherwise, the named interface, array, vector, closure or
	ordinary class is resolved (...).  If objectref can be cast to
	the resolved type (that is, it is a reference to an object
	whose class is a subclass of the resolved class), the operand
	stack is left unchanged.  Otherwise, a ClassCastError is
	thrown.

	objectref can be cast to the resolved class if it refers to an
	instance of the resolved class or one of its subclasses.  If
	the resolved class is an interface, then objectref must
	reference an object that implements that interface.

	A class C is a subclass of another class B under the following
	conditions.

	1. C and B are the same.

	2. C's type is the null type.

	3. If C extends B, then C is a subclass of B.

	4. If C is an interface that extends B, then C is a subclass
	of B.

	5. If B is an interface and C implements B, then C is a
	subclass of B.

	5.  If C is a closure class, then it is a subclass of B if C's
	type is a subtype of B's.  For types Ti, T, Si and S, a
	closure type of the form (T1, ... , Ti) => T is a subtype of
	(S1, ... , Si) => S if Tm is a subtype of Sm for all m in
	1..i, and T is a subtype of S.

Runtime Exception

	If objectref cannot be cast to the resolved type, a
	ClassCastError is thrown.

Notes

	The checkcast instruction performs the same check as the
	isinstanceof instruction.

	Because the type argument denotes the Object class or one of
	its subclasses, references to box or closed-over-variable
	objects will provoke a ClassCastError.


cmpd

Operation

	Compare double

Format

	cmpd<op>

Forms

	cmpdg = 155 (0x9b)
	cmpdl = 156 (0x9c)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type double.  They are
	popped from the operand stack and a floating point comparison
	is performed.

	The int value 1, 0, or -1 is pushed onto the operand stack
	according to whether value1 is greater than, equal to or less
	than value2.

	If one or the other or both of value1 and value2 are NaN, then
	the int value 1 or -1 is pushed onto the operand stack
	according to whether the instruction is cmpdg or cmpdl.

	Floating point comparison is done according to the rules if
	IEEE-754.  All values other than NaN are ordered, with
	negative infinity less than and positive infinity greater than
	all finite values.  Positive and negative zero are equal.

Notes

	The cmpdg and cmpdl instructions differ only in their
	treatment of NaN operand(s).


cmpf

Operation

	Compare float

Format

	cmpf<op>

Forms

	cmpfg = 153 (0x99)
	cmpfl = 154 (0x9a)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type float.  They are popped
	from the operand stack and a floating point comparison is
	performed.

	The int value 1, 0, or -1 is pushed onto the operand stack
	according to whether value1 is greater than, equal to or less
	than value2.

	If one or the other or both of value1 and value2 are NaN, then
	the int value 1 or -1 is pushed onto the operand stack
	according to whether the instruction is cmpfg or cmpfl.

	Floating point comparison is done according to the rules if
	IEEE-754.  All values other than NaN are ordered, with
	negative infinity less than and positive infinity greater than
	all finite values.  Positive and negative zero are equal.

Notes

	The cmpfg and cmpfl instructions differ only in their
	treatment of NaN operand(s).


cmpl

Operation

	Compare signed long

Format

	cmpl

Forms

	cmpl = 151 (0x97)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 must be of type long or ulong, as must value2.
	value1's type may differ from value2's.  They are popped from
	the operand stack and a signed long comparison is performed.

	The int value 1, 0, or -1 is pushed onto the operand stack
	according to whether value1 is greater than, equal to or less
	than value2.


cmpu

Operation

	Compare unsigned integer

Format

	cmpu

Forms

	cmpu = 145 (0x91)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 must be of type int or uint, as must value2.  value1's
	type may differ from value2's.  They are popped from the
	operand stack and an unsigned integer comparison is performed.

	The int value 1, 0, or -1 is pushed onto the operand stack
	according to whether value1 is greater than, equal to or less
	than value2.


cmpul

Operation

	Compare unsigned long

Format

	cmpul

Forms

	cmpul = 152 (0x98)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 must be of type long or ulong, as must value2.
	value1's type may differ from value2's.  They are popped from
	the operand stack and an unsigned long comparison is
	performed.

	The int value 1, 0, or -1 is pushed onto the operand stack
	according to whether value1 is greater than, equal to or less
	than value2.


coerce

Operation

	Coerce a value from one type to another

Format

	coerce
	u30	from-type
	u30	to-type

Forms

	coerce = 144 (0x90)

Operand Stack

	..., value ->
	..., result

Description

	from-type and to-type are indices into the top level abc file
	type array for the type names of the operand value and target
	types.  The type of the value on top of the operand stack must
	be from-type.  to-type denotes the type to which the top of
	stack value is to be coerced.

	If either from-type or to-type is a primitive machine (2.2.1)
	or struct (2.2.2) type, the other must not be the Object type
	or one of its subtypes.

	If from-type and to-type are identical, the operand stack is
	left unchanged.

	If both from-type and to-type are struct types, and they are
	not the same type, a TypeError is thrown.  Otherwise, the
	operand stack is left unchanged.

	If both from-type and to-type are the Object type or one of
	its subtypes, the equivalent of a "checkcast to-type"
	instruction is executed.

	If from-type is a primitive machine type and to-type is a
	struct type, the equivalent of a "packst to-type" instruction
	is executed.

	If from-type is a struct type and to-type is a primitive
	machine type, from-type must denote a struct type with a
	single field whose type is to-type, and the equivalent of an
	"unpackst from-type" instruction is executed.

	If from-type is '*' and to-type is the Object type or one of
	its subtypes, the equivalent of a "checkcast to-type"
	instruction is executed.

	If from-type is '*', and to-type is not the Object type or one
	of its subtypes, the equivalent of an "unbox to-type"
	instruction is executed.

	If from-type is the Object type or one of its subtypes and
	to-type is '*', the operand stack is left unchanged.

	If from-type is a struct type and to-type is '*', the
	equivalent of a "newbox from-type" instruction is executed to
	box the operand value.

	If from-type is a primitive machine type and to-type is '*',
	the equivalent of a "packst scalar-struct, newbox
	scalar-struct" instruction sequence is executed to box the
	operand value, where scalar-struct is the struct-type
	descriptor (3.2) corresponding to from-type.

	Otherwise, both from-type and to-type are primitive machine
	types, and the equivalent of a "calldirect
	<from-type>to<to-type>" instruction is executed, where
	"<from-type>to<to-type>" is the name of a static conversion
	method on the scalar class corresponding to <from-type> that
	attempts to convert the operand value to a value of the target
	scalar type.  Conversion method semantics are defined in
	Appendix A.

	An example of the name of such a method is "DtoI" for
	conversions from double to int.  The name of the conversion
	method can be constructed by catenating the from-type name
	string, the string constant "to" and the to-type name string.
	The conversion method name is thus always a four-character
	string.

	The conversion methods are "almost pure" functions.  They have
	no side effects other than that they may throw an exception.

	The operation of the coerce instruction in tabular form:

       			      	               Target type
		                | primitive | struct |   *    | Object
        ------------------------|-----------|--------|--------|----------
	Operand type  primitive	| call      | packst | newbox | error
		      struct	| unpackst  | nop    | newbox | error
		      *		| unbox     | unbox  | nop    | checkcast
		      Object    | error     | error  | nop    | checkcast

Runtime Exceptions

	TypeError may be thrown by the coerce instruction.  Other
	runtime exceptions may be thrown by the invocation or
	execution of the conversion method or during execution of the
	equivalents of the unbox and newbox instructions.

Notes

	The coerce instruction is the virtual machine implementation
	of AS4 argument coercion, as required for the call, callv,
	invokeprop and invokepropv instructions.

	The wording "The equivalent of a calldirect instruction ..."
	allows the virtual machine to implement the conversion methods
	in any way it chooses.

	Because type array entries one through twelve denote the
	eleven scalar types and '*', from-type and to-type can be used
	to optimize execution of a coerce instruction.

	The type-specific conversion instructions (2.8.3) perform the
	same operations as the conversion methods, though without the
	possibility of throwing an exception.  For scalar to scalar
	coercions, the coerce instruction is a generalization of those
	instructions.

	The checkcast instruction (2.8.5) performs the same operation
	as a coerce instruction whose operand type is a reference type
	and whose target type is the Object type or one of its
	subtypes.

	Because the coerce instruction is expected to run more slowly
	than a type-specific conversion, checkcast, packst, unpackst,
	newbox or unbox instruction, compilers should, if at all
	possible, emit a type-specific conversion, checkcast, packst,
	unpackst, newbox or unbox instruction in preference to a
	coerce instruction.


d2f

Operation

	Convert double to float

Format

	d2f

Forms

	d2f = 223 (0xdf)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type double.  It is popped from the operand
	stack and converted to a float result using IEEE round to
	nearest mode.  The float result is pushed onto the operand
	stack.

	If value has a finite magnitude too small to be represented as
	a float it is converted to a zero of the same sign, while if
	it has a finite magnitude too large to be represented as a
	float it is converted to an infinity of same sign.

	A double NaN is converted to a float NaN.

Notes

	Loss of magnitude and precision information may occur.


d2i

Operation

	Convert double to signed integer

Format

	d2i

Forms

	d2i = 220 (0xdc)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type double.  It is popped from the operand
	stack and converted to an int result.  The int result is
	pushed onto the operand stack.

	If value is NaN, the result is zero.

	If value is positive infinity, the result is the maximum
	representable value of int type (MAXINT).  If the value is
	negative infinity, the result is the minimum representable
	value of int type (MININT).

	If the value is not a NaN or infinity, it is rounded to a
	signed integer value, rounding toward zero.  The result is
	MAXINT if the rounded result is larger than MAXINT.  The
	result is MININT if the rounded result is smaller than MININT.

Notes

	Loss of both magnitude and precision information may occur.


d2l

Operation

	Convert double to signed long

Format

	d2l

Forms

	d2l = 222 (0xde)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type double.  It is popped from the operand
	stack and converted to a long result.  The long result is
	pushed onto the operand stack.

	If value is NaN, the result is zero.

	If value is positive infinity, the result is the maximum
	representable value of long type (MAXLONG).  If value is
	negative infinity, the result is the minimum representable
	value of long type (MINLONG).

	If value is not a NaN or infinity, it is rounded to a signed
	integer value, rounding toward zero.  The result is MAXLONG if
	the rounded result is larger than MAXLONG.  The result is
	MINLONG if the rounded result is smaller than MINLONG.

Notes

	Loss of both magnitude and precision information may occur.


d2u

Operation

	Convert double to unsigned integer

Format

	d2u

Forms

	d2u = 221 (0xdd)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type double.  It is popped from the operand
	stack and converted to a uint result.  The uint result is
	pushed onto the operand stack.

	If value is NaN, the result is zero.

	If value is positive infinity, the result is the maximum
	representable value of uint type (MAXUINT).  If value is
	negative infinity, the result is zero.

	If value is not a NaN or infinity, it is rounded to a signed
	integer value, rounding toward zero.  The result is MAXUINT if
	the rounded result is larger than MAXUINT.  The result is zero
	if the rounded result is less than zero.

Notes

	Loss of magnitude, precision and sign information may occur.


d2ul

Operation

	Convert double to unsigned long

Format

	d2ul

Forms

	d2ul = 1, 221 (0x01, 0xdd)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type double.  It is popped from the operand
	stack and converted to a ulong result.  The ulong result is
	pushed onto the operand stack.

	If value is NaN, the result is zero.

	If value is positive infinity, the result is the maximum
	representable value of ulong type (MAXULONG).  If value is
	negative infinity, the result is zero.

	If value is not a NaN or infinity, it is rounded to a signed
	integer value, rounding toward zero.  The result is MAXULONG
	if the rounded result is larger than MAXULONG.  The result is
	zero if the rounded result is less than zero.

Notes

	Loss of magnitude, precision and sign information may occur.


debug

Operation

	Debug information

Format

	debug
	u30	type
	u30	name
	u30	reg

Forms

	debug = 1, 0 (0x01, 0x00)

Operand Stack

	... ->
	...

Description

	type specifies what sort of debug information the debug
	instruction provides.  It is ignored.  name is an index into
	the top level abc file string array for a string that is the
	name to associate with a local register.  reg is the local
	register's number.  The local register number may or may not
	be valid in the current method.

	The name string is used to label whatever value is in
	local register number reg for all subsequent instructions,
	unless overridden by execution of another debug instruction.

	Otherwise, a debug instruction is equivalent to a nop
	instruction.

Notes

	The effect of the execution of a debug instruction crosses
	method invocation boundaries.


debugfile

Operation

	File name debug information

Format

	debugfile
	u30	name

Forms

	debugfile = 1, 2 (0x01, 0x02)

Operand Stack

	... ->
	...

Description

	name is an index into the top level abc file string array for
	a string that is a source file name.  Subsequent instructions
	are considered to have been derived from that source file
	until the next debugfile instruction is executed.

	A debugfile instruction must be executed before any debugline
	instruction is executed.

	Otherwise, a debugfile instruction is equivalent to a nop
	instruction.

Notes

	The effect of a debugfile instruction crosses method
	boundaries.


debugline

Operation

	Line number debug information

Format

	debugfile
	u30	line

Forms

	debugline = 1, 1 (0x01, 0x01)

Operand Stack

	... ->
	...

Description

	line is a source file line number.  Subsequent instructions
	are considered to have been derived from that line in the
	source file specified by the most recently executed debugfile
	instruction until the next debugline instruction is executed.

	A debugfile instruction must be executed before any debugline
	instruction is executed.

	Otherwise, a debugline instruction is equivalent to a nop
	instruction.

Notes

	The effect of a debugline instruction crosses method
	boundaries.


dec<type>

Operation

	Decrement local register

Format

	deci
	u30	reg
	s32	inc

	decl
	u30	reg
	s32	inc

Forms

	deci = 190 (0xbe)
	decl = 191 (0xbf)

Operand Stack

	... ->
	...

Description

	Decrement the value in local register number reg by value inc.

	The deci instruction decrements an int or uint local register
	value, while the decl instruction decrements a long or ulong
	local register value.

Notes

	The inci, incl, deci and decl instructions are intended to be
	used to increment and decrement loop induction variables,
	typically array indices.


divd

Operation

	Divide double

Format

	divd

Forms

	divd = 181 (0xb5)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type double.  They are
	popped from the operand stack.  The double result is value1 /
	value2.  The result is pushed onto the operand stack.

	The result is governed by the rules of IEEE 754 64-bit
	floating point arithmetic.

	Even though division by zero, overflow, underflow or loss of
	precision may occur, divd never throws a runtime exception.


divf

Operation

	Divide float

Format

	divf

Forms

	divf = 180 (0xb4)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type float.  They are popped
	from the operand stack.  The float result is value1 / value2.
	The result is pushed onto the operand stack.

	The result is governed by the rules of IEEE 754 32-bit
	floating point arithmetic.

	Even though division by zero, overflow, underflow or loss of
	precision may occur, divf never throws a runtime exception.


divi

Operation

	Divide signed integer

Format

	divi

Forms

	divi = 176 (0xb0)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type int.  They are popped
	from the operand stack.  The int result is value1 / value2.
	The result is pushed onto the operand stack.

	The result is rounded toward zero.

	If the dividend is the largest possible negative int value and
	the divisor is -1, overflow occurs and the result is equal to
	the dividend.  No exception is thrown on overflow.

Runtime Exception

	If the value of the divisor is zero, an ArithmeticError is
	thrown.


divl

Operation

	Divide signed long

Format

	divl

Forms

	divl = 178 (0xb2)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type long.  They are popped
	from the operand stack.  The int result is value1 / value2.
	The result is pushed onto the operand stack.

	The result is rounded toward zero.

	If the dividend is the largest possible negative int value and
	the divisor is -1, overflow occurs and the result is equal to
	the dividend.  No exception is thrown on overflow.

Runtime Exception

	If the value of the divisor is zero, an ArithmeticError is
	thrown.


divu

Operation

	Divide unsigned integer

Format

	divu

Forms

	divu = 177 (0xb1)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type uint.  They are popped
	from the operand stack.  The int result is value1 / value2.
	The result is pushed onto the operand stack.

	The result is rounded toward zero.

Runtime Exception

	If the value of the divisor is zero, an ArithmeticError is
	thrown.


divul

Operation

	Divide unsigned long

Format

	divul

Forms

	divul = 179 (0xb3)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type ulong.  They are popped
	from the operand stack.  The int result is value1 / value2.
	The result is pushed onto the operand stack.

	The result is rounded toward zero.

Runtime Exception

	If the value of the divisor is zero, an ArithmeticError is
	thrown.


dup

Operation

	Duplicate the top operand stack value

Format

	dup

Forms

	dup = 3 (0x03)

Operand Stack

	..., value ->
	..., value, value

Description

	Duplicate the top operand stack value and push the duplicated
	onto the operand stack.


dupn

Operation

	Duplicate top operand stack values

Format

	dupn
	ubyte	count

Forms

	dupn = 8 (0x08)

Operand Stack

	..., value1, ..., valuen ->
	..., value1, ..., valuen, value1, ..., valuen

Description

	The top count operand stack values are duplicated.  The
	duplicated values are pushed onto the operand stack in left to
	right order, with the duplicate of the original stack top
	value (the "rightmost" value) becoming the new top of stack
	value.

Notes

	"dupn 0" is equivalent to a nop instruction.  "dupn 1" is
	equivalent to a dup instruction.


f2d

Operation

	Convert float to double

Format

	f2d

Forms

	f2d = 219 (0xdb)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type float.  It is popped from the operand
	stack and converted to a double result.  The double result is
	pushed onto the operand stack.

	A float NaN is converted to a double NaN, and a float infinity
	is converted to a double infinity.

Notes

	The conversion is exact.


f2i

Operation

	Convert float to signed integer

Format

	f2i

Forms

	f2i = 216 (0xd8)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type float.  It is popped from the operand
	stack and converted to an int result.  The int result is
	pushed onto the operand stack.

	If value is NaN, the result is zero.

	If value is positive infinity, the result is the maximum
	representable value of int type (MAXINT).  If value is
	negative infinity, the result is the minimum representable
	value of int type (MININT).

	If value is not a NaN or infinity, it is rounded to a signed
	integer value, rounding toward zero.  The result is MAXINT if
	the rounded result is larger than MAXINT.  The result is
	MININT if the rounded result is smaller than MININT.

Notes

	Loss of both magnitude and precision information may occur.


f2l

Operation

	Convert float to signed long

Format

	f2l

Forms

	f2l = 217 (0xd9)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type float.  It is popped from the operand
	stack and converted to a long result.  The long result is
	pushed onto the operand stack.

	If value is NaN, the result is zero.

	If value is positive infinity, the result is the maximum
	representable value of long type (MAXLONG).  If value is
	negative infinity, the result is the minimum representable
	value of long type (MINLONG).

	If value is not a NaN or infinity, it is rounded to a signed
	integer value, rounding toward zero.  The result is MAXLONG if
	the rounded result is larger than MAXLONG.  The result is
	MINLONG if the rounded result is smaller than MINLONG.

Notes

	Loss of both magnitude and precision information may occur.


f2u

Operation

	Convert float to unsigned integer

Format

	f2u

Forms

	f2u = 218 (0xda)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type float.  It is popped from the operand
	stack and converted to a uint result.  The uint result is
	pushed onto the operand stack.

	If value is NaN, the result is zero.

	If value is positive infinity, the result is the maximum
	representable value of uint type (MAXUINT).  If value is
	negative infinity, the result is zero.

	If value is not a NaN or infinity, it is rounded to a signed
	integer value, rounding toward zero.  The result is MAXUINT if
	the rounded result is larger than MAXUINT.  The result is zero
	if the rounded result is less than zero.

Notes

	Loss of magnitude, precision and sign information may occur.


f2ul

Operation

	Convert float to unsigned long

Format

	f2ul

Forms

	f2ul = 1, 218 (0x01, 0xda)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type float.  It is popped from the operand
	stack and converted to a ulong result.  The ulong result is
	pushed onto the operand stack.

	If value is NaN, the result is zero.

	If value is positive infinity, the result is the maximum
	representable value of uint type (MAXUINT).  If value is
	negative infinity, the result is zero.

	If value is not a NaN or infinity, it is rounded to a signed
	integer value, rounding toward zero.  The result is MAXUINT if
	the rounded result is larger than MAXUINT.  The result is zero
	if the rounded result is less than zero.

Notes

	Loss of magnitude, precision and sign information may occur.


fillnewarray

Operation

	Create a new one-dimensional array object from values

Format

	fillnewarray
	u30	type
	u30	length

Forms

	fillnewarray = 226 (0xe2)

Operand Stack

	...[, value1[, ..., valuen]] ->
	..., arrayref

Description

	type is an index into the top level abc file type array for
	the array-type descriptor (3.2) for the object to allocate.
	length is the number of elements in the array to be created.
	length is not negative, but may be zero.

	The type of each value must be compatible (...) with the array
	element type.  If the element type is sbyte, ubyte, short,
	ushort or bool, then each value's type must be int.  If the
	element type is int or uint, then each value's type be one of
	int or uint.  If the element type is long or ulong, then each
	values's type must be one of long or ulong.  If the element
	type is float or double, then each value's type must be float
	or double respectively.  If the element type is a reference
	type, then each value must be of a type that is assignment
	compatible (...)  with the element type.

	Memory is allocated from the heap (2.3.3) for a new
	uninitialized array of the specified length and type.  Its
	elements are set to the values on top of the operand stack.
	There must be length values on top of the operand stack.  They
	are popped.  The initial value for the last array element is
	on top of the operand stack, that for the next-to-last element
	just beneath, and so on.  The initial value for the first
	array element is length - 1 slots below the top of the operand
	stack.  If length is zero, no values are popped from the
	operand stack.

	If the values to be stored are of type int, their high order
	bits are truncated as necessary to fit into each array
	element.

	A reference to the new object is pushed onto the operand
	stack.

Runtime Exception

	An OutOfMemoryError is thrown if there is no space for the new
	object in the heap.

Notes

	The stores to the array elements are done as for by sta<type>
	instructions.


fillnewvector

Operation

	Create a new one-dimensional vector object from values

Format

	fillnewvector
	u30	type
	u30	length

Forms

	fillnewvector = 1, 226 (0x01, 0xe2)

Operand Stack

	...[, value1[, ..., valuen]] ->
	..., vectorref

Description

	type is an index into the top level abc file type array for
	the vector-type descriptor (3.2) for the object to allocate.
	length is the number of elements in the vector to be created.
	length is not negative, but may be zero.

	The type of each value must be compatible (...) with the
	vector element type.  If the element type is sbyte, ubyte,
	short, ushort or bool, then each value's type must be int.  If
	the element type is int or uint, then each value's type be one
	of int or uint.  If the element type is long or ulong, then
	each values's type must be one of long or ulong.  If the
	element type is float or double, then each value's type must
	be float or double respectively.  If the element type is a
	reference type, then each value must be of a type that is
	assignment compatible (...)  with the element type.

	Memory is allocated from the heap (2.3.3) for a new
	uninitialized vector of the specified length and type.  Its
	elements are set to the values on top of the operand stack.
	There must be length values on top of the operand stack.  They
	are popped.  The initial value for the last vector element is
	on top of the operand stack, that for the next-to-last element
	just beneath, and so on.  The initial value for the first
	vector element is length - 1 slots below the top of the
	operand stack.  If length is zero, no values are popped from
	the operand stack.

	If the values to be stored are of type int, their high order
	bits are truncated as necessary to fit into each vector
	element.

	A reference to the new object is pushed onto the operand
	stack.

Runtime Exceptions

	An OutOfMemoryError is thrown if there is no space for the new
	object in the heap.

Notes

	The stores to the vector elements are done as for by stv<type>
	instructions.


getcov

Operation

	Load closed-over-variable object element

Format

	getcov
	u30	type
	u30	index

Forms

	getcov = 118 (0x76)

Operand Stack

	..., covref ->
	..., value

Description

	type is an index into the top level abc file type array for a
	cov-type descriptor (3.2).  index is an index of an element in
	the cov-type descriptor's type list.

	covref is popped from the operand stack.  It must be a
	reference to an object of the referenced cov type.  The value
	of the indexed element in the object referenced by covref is
	fetched and pushed onto the operand stack.

	Values of type sbyte and short are signed-extended, and values
	of type ubyte, bool and ushort are zero-extended to an int
	value before being pushed onto the operand stack.  The value
	pushed is of type int.

Runtime Exception

	If the value of covref is null, the getcov instruction
	throws a NullPointerError.

Notes

	Cov object elements are referenced using getcov and putcov
	instructions rather than getfield and putfield, or lda and
	sta.  The VM can therefore choose the representation of cov
	objects independent of those for other objects.


getelement

Operation

	Load array or vector element

Format

	getelement

Forms

	getelement = 122 (0x7a)

Operand Stack

	..., objectref, index ->
	..., valueref

Description

	index must be a value of type int.

	objectref and index are popped from the operand stack.  If
	objectref is not a reference to an array or vector object, a
	TypeError is thrown.

	If objectref is a reference to an array object, its element
	type is used to fetch the value in the element of the array
	object indexed by index.

	If objectref is a reference to a vector object, its element
	type is used to fetch the value in the element of the vector
	object indexed by index.

	The fetched value is pushed onto the operand stack.

	Fetched values of type sbyte and short are signed-extended,
	and fetched values of type ubyte, bool and ushort are
	zero-extended to an int value.  The value pushed is of type
	int.

	If the array or vector element type is a primitive machine
	type (2.2.1), the equivalent of a "packst scalar-struct,
	newbox scalar-struct" instruction sequence is executed to box
	the value, where scalar-struct is the struct-type descriptor
	(3.2) corresponding to the array or vector element type.  A
	reference to the resulting scalar object replaces the
	primitive machine type value on the operand stack.

	If the array or vector element type is a struct type, the
	equivalent of a "newbox struct-type" instruction is executed
	to box the value, where struct-type is the struct-type
	descriptor (3.2) for the array or vector element type.  A
	reference to the resulting box object replaces the struct
	value on the operand stack.

Runtime Exceptions

	If objectref is null, a NullPointerError is thrown.

	If objectref does not refer to an array or vector object, a
	TypeError is thrown.

	Other runtime exceptions may be thrown during execution of the
	equivalent of the newbox instruction.

Notes

	The getelement instruction always pushes an object reference
	because the fetched value's type cannot be known by the
	compiler.

	For primitive machine (2.2.1) or struct (2.2.2) array or
	vector element types, the equivalent of a newbox instruction
	is executed to produce a reference to a scalar or box object.
	Because box objects are immutable, the VM is free to implement
	a caching scheme whereby a reference to an existing rather
	than newly created scalar or box object is pushed onto the
	operand stack.


getfield

Operation

	Load object field

Format

	getfield
	u30	class
	u30	field

Forms

	getfield = 114 (0x72)

Operand Stack

	..., objectref ->
	..., value

Description

	class is an index into the top level abc file type array for a
	class-type descriptor (3.2) for a class.  field is an index
	into the top level abc file string array for the name of a
	field within the referenced class.  The referenced field
	within the referenced class is resolved (...).

	The referenced class is initialized (...) if it has not
	already been initialized.

	objectref is popped from the operand stack.  It must be a
	reference to an object of the referenced class.  The value of
	the referenced field in the object referenced by objectref is
	fetched and pushed onto the operand stack.

	Values of type sbyte and short are signed-extended, and values
	of type ubyte, bool and ushort are zero-extended to an int
	value before being pushed onto the operand stack.  The value
	pushed is of type int.

Linking Exceptions

	Field resolution (...)  may throw an exception.

	If the referenced field is static (that is, is not an instance
	field), an IncompatibleClassChangeError is thrown.

Runtime Exception

	If the value of objectref is null, a NullPointerError is
	thrown.


getfieldstf

Operation

	Load struct field from object field

Format

	getfieldstf
	u30	class
	u30	field
	u30	struct-field

Forms

	getfieldstf = 1, 114 (0x01, 0x72)

Operand Stack

	..., objectref ->
	..., value

Description

	class is an index into the top level abc file type array for a
	class-type descriptor (3.2) for a class.  field is an index
	into the top level abc file string array for the name of a
	field within the referenced class.  The referenced field
	within the referenced class is resolved (...).  The type of
	the referenced class field must be a struct type.

	struct-field is an index into the top level abc file string
	array for a qualified struct field name (3.1.3).  It must
	denote a struct field within the referenced class field.

	The referenced class is initialized (...) if it has not
	already been initialized.

	objectref is popped from the operand stack.  It must be a
	reference to an object of the referenced class.  The value of
	the referenced struct field in the referenced class field in
	the object referenced by objectref is fetched and pushed onto
	the operand stack.

	Values of type sbyte and short are signed-extended, and values
	of type ubyte, bool and ushort are zero-extended to an int
	value before being pushed onto the operand stack.  The value
	pushed is of type int.

Linking Exceptions

	Class or struct field resolution (...)  may throw an
	exception.

	If the referenced class field is static (that is, is not an
	instance field), an IncompatibleClassChangeError is thrown.

Runtime Exception

	If the value of objectref is null, a NullPointerError is
	thrown.

Notes

	Nested struct values may be loaded by the getfieldstf
	instruction.


getprop

Operation

	Load object field by name

Format

	getprop
	u30	field

Forms

	getprop = 120 (0x78)

Operand Stack

	..., objectref ->
	..., valueref

Description

	field is an index into the top level abc file string array for
	the name of a field within objectref's class.

	objectref is popped from the operand stack.  If objectref is
	not a reference to an object, a TypeError is thrown.  The
	referenced field is resolved within objectref's class (...).

	The value of the referenced field in the object referenced by
	objectref is fetched and pushed onto the operand stack.

	Fetched values of type sbyte and short are signed-extended,
	and fetched values of type ubyte, bool and ushort are
	zero-extended to an int value.  The value pushed is of type
	int.

	If the field type is a primitive machine type (2.2.1), the
	equivalent of a "packst scalar-struct, newbox scalar-struct"
	instruction sequence is executed to box the fetched value,
	where scalar-struct is the struct-type descriptor (3.2)
	corresponding to the field's type.  A reference to the
	resulting scalar object replaces the primitive machine type
	value on the operand stack.

	If the field type is a struct type, the equivalent of a
	"newbox struct-type" instruction is executed to box the
	fetched value, where struct-type is the field's struct-type
	descriptor (3.2).  A reference to the resulting box object
	replaces the struct value on the operand stack.

Runtime Exceptions

	If objectref is null, a NullPointerError is thrown.

	If objectref does not refer to an object, a TypeError is
	thrown.

	If the referenced field is static (that is, is not an instance
	field), an IncompatibleClassChangeError is thrown.

	Field resolution may throw runtime exceptions.

	Other runtime exceptions may be thrown during execution of the
	equivalent of the newbox instruction.

Notes

	The getprop instruction is essentially an auto-reflecting
	getfield instruction.

	The getprop instruction always pushes an object reference
	because the fetched value's type cannot be known by the
	compiler.

	For primitive machine or struct type fields, the equivalent of
	a newbox instruction is executed to produce a reference to a
	scalar or box object.  Because box objects are immutable, the
	VM is free to implement a caching scheme whereby a reference
	to an existing rather than newly created scalar or box object
	is pushed onto the operand stack.


getstatic

Operation

	Load class static field

Format

	getstatic
	u30	class
	u30	field

Forms

	getstatic = 116 (0x74)

Operand Stack

	... ->
	..., value

Description

	class is an index into the top level abc file type array for a
	class-type descriptor (3.2) for a class or interface.  field
	is an index into the top level abc file string array for the
	name of a static field within the referenced class or
	interface.  The referenced field within the referenced class
	or interface is resolved (...)

	The referenced class or interface is initialized (...) if it
	has not already been initialized.

	The value of the referenced field is fetched and pushed onto
	the operand stack.

	Values of type sbyte and short are signed-extended, and values
	of type ubyte, bool and ushort are zero-extended to an int
	value before being pushed onto the operand stack.  The value
	pushed is of type int.

Linking Exception

	If the referenced field is not either a class static or
	interface field, the getstatic instruction throws an
	IncompatibleClassChangeError.


getstaticstf

Operation

	Load struct field from class static field

Format

	getstaticstf
	u30	class
	u30	field
	u30	struct-field

Forms

	getstaticstf = 1, 116 (0x01, 0x74)

Operand Stack

	... ->
	..., value

Description

	class is an index into the top level abc file type array for a
	class-type descriptor (3.2) for a class or interface.  field
	is an index into the top level abc file string array for the
	name of a static field within the referenced class or
	interface.  The referenced field within the referenced class
	or interface is resolved (...).  The type of the referenced
	class static field must be a struct type.

	struct-field is an index into the top level abc file string
	array for a qualified struct field name (3.1.3).  It must
	denote a struct field within the referenced class static
	field.

	The referenced class or interface is initialized (...) if it
	has not already been initialized.

	The value of the referenced struct field in the referenced
	class static field is fetched and pushed onto the operand
	stack.

	Values of type sbyte and short are signed-extended, and values
	of type ubyte, bool and ushort are zero-extended to an int
	value before being pushed onto the operand stack.  The value
	pushed is of type int.

Linking Exception

	If the referenced class field is not either a class static or
	interface field, the getstaticstf instruction throws an
	IncompatibleClassChangeError.

Notes

	Nested struct values may be loaded by the getstaticstf
	instruction.


getvalue

Operation

	Load a bound value

Format

	getvalue
	u30	index

Forms

	getvalue = 124 (0x7c)

Operand Stack

	... ->
	..., value

Description

	index is an index into the current method's bound value type
	descriptor.  The bound value type descriptor is a
	closed-over-variable-type descriptor (3.2) and is referenced
	by the box field in the method_body_info item (3.3.7) for the
	current method.

	The bound value indexed by index is pushed onto the stack.

	A getvalue instruction may only be used within the code for a
	method called by a callindirect instruction.

Notes

	The callindirect instruction arranges for a closure object's
	bound values to be made available in its target method using
	getvalue instructions.


i2sb

Operation

	Convert integer to signed byte

Format

	i2sb

Forms

	i2sb = 146 (0x92)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type int or uint.  It is popped from the
	operand stack, truncated to a signed byte and then
	sign-extended to an int result.  The int result is pushed onto
	the operand stack.

Notes

	The i2sb instruction will lose information if the high order
	24 bits of (value & 0xFFFFFF00) are not the same as that of
	the sign of the signed byte intermediate result.


i2d

Operation

	Convert signed integer to double

Format

	i2d

Forms

	i2d = 211 (0xd3)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type int.  It is popped from the operand
	stack and converted to a double result using IEE-754
	round-to-nearest mode.  The double result is pushed onto the
	operand stack.

Notes

	The conversion is exact because double values have 53
	significand bits.


i2f

Operation

	Convert signed integer to float

Format

	i2f

Forms

	i2f = 210 (0xd2)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type int.  It is popped from the operand
	stack and converted to a float result using IEE-754
	round-to-nearest mode.  The float result is pushed onto the
	operand stack.

Notes

	Loss of precision may result since float values have only 24
	significand bits.


i2l

Operation

	Convert signed integer to signed long

Format

	i2l

Forms

	i2l = 208 (0xd0)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type int.  It is popped from the operand
	stack and sign-extended to a long result.  The long result is
	pushed onto the operand stack.


i2u

Operation

	Convert signed to unsigned integer

Format

	i2u

Forms

	i2u = 209 (0xd1)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type int.  It is popped from the operand
	stack and reinterpreted as a uint.  The uint result is pushed
	onto the operand stack.

Notes

	The i2u instruction changes the type of the top of stack value
	from int to uint.  Otherwise it is a nop.


i2l

Operation

	Convert signed integer to signed long

Format

	i2l

Forms

	i2l = 208 (0xd0)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type int.  It is popped from the operand
	stack and sign-extended to a long result.  The long result is
	pushed onto the operand stack.

Notes

	The potential instruction i2ul can be composed from an i2l
	instruction followed by an l2ul instruction.


i2s

Operation

	Convert integer to signed short

Format

	i2s

Forms

	i2s = 148 (0x94)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type int or uint.  It is popped from the
	operand stack, truncated to a signed short and then
	sign-extended to an int result.  The int result is pushed onto
	the operand stack.

Notes

	The i2s instruction will lose information if the high order 16
	bits of (value & 0xFFFF0000) are not the same as that of the
	sign of the signed short intermediate result.


i2ub

Operation

	Convert integer to unsigned byte

Format

	i2ub

Forms

	i2ub = 147 (0x93)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type int or uint.  It is popped from the
	operand stack, truncated to an unsigned byte and then
	zero-extended to an int result.  The int result is pushed onto
	the operand stack.

Notes

	The i2ub instruction will lose information if any of the high
	order 24 bits of (value & 0xFFFFFF00) are not zero.


i2us

Operation

	Convert integer to unsigned short

Format

	i2us

Forms

	i2us = 149 (0x95)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type int or uint.  It is popped from the
	operand stack, truncated to an unsigned short and then
	zero-extended to an int result.  The int result is pushed onto
	the operand stack.

Notes

	The i2us instruction will lose information if any of the high
	order 16 bits of (value & 0xFFFF0000) are not zero.


i2z

Operation

	Convert integer to boolean

Format

	i2z

Forms

	i2z = 106 (0x6a)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type int or uint.  It is popped from the
	operand stack, truncated to a one-bit boolean value and then
	zero-extended to an int result.  The int result is pushed onto
	the operand stack.

Notes

	The i2z instruction will lose information if any of the high
	order 31 bits of (value & 0xFFFFFFFE) are not zero.


if<cond>r

Operation

	Branch on reference comparison

Format

	if<cond>r
	s24	offset

Forms

	ifeqr = 62 (0x3e)
	ifner = 63 (0x3f)

Operand Stack

	..., value1, value2 ->
	...

Description

	value1 and value2 must be of a reference type.  The reference
	types need not be related.  value1 and value2 are popped and
	compared.  For the ifeqr instruction, the comparison succeeds
	if value1 and value2 are references to the exact same object.
	For the ifner instruction, the comparison succeeds if value1
	and value2 are not references to the exact same object.

	If the comparison succeeds, the pc register is loaded with
	offset plus the address of the opcode of the immediately
	following instruction.

	If the comparison fails, the pc register is loaded with the
	address of the opcode of the immediately following
	instruction.

	The new pc value must be the address of an instruction opcode
	within the current method.

	Execution continues at the new pc address.


if<eqcond>st

Operation

	Branch on struct equality comparison

Format

	if<eqcond>st
	s24	offset
	u30	struct-type

Forms

	ifeqst = 1, 60 (0x01, 0x3c)
	ifnest = 1, 61 (0x01, 0x3d)

Operand Stack

	..., value1, value2 ->
	...

Description

	struct-type is an index into the top level abc file type array
	for a struct-type descriptor (3.2).

	value1 and value2 must be of struct types whose fields match
	in number and type order with the type denoted by struct-type.
	The types of corresponding scalar type (2.2.1) fields match if
	they are identical.  The types of corresponding struct type
	(2.2.2) fields match if, recursively, their fields match in
	number and type order.  The types of corresponding reference
	type (2.2.8) fields always match.

	value1 and value2 are popped and compared.  For the ifeqst
	instruction, the comparison succeeds if the value of each
	field of value1 is equal to the value of the corresponding
	field of value2.  For the ifnest instruction, the comparison
	succeeds if the value of any field of value1 is not equal to
	the value of the corresponding field of value2.

	Primitive integral type field values are equal if they are
	arithmetically equal.  float field values are equal if
	execution of a cmpfg or cmpfl instruction on them would push
	the int value 0 onto the operand stack.  double field values
	are equal if execution of a cmpdg or cmpdl instruction on them
	would push the int value 0 onto the operand stack.  Struct
	type field values are equal if their types match as described
	above and execution of an ifeqst instruction on them would
	result in a taken branch.
	
	Corresponding reference type field values are equal if the
	equivalent of the following pseudo-AS4 method returns true.

	public static function equal(a : *, b : *) : bool {
	  if (a === null) return b === null;
	  if (b === null) return false;
	  if (a is Object) { // Object or one of its subclasses
	    if (b is Object) {
	      return (a as Object).equal(b as Object);
	    }
	    return false;
	  }
	  if (a is Box) { // A box class, including scalar classes
	    if (b is Box) { // The same box class
	      return (a as Box).equal(b as Box);
	    }
	    return false;
	  }
	  return false;
	}

	The values taken on by the formal parameters a and b are
	respectively the values of the corresponding reference type
	fields of value1 and value2.

	Object.equal is a virtual method that may be overridden by an
	Object subclass.  For the Object class, it is defined by

	public function equal(other : Object) : bool {
	  return this === other;
	}

	Box.equal is a final virtual method defined by each box class
	that returns true if the corresponding field values of the
	objects to which they refer are equal as defined above.

	If the comparison succeeds, the pc register is loaded with
	offset plus the address of the opcode of the immediately
	following instruction.

	If the comparison fails, the pc register is loaded with the
	address of the opcode of the immediately following
	instruction.

	The new pc value must be the address of an instruction opcode
	within the current method.

	Execution continues at the new pc address.

Notes

	If one or more reference fields are involved in the
	comparison,

	1. Different if<eqcond>st instructions specifying the same
	struct-type and operating on the same values may return
	different results.

	2. if<eqcond>st instructions will be relatively inefficient
	compared to if<idcond>st instructions specifying the same
	struct-type.


if<idcond>st

Operation

	Branch on struct identity comparison

Format

	if<idcond>st
	s24	offset
	u30	struct-type

Forms

	ifidst = 1, 62 (0x01, 0x3e)
	ifnist = 1, 63 (0x01, 0x3f)

Operand Stack

	..., value1, value2 ->
	...

Description

	struct-type is an index into the top level abc file type array
	for a struct-type descriptor (3.2).

	value1 and value2 must be of struct types whose fields match
	in number and type order with the type denoted by struct-type.
	Corresponding field types must be identical.  The three struct
	types need not be otherwise related.

	value1 and value2 are popped and compared.  For the ifidst
	instruction, the comparison succeeds if the value of each
	field of value1 is identical to the value of the corresponding
	field of value2.  For the ifnist instruction, the comparison
	succeeds if the value of any field of value1 is not identical
	to the value of the corresponding field of value2.

	Primitive integral type (2.2.1) field values are identical if
	they are arithmetically equal.  float field values are
	identical if execution of a cmpfg or cmpfl instruction on them
	would push the int value 0 onto the operand stack.  double
	field values are identical if execution of a cmpdg or cmpdl
	instruction on them would push the int value 0 onto the
	operand stack.  Struct type (2.2.2) field values are identical
	if their types match as described above and execution of an
	ifidst instruction on them would result in a taken branch.
	Reference type (2.2.8) field values are identical if execution
	of an ifeqr instruction on them would result in a taken
	branch.

	If the comparison succeeds, the pc register is loaded with
	offset plus the address of the opcode of the immediately
	following instruction.

	If the comparison fails, the pc register is loaded with the
	address of the opcode of the immediately following
	instruction.

	The new pc value must be the address of an instruction opcode
	within the current method.

	Execution continues at the new pc address.


ifcmp<cond>i

Operation

	Branch on integer comparison.

Format

	ifcmp<cond>i
	s24	offset

Forms

	ifcmpeqi = 90 (0x5a)
	ifcmpnei = 91 (0x5b)
	ifcmplei = 92 (0x5c)
	ifcmplsi = 93 (0x5d)
	ifcmpgei = 94 (0x5e)
	ifcmpgti = 95 (0x5f)

Operand Stack

	..., value1, value2 ->
	...

Description

	value1 and value2 must be of int type.  They are popped and
	compared with each other.  The comparison succeeds if

	For ifcmpeqi, value1 == value2

	For ifcmpnei, value1 != value2

	For ifcmplei, value1 <= value2

	For ifcmplsi, value1 < value2

	For ifcmpgei, value1 >= value2

	For ifcmpgti, value1 > value2

	If the comparison succeeds, the pc register is loaded with
	offset plus the address of the opcode of the immediately
	following instruction.

	If the comparison fails, the pc register is loaded with the
	address of the opcode of the immediately following
	instruction.

	The new pc value must be the address of an instruction opcode
	within the current method.

	Execution continues at the new pc address.


ifnotnull

Operation

	Branch on non-null reference

Format

	ifnotnull
	s24	offset

Forms

	ifnotnull = 61 (0x3d)

Operand Stack

	..., objectref ->
	...

Description

	objectref must be of a reference type (2.2.8).  It is popped.

	If objectref is not equal to null, the pc register is loaded
	with offset plus the address of the opcode of the immediately
	following instruction.

	If objectref is equal to null, the pc register is loaded with
	the address of the opcode of the immediately following
	instruction.

	The new pc value must be the address of an instruction opcode
	within the current method.

	Execution continues at the new pc address.


ifnull

Operation

	Branch on null reference

Format

	ifnull
	s24	offset

Forms

	ifnull = 60 (0x3c)

Operand Stack

	..., objectref ->
	...

Description

	objectref must be of a reference type (2.2.8).  It is popped.

	If objectref is equal to null, the pc register is loaded with
	offset plus the address of the opcode of the immediately
	following instruction.

	If objectref is not equal to null, the pc register is loaded
	with the address of the opcode of the immediately following
	instruction.

	The new pc value must be the address of an instruction opcode
	within the current method.

	Execution continues at the new pc address.


ifz<cond>i

Operation

	Branch on integer comparison to zero.

Format

	ifz<cond>i
	s24	offset

Forms

	ifzeqi = 84 (0x54)
	ifznei = 85 (0x55)
	ifzlei = 86 (0x56)
	ifzlsi = 87 (0x57)
	ifzgei = 88 (0x58)
	ifzgti = 89 (0x59)

Operand Stack

	..., value ->
	...

Description

	value must be of int type.  It is popped and compared with
	zero.  The comparison succeeds if

	For ifzeqi, value == 0

	For ifznei, value != 0

	For ifzlei, value <= 0

	For ifzlsi, value < 0

	For ifzgei, value >= 0

	For ifzgti, value > 0

	If the comparison succeeds, the pc register is loaded with
	offset plus the address of the opcode of the immediately
	following instruction.

	If the comparison fails, the pc register is loaded with the
	address of the opcode of the immediately following
	instruction.

	The new pc value must be the address of an instruction opcode
	within the current method.

	Execution continues at the new pc address.


inc<type>

Operation

	Increment local register

Format

	inci
	u30	reg
	s32	inc

	incl
	u30	reg
	s64	inc

Forms

	inci = 188 (0xbc)
	incl = 189 (0xbd)

Operand Stack

	... ->
	...

Description

	Increment the value in local register number reg by value inc.

	The inci instruction increments an int or uint local register
	value, while the incl instruction increments a long or ulong
	local register value.

Notes

	The inci, incl, deci and decl instructions are intended to be
	used to increment and decrement loop induction variables,
	typically array indices.


invokeinterface

Operation

	Invoke an interface method

Format

	invokeinterface
	u30	method
	ubyte	0

Forms

	invokeinterface = 235 (0xeb)

Operand Stack

	..., objectref[, arg1[, ..., argn]] ->
	...

Description

	method is an index into the top level abc file method array.
	The method's enclosing class is referenced by the class field
	in the indexed method_info item and must be an interface
	class.  The referenced method is resolved (...).  The resolved
	method must be an instance method, and not an instance, class
	or interface initialization method.  It may not be static and
	must be abstract.

	objectref must be a reference to an ordinary class (2.2.3)
	object whose class implements the resolved method's enclosing
	interface.  The method to be invoked is looked up in
	objectref's class.

	If objectref's class, call it C, defines an instance method
	with the same name and method-signature descriptor (3.2) as
	the resolved method, that method is the method to invoke.  If
	no such method exists, do the same lookup on C's direct
	superclass, and so on for all of C's superclasses until a
	matching method is found.  The matching method is the method
	to invoke.  If no matching method is found, throw an
	AbstractMethodError.

	The argument values are on top of the operand stack, just
	above objectref.  The number, type and order of the values
	must be consistent with the method's method-signature
	descriptor.  The value on top of the operand stack is the last
	(rightmost) argument value, the value just beneath it is the
	second-to-last argument value, and so on.  arg1, the value
	just above objectref, is the first (leftmost) argument value.

	objectref and the argument values are popped from the operand
	stack. A new frame is created on the virtual machine stack for
	the method.  The argument values are consecutively written
	into local registers in the new frame, with objectref in local
	register 0, arg1 in local register 1, and so on with argn in
	local register n.  The new frame is then made the current
	frame and the virtual machine PC register set to the opcode of
	the first instruction of the method.  Execution continues at
	that instruction.

	If the method is native, the platform-dependent code for the
	native method is bound into the virtual machine if that has
	not already been done.  objectref and the argument values are
	passed to the native method and the native code invoked in a
	platform and implementation-dependent fashion.  If the native
	method returns a value, it is converted in a platform and
	implementation-dependent fashion to a value of the method's
	return type and pushed onto the operand stack.

Linking Exception

	If the method's enclosing class is not an interface class, or
	the resolved method is not an instance method, or is an
	instance, class, or interface initialization method, or is
	static, or is not abstract, an IncompatibleClassChangeError is
	thrown.

Runtime Exceptions

	If objectref is null, a NullPointerError is thrown.

	If objectref's class does not implement the resolved method's
	enclosing interface, an IncompatibleClassChangeError is
	thrown.

	If no method matching the name and signature of the resolved
	method is found in objectref's class or any of its
	superclasses, an AbstractMethodError is thrown.

	If the matching method is not public, an IllegalAccessError is
	thrown.

	If the matching method is abstract, an AbstractMethodError is
	thrown.

	If the matching method is native and the code that implements
	it cannot be bound into the VM, an UnsatisfiedLinkError is
	thrown.

Notes

	The extra zero ubyte exists so that the VM is guaranteed
	enough space to rewrite the instruction.


invokeprop

Operation

	Invoke a virtual (polymorphic) method using a name and
	signature to look up the method, boxing any scalar result
	value

Format

	invokeprop
	ubyte	count
	u30	sig
	u30	name

Forms

	invokeprop = 237 (0xed)

Operand Stack

	..., objectref[, arg1[, ..., argn]] ->
	..., resultref

Description

	count is the number of stacked argument values arg1 through
	argn.  name is an index into the top level abc file string
	array for the name of the method to invoke.  sig is an index
	into the top level abc file type array of a method-signature
	descriptor (3.2).  sig is generated by the compiler from the
	types of the stacked argument values.  sig's return type must
	be '*'.

	objectref is a reference to an object (2.2).  The method to be
	invoked is looked up in objectref's class.

	If objectref's class, call it C, defines a method with the
	same name as name and a method-signature descriptor (3.2) that
	is compatible (...) with sig, and that is accessible (...) by
	the caller, that method is the method to invoke.  The matching
	method must be an instance method and must not be an instance,
	class or interface initialization method.  It must not be
	abstract and its return type must not be void.

	[ "that is compatible with sig" means, for the time being,
	"with the same number of parameters specified by sig" ]

	If no such method exists in C, but C has a field with same
	name as name that is accessible (...) by the caller, then the
	matching field must be an instance field and its type must be
	a closure type (2.2.5).  The method to invoke is the target
	method encapsulated by the closure object that is the matching
	field's value.

	If no matching method or field of C exists, the same lookup is
	done on C's direct superclass, and so on for all of C's
	superclasses until a matching method or field is found.  If no
	matching method or field is found, an AbstractMethodError is
	thrown.

	If a field of a closure type, rather an instance method, is
	matched, the equivalent of a "rol count + 1, pop" instruction
	sequence is executed to remove objectref from the operand
	stack.  Then, the value of the matching field is fetched and
	pushed onto the operand stack and the equivalent of a "call
	count sig" instruction is executed.

	Otherwise, an instance method was matched and the argument
	values are on top of the operand stack, just above objectref.
	The number, type and order of the values must be consistent
	with sig.  The value on top of the operand stack is the last
	(rightmost) argument value, the value just beneath it is the
	second-to-last argument value, and so on.  arg1, the value
	just above objectref, is the first (leftmost) argument value.

	The equivalent of a "coerce arg-type formal-type" instruction
	is executed on each argument value, where arg-type is the
	corresponding parameter type in sig and formal-type is the
	corresponding parameter type in the matching method's
	method-signature descriptor.  The order in which argument
	values are coerced is unspecified.

	The coerced argument values are popped from the operand
	stack. A new frame is created on the virtual machine stack for
	the method.  objectref and the coerced argument values are
	consecutively written into local registers in the new frame,
	with objectref in local register 0, the coerced value of arg1
	in local register 1, and so on with the coerced value of argn
	in local register n.  The new frame is then made the current
	frame and the virtual machine PC register set to the opcode of
	the first instruction of the method.  Execution continues at
	that instruction.

	If the method is native, the platform-dependent code for the
	native method is bound into the virtual machine if that has
	not already been done.  objectref and the coerced argument
	values are passed to the native method and the native code
	invoked in a platform and implementation-dependent fashion.
	If the native method returns a value, it is converted in a
	platform and implementation-dependent fashion to a value of
	the method's return type and pushed onto the operand stack.

	Upon return from the invoked method, a return value is on top
	of the operand stack.  If the return value is of a reference
	type, it is left on the operand stack unchanged.

	If the return value is of a primitive machine type (2.2.1),
	the equivalent of a "packst scalar-struct, newbox
	scalar-struct" instruction sequence is executed to box the
	return value, where scalar-struct is the struct-type
	descriptor (3.2) corresponding to the method's return type.  A
	reference to the resulting scalar object replaces the
	primitive machine type value on the operand stack.

	Otherwise, the return value is a struct value and the
	equivalent of a "newbox struct-type" instruction is executed
	to box the return value, where struct-type is the struct-type
	descriptor (3.2) for the method's return type.  A reference to
	the resulting box object replaces the struct value on the
	operand stack.

Runtime Exceptions

	If objectref is null, a NullPointerError is thrown.

	If objectref is not a reference to a class object, a TypeError
	is thrown.

	If no method matching method or field is found in objectref's
	class or any of its superclasses, an AbstractMethodError is
	thrown.

	If the matching field is not an instance field or its type is
	not a closure type, an IncompatibleClassChangeError is thrown.

	If the matching method is not an instance method, or is an
	instance, class or interface initialization method, or has a
	void return type, an IncompatibleClassChangeError is thrown.

	If the matching method is abstract, an AbstractMethodError is
	thrown.

	If the matching method is native and the code that implements
	it cannot be bound into the VM, an UnsatisfiedLinkError is
	thrown.

	Other runtime exceptions may be thrown during execution of the
	equivalent of the call, coerce or newbox instructions.

Notes

	invokeprop is intended to be used in contexts in which a
	return value is required.  Use invokepropv in contexts where
	a return value is not required.

	The invokeprop instruction is essentially an auto-reflecting
	invokevirtual instruction that checks for a matching field as
	well as a matching method.

	The invokeprop instruction always returns an object reference
	(that is, the return type is always '*') because the return
	type cannot be known by the compiler.

	For primitive machine or struct type return values, the
	equivalent of a newbox instruction is executed to produce a
	reference to a scalar or box object.  Because box objects are
	immutable, the VM is free to implement a caching scheme
	whereby a reference to an existing rather than newly created
	scalar or box object is pushed onto the operand stack.

	Even though primitive machine type return values of sbyte,
	ubyte, short, ushort and bool type are represented as int
	values on the operand stack, the result is of the
	corresponding scalar class type, not of the scalar class
	corresponding to int.  No type information is lost.


invokepropv

Operation

	Invoke a virtual (polymorphic) method using a name and
	signature to look up the method, discarding any return value

Format

	invokepropv
	ubyte	count
	u30	sig
	u30	name

Forms

	invokepropv = 233 (0xe9)

Operand Stack

	..., objectref[, arg1[, ..., argn]] ->
	...

Description

	The invokepropv instruction operates exactly as does the
	invokeprop instruction, except that:

	1. The matching method's return type may be void.

	2. If the matching method's return type is not void, the
	return value is popped and discarded.  Because the result
	value is discarded, invokepropv does not box a scalar result
	value.

	3. If a matching field rather than matching method is found,
	the equivalent of a callv rather than call instruction is
	executed.

Notes

	invokepropv is intended to be used in contexts in which a
	return value is not required.  Use invokeprop in contexts
	where a return value is required.


invokesuper

Operation

	Invoke a virtual (polymorphic) superclass method

Format

	invokesuper
	u30	method
	ubyte	0

Forms

	invokesuper = 236 (0xec)

Operand Stack

	..., objectref[, arg1[, ..., argn]] ->
	...

Description

	method is an index into the top level abc file method array.
	The method's enclosing class is referenced by the class field
	in the indexed method_info item.  The referenced method is
	resolved (...).  The resolved method must be an instance or
	instance initialization method, and not a class or interface
	initialization method.  It must not be static or abstract.

	If the method is successfully resolved, its enclosing class
	must be either the current class (3.2) or a superclass of the
	current class.

	objectref must be a reference to the object on which the
	current method was invoked.

	If the direct superclass of the current class, call it C,
	defines an instance method with the same name and
	method-signature descriptor as the resolved method, that
	method is the method to invoke.  If no such method exists, do
	the same lookup on C's direct superclass, and so on for all of
	C's superclasses until a matching method is found.  The
	matching method is the method to invoke.  If no matching
	method is found, throw an AbstractMethodError.

	If the method is an instance initialization method, the
	current method must be an instance initialization method.

	The argument values are on top of the operand stack, just
	above objectref.  The number, type and order of the values
	must be consistent with the method's method-signature
	descriptor.  The value on top of the operand stack is the last
	(rightmost) argument value, the value just beneath it is the
	second-to-last argument value, and so on.  arg1, the value
	just above objectref, is the first (leftmost) argument value.

	objectref and the argument values are popped from the operand
	stack. A new frame is created on the virtual machine stack for
	the method.  The argument values are consecutively written
	into local registers in the new frame, with objectref in local
	register 0, arg1 in local register 1, and so on with argn in
	local register n.  The new frame is then made the current
	frame and the virtual machine PC register set to the opcode of
	the first instruction of the method.  Execution continues at
	that instruction.

	If the method is native, the platform-dependent code for the
	native method is bound into the virtual machine if that has
	not already been done.  objectref and the argument values are
	passed to the native method and the native code invoked in a
	platform and implementation-dependent fashion.  If the native
	method returns a value, it is converted in a platform and
	implementation-dependent fashion to a value of the method's
	return type and pushed onto the operand stack.

Linking Exceptions

	if the resolved method's enclosing class is not the current
	class or one of its superclasses, an
	IncompatibleClassChangeError is thrown.

	If the resolved method is not an instance or instance
	initialization method, or is abstract, an
	IncompatibleClassChangeError is thrown.

Runtime Exceptions

	If objectref is null, a NullPointerError is thrown.

	If no method matching the name and signature of the resolved
	method is found in objectref's class or any of its
	superclasses, an AbstractMethodError is thrown.

	If the matching method is abstract, an AbstractMethodError is
	thrown.

	If the matching method is an instance initialization method,
	and the current method is not an instance initialization
	method, an IncompatibleClassChangeError is thrown.

	If the matching method is native and the code that implements
	it cannot be bound into the VM, an UnsatisfiedLinkError is
	thrown.

Notes

	There is no way to invoke an instance initializer method other
	than via a newinstance or invokesuper instruction.

	Method lookup can be done during linking rather than waiting
	until runtime.

	The extra zero ubyte exists so that the VM is guaranteed
	enough space to rewrite the instruction.


invokevirtual

Operation

	Invoke a virtual (polymorphic) method

Format

	invokevirtual
	u30	method
	ubyte	0

Forms

	invokevirtual = 234 (0xea)

Operand Stack

	..., objectref[, arg1[, ..., argn]] ->
	...

Description

	method is an index into the top level abc file method array.
	The method's enclosing class is referenced by the class field
	in the indexed method_info item.  The referenced method is
	resolved (...).  The resolved method must be an instance
	method, and not an instance, class or interface initialization
	method.  It must not be static or abstract.

	If the method is successfully resolved, its enclosing class is
	initialized (...) if it has not already been initialized.

	objectref must be a reference to a class object.  The method
	to be invoked is looked up in objectref's class.

	If objectref's class, call it C, defines an instance method
	with the same name and method-signature descriptor as the
	resolved method, that method is the method to invoke.  If no
	such method exists, do the same lookup on C's direct
	superclass, and so on for all of C's superclasses until a
	matching method is found.  The matching method is the method
	to invoke.  If no matching method is found, throw an
	AbstractMethodError.

	The argument values are on top of the operand stack, just
	above objectref.  The number, type and order of the values
	must be consistent with the method's method-signature
	descriptor (3.2).  The value on top of the operand stack is
	the last (rightmost) argument value, the value just beneath it
	is the second-to-last argument value, and so on.  arg1, the
	value just above objectref, is the first (leftmost) argument
	value.

	objectref and the argument values are popped from the operand
	stack. A new frame is created on the virtual machine stack for
	the method.  The argument values are consecutively written
	into local registers in the new frame, with objectref in local
	register 0, arg1 in local register 1, and so on with argn in
	local register n.  The new frame is then made the current
	frame and the virtual machine PC register set to the opcode of
	the first instruction of the method.  Execution continues at
	that instruction.

	If the method is native, the platform-dependent code for the
	native method is bound into the virtual machine if that has
	not already been done.  objectref and the argument values are
	passed to the native method and the native code invoked in a
	platform and implementation-dependent fashion.  If the native
	method returns a value, it is converted in a platform and
	implementation-dependent fashion to a value of the method's
	return type and pushed onto the operand stack.

Linking Exception

	If the resolved method is not an instance method, or is an
	instance, class or interface initialization method, or is
	static or abstract, an IncompatibleClassChangeError is thrown.

Runtime Exceptions

	If objectref is null, a NullPointerError is thrown.

	If no method matching the name and signature of the resolved
	method is found in objectref's class or any of its
	superclasses, an AbstractMethodError is thrown.

	If the matching method is abstract, an AbstractMethodError is
	thrown.

	If the matching method is native and the code that implements
	it cannot be bound into the VM, an UnsatisfiedLinkError is
	thrown.

Notes

	The extra zero ubyte exists so that the VM is guaranteed
	enough space to rewrite the instruction.


isinstanceof

Operation

	Check whether object is of a given type

Format

	isinstanceof
	u30	type

Forms

	isinstanceof = 159 (0x9f)

Operand Stack

	..., objectref ->
	..., result

Description

	type is an index into the type array for the type name string
	for the target class.  It must denote the Object type or one
	of its subtypes and thus may index a interface (2.2.3), array
	(2.2.4), vector (2.2.4), closure (2.2.5) or ordinary class
	(2.2.3) type name.

	objectref must be an object reference (2.2.8).  It is popped.
	If it is null, an int value of zero is pushed onto the operand
	stack.

	Otherwise, the named interface, array, vector, closure or
	ordinary class type is resolved (...).  If objectref can be
	cast to the resolved type (that is, it is a reference to an
	object whose class is a subclass of the resolved class), an
	int value of one is pushed onto the operand stack.  Otherwise,
	an int value of zero is pushed onto the operand stack.

	objectref can be cast to the resolved type if it refers to an
	instance of the resolved type or one of its subtypes.  If the
	resolved type is an interface, then objectref must reference
	an object that implements that interface.

	A class C is a subclass of another class B under the following
	conditions.

	1. C and B are the same.

	2. C's type is the null type.

	3. If C extends B, then C is a subclass of B.

	4. If C is an interface that extends B, then C is a subclass
	of B.

	5. If B is an interface and C implements B, then C is a
	subclass of B.

	5.  If C is a closure class, then it is a subclass of B if C's
	type is a subtype of B's.  For types Ti, T, Si and S, a
	closure type of the form (T1, ... , Ti) => T is a subtype of
	(S1, ... , Si) => S if Tm is a subtype of Sm for all m in
	1..i, and T is a subtype of S.

Notes

	The int values one and zero pushed onto the operand stack
	correspond to the representation of the boolean values true
	and false.

	The isinstanceof instruction performs the same check as the
	checkcast instruction.

	Because the type argument denotes the Object class or one of
	its subclases, references to objects of other classes will
	cause zero to be pushed onto the operand stack.


jump

Operation

	Branch always

Format

	jump
	s24	offset

Forms

	jump = 207 (0xcf)

Operand Stack

	... ->
	...

Description

	The pc register is loaded with offset plus the address of the
	opcode of the immediately following instruction.  The new pc
	value must be the address of an opcode of an instruction
	within the current method.


l2d

Operation

	Convert signed long to double

Format

	l2d

Forms

	l2d = 215 (0xd7)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type long.  It is popped from the operand
	stack and converted to a double result using IEE-754
	round-to-nearest mode.  The double result is pushed onto the
	operand stack.

Notes

	Loss of precision may occur since double values have only 53
	significand bits.


l2f

Operation

	Convert signed long to float

Format

	l2f

Forms

	l2f = 214 (0xd6)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type long.  It is popped from the operand
	stack and converted to a float result using IEE-754
	round-to-nearest mode.  The float result is pushed onto the
	operand stack.

Notes

	Loss of precision may occur since float values have only 24
	significand bits.


l2i

Operation

	Convert long to signed integer

Format

	l2i

Forms

	l2i = 212 (0xd4)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type long or ulong.  It is popped from the
	operand stack and truncated to an int result.  The int result
	is pushed onto the operand stack.

Notes

	The l2i instruction will lose information if the high order 32
	bits of (value & 0xFFFFFFFF00000000) are not the same as that
	of the sign of the result.

	The potential instruction ul2i can be implemented with an l2i
	instruction.  The potential ul2i instruction will lose
	information if the high order 33 bits of (value &
	0xFFFFFFFF80000000) are not zero.

	The potential instruction l2u can be implemented as an l2i
	instruction followed by an i2u instruction.  The potential l2u
	instruction will lose information if the high order 32 bits of
	(value & 0xFFFFFFFF00000000) are not zero.

	The potential instruction ul2u can be implemented as an l2i
	followed by an i2u instruction.  The potential ul2u
	instruction will lose information if the high order 32 bits of
	(value & 0xFFFFFFFF00000000) are not zero.


l2ul

Operation

	Convert signed to unsigned long

Format

	l2ul

Forms

	l2ul = 213 (0xd5)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type long.  It is popped from the operand
	stack and reinterpreted as a ulong.  The ulong result is
	pushed onto the operand stack.

Notes

	The l2ul instruction changes the type of the top of stack
	value from long to ulong.  Otherwise it is a nop.


label

Operation

	Identify branch target

Format

	label

Forms

	label = 206 (0xce)

Operand Stack

	... ->
	...

Description

	Identify a branch target.  A sequence number is implied that
	is equal to the number of previous label instructions in the
	instruction stream.  Sequence numbers start at zero.

Notes

	The label instruction is strictly informative and is
	equivalent to a nop instruction.


ld<type>

Operation

	Load from local register

Format

	ld<type>
	u30	reg

Forms

	ldi = 32 (0x20)
	ldl = 33 (0x21)
	ldf = 34 (0x22)
	ldd = 35 (0x23)
	ldr = 36 (0x24)

Operand Stack

	... ->
	..., value

Description

	The value in local register number reg is pushed onto the
	operand stack.  The value must be of type int/uint,
	long/ulong, float or double, or an object reference or struct
	value, according to whether the instruction is ldi, ldl, ldf,
	ldd or ldr.

Notes

	Loading a uint or ulong value is accomplished by an ldi or ldl
	instruction followed by an i2u or l2ul instruction
	respectively.


lda<type>

Operation

	Load array element

Format

	lda<type>

Forms

	ldasb = 96  (0x60)
	ldaub = 97  (0x61)
	ldas  = 98  (0x62)
	ldaus = 99  (0x63)
	ldai  = 100 (0x64)
	ldal  = 101 (0x65)
	ldaf  = 102 (0x66)
	ldad  = 103 (0x67)
	ldar  = 104 (0x68)

Operand Stack

	..., arrayref, index ->
	..., value

Description

	arrayref must be a reference to an array object whose elements
	are of type sbyte, ubyte, short, ushort, int/uint, long/ulong,
	float, double or an object reference type, according to
	whether the instruction is respectively ldasb, ldaub, ldas,
	ldaus, ldai, ldal, ldaf, ldad or ldar.  index must be a value
	of type int.  arrayref and index are popped from the operand
	stack.  The value in the element of the array object indexed
	by index is pushed onto the operand stack.

	Values of type sbyte and short are signed-extended, and values
	of type ubyte, bool and ushort are zero-extended to an int
	value before being pushed onto the operand stack.  The value
	pushed is of type int.

	Values of type bool are loaded using an ldaub instruction.

Notes

	A uint or ulong array element is loaded by an ldai or ldal
	instruction followed by an i2u or l2ul instruction
	respectively.


ldast

Operation

	Load array struct element

Format

	ldast
	u30	struct-type

Forms

	ldast = 1, 124 (0x01, 0x7c)

Operand Stack

	..., arrayref, index ->
	..., value

Description

	struct-type is an index into the top level abc file type array
	for a struct-type descriptor (3.2).

	arrayref must be a reference to an array object whose elements
	are of the type referenced by struct-type.  index must be a
	value of type int.  arrayref and index are popped from the
	operand stack.  The struct value element of the array object
	indexed by index is pushed onto the operand stack.


ldastf

Operation

	Load array struct element field

Format

	ldastf
	u30	struct-type
	u30	struct-field

Forms

	ldastf = 1, 125 (0x01, 0x7d)

Operand Stack

	..., arrayref, index ->
	..., value

Description

	struct-type is an index into the top level abc file type array
	for a struct-type descriptor.  struct-field is an index into
	the top level abc file string array for a qualifield struct
	field name (3.1.3), which must denote a field of either the
	referenced struct type or a struct type nested within the
	referenced struct type.

	arrayref must be a reference to an array object whose elements
	are of the referenced struct type.  index must be a value of
	type int.  arrayref and index are popped from the operand
	stack.  The value in the referenced field within the struct
	element of the array object indexed by index is pushed onto
	the operand stack.

	Values of type sbyte and short are signed-extended, and values
	of type ubyte, bool and ushort are zero-extended to an int
	value before being pushed onto the operand stack.  The value
	pushed is of type int.

Notes

	Nested struct values may be loaded by the ldastf instruction.


ldc<type>

Operation

	Load scalar constant

Format

	ldc<type>
	u30	index

Forms

	ldci  = 52 (0x34)
	ldcu  = 53 (0x35)
	ldcl  = 54 (0x36)
	ldcul = 55 (0x37)
	ldcf  = 56 (0x38)
	ldcd  = 57 (0x39)

Operand Stack

	... ->
	..., value

Description

	Push a constant scalar value from the top level abc file int,
	uint, long, ulong, float or double constant array, according
	as the instruction is ldci, ldcu, ldcl, ldcul, ldcf or ldcd.
	The index argument is the index into the array.


ldcc

Operation

	Load Class

Format

	ldcc
	u30	index

Forms

	ldcc = 59 (0x3b)

Operand Stack

	... ->
	..., value

Description

	index is an index into the top level abc file type array for a
	class-type descriptor (3.2) for the class.  The named class is
	resolved (...) and a reference to the Class object
	representing it is pushed onto the operand stack.


ldcs

Operation

	Load String

Format

	ldcs
	u30	index

Forms

	ldcs = 58 (0x3a)

Operand Stack

	... ->
	..., value

Description

	index is an index into the top level abc file string constant
	array for the string literal value.  Push a reference to an
	instance of a class String object representing the indexed
	string literal onto the operand stack.

Notes

	Because String objects are immutable, the VM is free to
	implement a caching scheme whereby a reference to an existing
	rather than newly created String object is pushed onto the
	operand stack.


ldi<reg>

Operation

	Load integer from local register

Format

	ldi<reg>

Forms

	ldi1 = 37 (0x25)
	ldi2 = 38 (0x26)
	ldi3 = 39 (0x27)
	ldi4 = 40 (0x28)
	ldi5 = 41 (0x29)
	ldi6 = 42 (0x2a)
	ldi7 = 43 (0x2b)

Operand Stack

	... ->
	..., value

Description

	The int value in local register number <reg> is pushed onto
	the operand stack.

Notes

	Loading a uint is accomplished by an ldi<reg> instruction
	followed by an i2u instruction.


ldl<reg>

Operation

	Load long from local register

Format

	ldl<reg>

Forms

	ldl1 = 81 (0x51)
	ldl2 = 82 (0x52)
	ldl3 = 83 (0x53)

Operand Stack

	... ->
	..., value

Description

	The long value in local register number <reg> is pushed onto
	the operand stack.

Notes

	Loading a ulong is accomplished by an ldl<reg> instruction
	followed by an l2ul instruction.


ldm<type>

Operation

	Load from machine location

Format

	ldm<type>

Forms

	ldmub = 240 (0xf0)
	ldmus = 241 (0xf1)
	ldmu  = 242 (0xf2)
	ldmul = 243 (0xf3)
	ldmf  = 244 (0xf4)
	ldmd  = 245 (0xf5)

Operand Stack

	..., address ->
	..., value

Description

	address is a ulong value on top of the operand stack that can
	be used to reference a memory location.  Its format is
	platform and implementation dependent.

	Pop address and use it to load an ubyte, ushort, uint, ulong,
	float or double value from a machine location, according to
	whether the instruction is ldmub, ldmus, ldmu, ldmul, ldmf or
	ldmd.

Notes

	The ldm and stm instructions are intended to be used to
	support low level operations on primitive machine type (2.2.1)
	values.  Code using these instructions is platform and
	implementation dependent, thus only primitive machine types
	are supported.


ldr<reg>

Operation

	Load reference from local register

Format

	ldr<reg>

Forms

	ldr0 = 44 (0x2c)
	ldr1 = 45 (0x2d)
	ldr2 = 46 (0x2e)
	ldr3 = 47 (0x2f)
	ldr4 = 48 (0x30)
	ldr5 = 49 (0x31)
	ldr6 = 50 (0x32)
	ldr7 = 51 (0x33)

Operand Stack

	... ->
	..., value

Description

	The object reference in local register number <reg> is pushed
	onto the operand stack.


ldst

Operation

	Load struct value from local register

Format

	ldst
	u30	reg
	u30	struct-type

Forms

	ldst = 1, 37 (0x01, 0x25)

Operand Stack

	... ->
	..., value

Description

	struct-type is an index into the top level abc file type array
	of a struct-type descriptor (3.2).  The value in local
	register number reg must be a value of the referenced struct
	type.  It is pushed onto the operand stack.


ldstf

Operation

	Load struct field from local register

Format

	ldstf
	u30	reg
	u30	struct-type
	u30	struct-field

Forms

	ldstf = 1, 140 (0x01, 0x8c)

Operand Stack

	... ->
	..., value

Description

	struct-type is an index into the top level abc file type array
	of a struct-type descriptor (3.2).  struct-field is an index
	the top level abc file string array for a qualifield struct
	field name (3.1.3), which must denote a field of either the
	referenced struct type or a struct type nested within the
	referenced struct type.

	The value in local register number reg must be a value of the
	referenced struct type.  The value of the referenced field
	within the struct value is pushed onto the operand stack.

	Values of type sbyte and short are signed-extended, and values
	of type ubyte, bool and ushort are zero-extended to an int
	value before being pushed onto the operand stack.  The value
	pushed is of type int.

Notes

	Nested struct values may be loaded by the ldstf instruction.


ldv<type>

Operation

	Load vector element

Format

	ldv<type>

Forms

	ldvsb = 1, 96  (0x01, 0x60)
	ldvub = 1, 97  (0x01, 0x61)
	ldvs  = 1, 98  (0x01, 0x62)
	ldvus = 1, 99  (0x01, 0x63)
	ldvi  = 1, 100 (0x01, 0x64)
	ldvl  = 1, 101 (0x01, 0x65)
	ldvf  = 1, 102 (0x01, 0x66)
	ldvd  = 1, 103 (0x01, 0x67)
	ldvr  = 1, 104 (0x01, 0x68)

Operand Stack

	..., vectorref, index ->
	..., value

Description

	vectorref must be a reference to a vector object whose
	elements are of type sbyte, ubyte, short, ushort, int/uint,
	long/ulong, float, double or an object reference type,
	according to whether the instruction is respectively ldvsb,
	ldvub, ldvs, ldvus, ldvi, ldvl, ldvf, ldvd or ldvr.  index
	must be a value of type int.  vectorref and index are popped
	from the operand stack.  The value in the element of the
	vector object indexed by index is pushed onto the operand
	stack.

	Values of type sbyte and short are signed-extended, and values
	of type ubyte, bool and ushort are zero-extended to an int
	value before being pushed onto the operand stack.  The value
	pushed is of type int.

	Values of type bool are loaded using an ldvub instruction.

Notes

	A uint or ulong vector element is loaded by an ldvi or ldvl
	instruction followed by an i2u or l2ul instruction
	respectively.


ldvst

Operation

	Load vector struct element

Format

	ldvst
	u30	struct

Forms

	ldvst = 1, 132 (0x01, 0x84)

Operand Stack

	..., vectorref, index ->
	..., value

Description

	struct is an index into the top level abc file type array for
	a struct-type descriptor.

	vectorref must be a reference to a vector object whose
	elements are of the type referenced by struct.  index must be
	a value of type int.  vectorref and index are popped from the
	operand stack.  The value in the element of the vector object
	indexed by index is pushed onto the operand stack.


ldvstf

Operation

	Load vector struct element field

Format

	ldvstf
	u30	struct-type
	u30	struct-field

Forms

	ldvstf = 1, 133 (0x01, 0x85)

Operand Stack

	..., vectorref, index ->
	..., value

Description

	struct-type is an index into the top level abc file type array
	for a struct-type descriptor.  struct-field is an index into
	the the top level abc file string array for a qualifield
	struct field name (3.1.3), which must denote a field of either
	the referenced struct type or a struct type nested within the
	referenced struct type.

	vectorref must be a reference to a vector object whose
	elements are of the referenced struct type.  index must be a
	value of type int.  vectorref and index are popped from the
	operand stack.  The value in the referenced field within the
	struct element of the vector object indexed by index is pushed
	onto the operand stack.

	Values of type sbyte and short are signed-extended, and values
	of type ubyte, bool and ushort are zero-extended to an int
	value before being pushed onto the operand stack.  The value
	pushed is of type int.

Notes

	Nested struct values may be loaded by the ldvstf instruction.


lookupswitch

Operation

	Match key in jump table and branch

Format

	lookupswitch
	...

Forms

	lookupswitch = 127 (0x7f)

Operand Stack

	..., key ->
	...

Description

	Not yet implemented.


modd

Operation

	Double modulus

Format

	modd

Forms

	modd = 187 (0xbb)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type double.  They are
	popped from the operand stack.  The double result is
	calculated and pushed onto the operand stack.

	The result is not the same as the IEEE-754 remainder operation
	in that the division traucates toward zero.

	If neither operand is a NaN, the sign of the result is the
	sign of the dividend.

	The result is a NaN if either operand is a NaN, the dividend
	is an infinity or the divisor is zero.

	The result is the dividend if the dividend is finite and the
	divisor is an infinity, or if the dividend is a zero and the
	divisor is finite.

	In other than the above cases, the result is value1 - (q *
	value2), where q is an integer whose value is the floating
	point result of (value1 / value2) rounded toward zero.  If q
	is not zero, its sign is the sign of the dividend.

	Even though division by zero may occur, modd never throws a
	runtime exception.  Overflow, underflow or loss of precision
	cannot occur.


modf

Operation

	Float modulus

Format

	modf

Forms

	modf = 186 (0xba)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type float.  They are
	popped from the operand stack.  The float result is
	calculated and pushed onto the operand stack.

	The result is not the same as the IEEE-754 remainder operation
	in that the division truncates toward zero.

	If neither operand is a NaN, the sign of the result is the
	sign of the dividend.

	The result is a NaN if either operand is a NaN, the dividend
	is an infinity or the divisor is zero.

	The result is the dividend if the dividend is finite and the
	divisor is an infinity, or if the dividend is a zero and the
	divisor is finite.

	In other than the above cases, the result is value1 - (q *
	value2), where q is an integer whose value is the floating
	point result of (value1 / value2) rounded toward zero.  If q
	is not zero, its sign is the sign of the dividend.

	Even though division by zero may occur, modf never throws a
	runtime exception.  Overflow, underflow or loss of precision
	cannot occur.


modi

Operation

	Signed integer modulus

Format

	modi

Forms

	modi = 182 (0xb6)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type int.  They are popped
	from the operand stack.  The int result is value1 - ((value1 /
	value2) * value2).  The result is pushed onto the operand
	stack.

	If the dividend is the largest possible negative int value and
	the divisor is -1, the result is zero.

	If the result is not zero, its sign is the sign of the
	dividend.

	The magnitude of the result is always less than the magnitude
	of the divisor.

Runtime Exception

	If the value of the divisor is zero, an ArithmeticError is
	thrown.


modl

Operation

	Signed long modulus

Format

	modl

Forms

	modl = 184 (0xb8)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type long.  They are popped
	from the operand stack.  The int result is value1 - ((value1 /
	value2) * value2)).  The result is pushed onto the operand
	stack.

	If the dividend is the largest possible negative int value and
	the divisor is -1, the result is zero.

	If the result is not zero, its sign is the sign of the
	dividend.

	The magnitude of the result is always less than the magnitude
	of the divisor.

Runtime Exception

	If the value of the divisor is zero, an ArithmeticError is
	thrown.


modu

Operation

	Unsigned integer modulus

Format

	modu

Forms

	modu = 183 (0xb7)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type uint.  They are popped
	from the operand stack.  The uint result is value1 - ((value1
	/ value2) * value2)).  The result is pushed onto the operand
	stack.

Runtime Exception

	If the value of the divisor is zero, an ArithmeticError is
	thrown.


modul

Operation

	Unsigned long modulus

Format

	modul

Forms

	modul = 185 (0xb9)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type ulong.  They are popped
	from the operand stack.  The ulong result is value1 - ((value1
	/ value2) * value2)).  The result is pushed onto the operand
	stack.

Runtime Exception

	If the value of the divisor is zero, an ArithmeticError is
	thrown.


muld

Operation

	Multiply double

Format

	muld

Forms

	muld = 175 (0xaf)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type double.  They are
	popped from the operand stack.  The double result is value1 *
	value2.  The result is pushed onto the operand stack.

	The result is governed by the rules of IEEE 754 64-bit
	floating point arithmetic.

	Even though overflow, underflow or loss of precision may
	occur, muld never throws a runtime exception.


mulf

Operation

	Multiply float

Format

	mulf

Forms

	mulf = 174 (0xae)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type float.  They are popped
	from the operand stack.  The float result is value1 * value2.
	The result is pushed onto the operand stack.

	The result is governed by the rules of IEEE 754 32-bit
	floating point arithmetic.

	Even though overflow, underflow or loss of precision may
	occur, addf never throws a runtime exception.


muli

Operation

	Multiply integer

Format

	muli

Forms

	muli = 172 (0xac)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type int or uint.  They are
	popped from the operand stack.  The int or uint result is
	value1 * value2.  The result is pushed onto the operand stack.

	If both operands are int, the result is the low-order 32 bits
	of the true two's-complement mathematical result, represented
	as an int.  On overflow, the sign of the result may not be the
	same as the sign of the mathematical product.

	If both operands are uint, the result is the low-order 32 bits
	of the true mathematical result, represented as a uint.  That
	is, the mathematical result is truncated to 32 bits.

	muli never throws a runtime exception.


mull

Operation

	Multiply long

Format

	mull

Forms

	mull = 173 (0xad)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type long or ulong.  They
	are popped from the operand stack.  The long or ulong result
	is value1 * value2.  The result is pushed onto the operand
	stack.

	If both operands are long, the result is the low-order 64 bits
	of the true two's-complement mathematical result, represented
	as an int.  On overflow, the sign of the result may not be the
	same as the sign of the mathematical product.

	If both operands are ulong, the result is the low-order 64
	bits of the true mathematical result, represented as a uint.
	That is, the mathematical result is truncated to 64 bits.

	mull never throws a runtime exception.


multinewarray

Operation

	Create a new one- or multi-dimensional array object

Format

	multinewarray
	u30	type
	ubyte	count

Forms

	multinewarray = 230 (0xe6)

Operand Stack

	..., length1[, ..., lengthn] ->
	..., arrayref

Description

	type is an index into the top level abc file type array for
	the array-type descriptor (3.2) for the object to allocate.
	count is the number of dimensions of the new array, and must
	be greater than or equal to one.

	If the lowest dimension's element type is the Object type or
	one of its subtypes, it is resolved (...).

	length1 through lengthn are int values on top of the stack.
	There must be count values on top of the stack, one for each
	array dimension.  The value on top of the operand stack is the
	number of elements in the lowest dimension of the array to be
	created, the value just beneath the number of elements in the
	next-lowest dimension, and so on.  The value count - 1 slots
	below the top of the operand stack is the number of elements
	in the highest dimension.  The dimension values are popped.

	Memory is allocated from the heap (2.3.3) for a new
	uninitialized array of the specified number of dimensions,
	dimension lengths and type.  Elements of the array's highest
	dimension are initialized to references to new subarrays of
	the array's next-highest dimension type, and so on.  Elements
	of the last dimension's subarray are initialized to the
	default value (2.2) of that dimension's element type.  If any
	dimension length is zero, no subsequent subarrays are
	allocated.  The array type may have more than count
	dimensions, in which case the leaf subarrays are not
	allocated.

	A reference to the new object is pushed onto the operand
	stack.

Linking Exception

	If the lowest dimension's element type is the Object type or
	one of its subtypes, and the current class does not have
	permission to access that class, an IllegalAccessError is
	thrown.

Runtime Exceptions

	If the any length value is negative, a NegativeArraySizeError
	is thrown.

	An OutOfMemoryError is thrown if there is no space for the new
	object in the heap.


multinewvector

Operation

	Create a new one- or multi-dimensional vector object

Format

	multinewvector
	u30	type
	ubyte	count

Forms

	multinewvector = 1, 230 (0x01, 0xe6)

Operand Stack

	..., length1[, ..., lengthn] ->
	..., vectorref

Description

	type is an index into the top level abc file type array for
	the vector-type descriptor (3.2) for the object to allocate.
	count is the number of dimensions of the new vector, and must
	be greater than or equal to one.

	If the lowest dimension's element type is the Object type or
	one of its subtypes, the corresponding class is resolved
	(...).

	length1 through lengthn are int values on top of the stack.
	There must be count values on top of the stack, one for each
	vector dimension.  The value on top of the operand stack is
	the number of elements in the lowest dimension of the vector
	to be created, the value just beneath the number of elements
	in the next-lowest dimension, and so on.  The value count - 1
	slots below the top of the operand stack is the number of
	elements in the highest dimension.  The dimension values are
	popped.

	Memory is allocated from the heap (2.3.3) for a new
	uninitialized vector of the specified number of dimensions,
	dimension lengths and type.  Elements of the vector's highest
	dimension are initialized to references to new subvectors of
	the vector's next-highest dimension type, and so on.  Elements
	of the last dimension's subvector are initialized to the
	default value (2.2) of that dimension's Element type.  If any
	dimension length is zero, no subsequent subvectors are
	allocated.  The vector type may have more than count
	dimensions, in which case the leaf subvectors are not
	allocated.

	A reference to the new object is pushed onto the operand
	stack.

Linking Exception

	If the lowest dimension's element type is the Object type or
	one of its subtypes and the current class does not have
	permission to access that class, an IllegalAccessError is
	thrown.

Runtime Exceptions

	If the any length value is negative, a NegativeArraySizeError
	is thrown.

	An OutOfMemoryError is thrown if there is no space for the new
	object in the heap.


negd

Operation

	Negate double

Format

	negd

Forms

	negd = 171 (0xab)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type double.  It is popped from the operand
	stack.  The double result is the arithmetic negation of value.
	The result is pushed onto the operand stack.

	Negation inverts the sign of a double and nothing else, thus
	the result is not the same as subtraction from zero.  If value
	is +0.0, then +0.0 - value equals +0.0, but -value equals -0.0.

	negd never throws a runtime exception.


negf

Operation

	Negate float

Format

	negf

Forms

	negf = 170 (0xaa)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type float.  It is popped from the operand
	stack.  The float result is the arithmetic negation of value.
	The result is pushed onto the operand stack.

	Negation inverts the sign of a float and nothing else, thus
	the result is not the same as subtraction from zero.  If value
	is +0.0, then +0.0 - value equals +0.0, but -value equals -0.0.

	negf never throws a runtime exception.


negi

Operation

	Negate signed integer

Format

	negi

Forms

	negi = 168 (0xa8)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type int.  It is popped from the operand
	stack.  The int result is the arithmetic negation of value.
	The result is pushed onto the operand stack.

	The result is the same as subtraction from zero.  Because a
	two's-complement representation is used by the virtual
	machine, the negation of the maximum negative int value
	results in that same value.  -value equals (~value) + 1.

	negi never throws a runtime exception.


negl

Operation

	Negate signed long

Format

	negl

Forms

	negl = 169 (0xa9)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type long.  It is popped from the operand
	stack.  The long result is the arithmetic negation of value.
	The result is pushed onto the operand stack.

	The result is the same as subtraction from zero.  Because a
	two's-complement representation is used by the virtual
	machine, the negation of the maximum negative long value
	results in that same value.  -value equals (~value) + 1.

	negl never throws a runtime exception.


newarray

Operation

	Create a new one-dimensional array object

Format

	newarray
	u30	type

Forms

	newarray = 225 (0xe1)

Operand Stack

	..., length ->
	..., arrayref

Description

	type is an index into the top level abc file type array for
	the array-type descriptor (3.2) for the object to allocate.

	If the array element type is the Object type or one of is
	subtypes, the corresponding class is resolved (...).

	length is an int value on top of the stack that is the number
	of elements in the array to be created.  It is popped.  Memory
	is allocated from the heap (2.3.3) for a new uninitialized
	array of the specified length and type and its elements are
	set to their default values (2.2).

	A reference to the new object is pushed onto the operand
	stack.

Linking Exception

	If the element type is Object or one of its subtypes, and the
	current class does not have permission to access the
	corresponding class, an IllegalAccessError is thrown.

Runtime Exceptions

	If the length value is negative, a NegativeArraySizeError is
	thrown.

	An OutOfMemoryError is thrown if there is no space for the new
	object in the heap.


newbox

Operation

	Create a new box object

Format

	newbox
	u30	type

Forms

	newbox = 1, 224 (0x01, 0xe0)

Operand Stack

	..., structvalue ->
	..., boxref

Description

	type is an index into the top level abc file type array for a
	struct-type descriptor (3.2) for the type of the value to box.
	structvalue must be a value of the struct type (2.2.2)
	specified by type.

	The static result type (2.2.8.1) is always '*'.  The dynamic
	result type (2.2.8.1) is chosen by the virtual machine, but
	must be a box type (2.2.7) whose instance fields correspond in
	name and type with the fields of the struct type specified by
	type, and whose instance methods, if any, correspond in name
	and signature with the methods of the struct type specified by
	type.

	If type specifies a struct type with a single scalar type
	(2.2.1) field, the virtual machine must use the corresponding
	scalar box type (2.2.8.1) as the result type.  The name
	specified by the descriptor is ignored.

	Anonymous struct-type descriptors for the scalar types are
	"@:Z;", "@:B;", "@:b;", "@:S;", "@:s;", "@:I;", "@:i;",
	"@:J;", "@:j;", "@:F;" and "@:D;", which respectively
	correspond to the bool, sbyte, ubyte, short, ushort, int,
	uint, long, ulong, float and double primitive machine types
	(2.2.1).

	Memory is allocated from the heap (2.3.3) for a new
	uninitialized instance of the class corresponding to the
	dynamic result type chosen by the virtual machine.  Each
	instance field of the new object is set to the value of the
	structvalue field of the same name and type.

	A reference to the new object is pushed onto the operand
	stack.

Notes

	The dynamic result type is either defined by a library class
	or synthesized by the virtual machine.


newboxprop

Operation

	Create a new box object from an existing one

Format

	newboxprop
	u30	count
	[u30	field1[, ..., fieldn]]

Forms

	newboxprop = 1, 228 (0x01, 0xe4)

Operand Stack

	..., boxref[, value1[, ..., valuen]] ->
	..., result-boxref

Description

	boxref's static type (2.2.8.1) must be '*'.  If the dynamic
	type of the object referenced by boxref is not a box type
	(2.2.7), a TypeError is thrown.

	count is the number of fields in the new box object whose
	values will differ from those of corresponding fields in the
	object referenced by boxref.  field1 through fieldn are
	indices into the top level abc file string array for the names
	of fields of the object referenced by boxref.  If any of the
	specified fields do not exist in the type of the object
	referenced by boxref, a NoSuchFieldError is thrown.  The value
	of count may be zero, in which case there are no field
	indices.

	There are count replacement field values on top of the operand
	stack.  value1's type must be compatible (...) with field1's
	type, and so on, with valuen's type being compatible with
	fieldn's type.

	If a named field's type is sbyte, ubyte, short, ushort or
	bool, then the corresponding value's type must be int.  If a
	named field's type is int or uint, the corresponding value's
	type be one of int or uint.  If a named field's type is long
	or ulong, the corresponding value's type must be one of long
	or ulong.  If a named field's type is float or double, the
	corresponding value's type must be float or double
	respectively.  If a named field's type is a reference type,
	the corresponding value must be of a type that is assignment
	compatible (...)  with the named field's type.

	Memory is allocated from the heap (2.3.3) for a new
	uninitialized box object of the the same class as the object
	referenced by boxref.  boxref and value1 through valuen are
	popped from the operand stack.  If count is zero, only boxref
	is on the operand stack and popped.

	If a field of the new box object is referenced by one of
	field1 through fieldn, that field is set to the corresponding
	value from the operand stack.  Otherwise, it is set to the
	value of the corresponding field in the object referenced by
	boxref.

	If a value from the operand stack is of type int, its high
	order bits are truncated as necessary to fit into the
	referenced field.

	A reference to the new box object is pushed onto the operand
	stack. The static result type of the reference is always '*'.
	The dynamic type of the new object is the same as that of the
	object referenced by boxref.

Runtime Exceptions

	If boxref is not a reference to a box object, a TypeError is
	thrown.

	If any of field1 through fieldn do not denote a field of the
	object referenced by boxref, a NoSuchFieldError is thrown.

Notes

	The newboxprop instruction effectively copies an existing box
	object, replacing specified field values with values on the
	operand stack.

	If count is zero, the new box object will be a copy of the one
	referenced by boxref.


newclosure

Operation

	Create a new closure object

Format

	newclosure
	ubyte	count
	u30	method

Forms

	newclosure = 229 (0xe5)

Operand Stack

	...[, value1[, ..., valuen]] ->
	..., closureref

Description

	count is the number of values on the operand stack to be bound
	into the closure object.  method is an index into the top
	level abc file method array.  The method's enclosing class is
	referenced by the class field in the indexed method_info item.
	The referenced method is resolved (...).  The method must not
	be an instance method, or an instance, class or interface
	initialization method.  It must be static and not abstract.
	The method's signature is the type of the closure object.

	If the method expects bound values, the values to be bound
	into the closure object are on top of the operand stack in the
	same form as a method argument list.  The value of count, and
	the number, type and order of the values must be consistent
	with the closed-over-variable-type descriptor (3.2) referenced
	by the method's method_body_info item's box field.  The value
	on top of the stack corresponds to the last element of the
	closed-over-variable-type descriptor, the value just beneath
	it to the second-to-last element, and so on.  value1
	corresponds to the first element of the
	closed-over-variable-type descriptor.

	If the referenced method expects no bound values, then count
	must be zero and there must be no bound values on the operand
	stack.

	The values to be bound into the closure object, if any, are
	popped from the operand stack.  Memory is allocated from the
	heap (2.3.3) for a new closure object of the indicated type,
	and the method and popped values are bound into the object.
	The values are bound into the object in such a way that
	getvalue instructions in the method body can access them in
	the order in which they appeared on the operand stack, which
	is also the order in which their types appear in the method's
	closed-over-variable-type descriptor.

	A reference to the new object is pushed onto the operand
	stack.

Linking Exception

	If the resolved method is an instance method, or an instance,
	class or interface initialization method, an
	IncompatibleClassChangeError is thrown.

Runtime Exception

	An OutOfMemoryError is thrown if there is no space for the new
	object in the heap.

Notes

	Though a cov-type descriptor is used to describe values bound
	into a closure object, those values are accessed in the target
	method using getvalue rather than getcov instructions.  The VM
	is free to choose the representation of values bound into a
	closure object.  There is no implication that bound values are
	represented within a closure object by a cov object.

	The stacked values to be bound into the closure object may
	include values of struct, primitive machine (2.2.1) and
	reference (2.2.8) types, including cov object references.
	Free variables bound into closures must first be transformed
	into cov objects that are in turn bound into a closure object.
	Their values are referenced using getcov and putcov
	instructions.

	A virtual method can be bound into a closure object using a
	trampoline method (6.1).


newcov

Operation

	Create a new closed-over-variable object

Format

	newcov
	u30	type

Forms

	newcov = 228 (0xe4)

Operand Stack

	... ->
	..., covref

Description

	type is an index into the top level abc file type array for
	the cov-type descriptor (3.2) for the object to allocate.

	Memory is allocated from the heap (2.3.3) for a new
	uninitialized instance of the specified cov type and its
	fields are set to their default values (2.2).

	A reference to the new object is pushed onto the operand
	stack.

Runtime Exception

	An OutOfMemoryError is thrown if there is no space for the new
	object in the heap.


newinstance

Operation

	Create a new ordinary class object

Format

	newinstance
	u30	type
	u30	sig

Forms

	newinstance = 224 (0xe0)

Operand Stack

	...[, value1[, ..., valuen]] ->
	..., objectref

Description

	type is an index into the top level abc file type array for
	the class-type descriptor (3.2) for the class of the object to
	allocate.  sig is an index into the top level abc file string
	array for a parameter-type descriptor (3.2) for one of the
	class's instance initializer methods.

	The referenced class is resolved (...).  It is initialized
	(...) if it has not already been initialized.

	Memory is allocated from the heap (2.3.3) for a new
	uninitialized instance of the specified class and its fields
	are set to their default values (2.2).  The instance
	initializer method whose parameter signature is sig is then
	invoked on the new object.  Arguments for the instance
	initializer method, if any, are on top of the stack as for
	invoke and call instructions.

	A reference to the new object is pushed onto the operand
	stack.

Linking Exception

	An InstantiationError is thrown if type resolves to an
	interface or abstract class.

Runtime Exception

	An OutOfMemoryError is thrown if there is no space for the new
	object in the heap.

Notes

	There is no way to invoke an instance initializer method other
	than via a newinstance or invokesuper instruction.


newvector

Operation

	Create a new one-dimensional vector object

Format

	newvector
	u30	type

Forms

	newvector = 1, 225 (0x01, 0xe1)

Operand Stack

	..., length ->
	..., vectorref

Description

	type is an index into the top level abc file type array for
	the vector-type descriptor (3.2) for the object to allocate.

	If the vector element type is the Object type or one of its
	subtypes, that corersponding class is resolved (...).

	length is an int value on top of the stack that is the number
	of elements in the vector to be created.  It is popped.
	Memory is allocated from the heap (2.3.3) for a new
	uninitialized vector of the specified length and type and its
	elements are set to their default values (2.2).

	A reference to the new object is pushed onto the operand
	stack.

Linking Exception

	If the element type is the Object type or one of its subtypes
	and the current class does not have permission to access the
	corresponding class, an IllegalAccessError is thrown.

Runtime Exceptions

	If the length value is negative, a NegativeVectorSizeError is
	thrown.

	An OutOfMemoryError is thrown if there is no space for the new
	object in the heap.


noti

Operation

	Bitwise complement integer

Format

	noti

Forms

	noti = 204 (0xcc)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type int or uint.  The int or uint result is
	the bitwise complement of value.  The result is pushed onto
	the operand stack.


notl

Operation

	Bitwise complement long

Format

	notl

Forms

	notl = 205 (0xcd)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type long or ulong.  The long or ulong result
	is the bitwise complement of value.  The result is pushed onto
	the operand stack.


nop

Operation

	No operation

Format

	nop

Forms

	nop = 0 (0x00)

Operand Stack

	... ->
	...

Description

	No operation.


ori

Operation

	Bitwise OR integer

Format

	ori

Forms

	ori = 200 (0xc8)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type int or uint.  The int
	or uint result is the bitwise OR of value1 and value2.  The
	result is pushed onto the operand stack.


orl

Operation

	Bitwise OR long

Format

	orl

Forms

	orl = 201 (0xc9)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type long or ulong.  The
	long or ulong result is the bitwise OR of value1 and value2.
	The result is pushed onto the operand stack.


packst

Operation

	Pack values into a struct value

Format

	packst
	u30	struct

Forms

	packst = 1, 157 (0x01, 0x9d)

Operand Stack

	...[, value1[, ... valuen]] ->
	..., result

Description

	struct is an index into the top level abc file type array for
	a struct-type (3.2) descriptor.

	The values to be packed into the struct value are on top of
	the operand stack.  The number of values must be the same as
	the number of fields of the type denoted by struct.  The
	values are in canonical order (2.2.2) for the type denoted by
	struct, with the value to be assigned to the last struct field
	on top of the operand stack.

	The type of each value packed must be compatible (...)  with
	the corresponding field's type.  If the field type is sbyte,
	ubyte, short, ushort or bool, then the corresponding value's
	type must be int.  If the field type is int or uint, then the
	corresponding value's type be one of int or uint.  If the
	field type is long or ulong, then the corresponding values's
	type must be one of long or ulong.  If the field type is float
	or double, then the corresponding value's type must be float
	or double respectively.  If the field type is a struct or
	reference type, then the corresponding value must be of a type
	that is assignment compatible (...)  with the field type.

	The values are popped from the operand stack and packed into a
	struct result value.  The first struct field is set to value1,
	and so on, with the last struct field set to valuen.  Then,
	the struct result value is pushed onto the operand stack.


pop

Operation

	Pop the top operand stack element

Format

	pop

Forms

	pop = 4 (0x04)

Operand Stack

	..., value ->
	...

Description

	Pop the top operand stack element.


push<type><value>

Operation

	Push constant

Format

	push<type><value>

Forms

	pushi0 = 21 (0x15)
	pushi1 = 22 (0x16)
	pushi2 = 23 (0x17)
	pushi3 = 24 (0x18)

	pushl0 = 25 (0x19)
	pushl1 = 26 (0x1a)

	pushf0 = 27 (0x1b)
	pushf1 = 28 (0x1c)

	pushd0 = 29 (0x1d)
	pushd1 = 30 (0x1e)

Operand Stack

	... ->
	..., value

Description

	Push the constant value specified by the instruction onto the
	operand stack.  pushi0, pushi1, pushi2 and pushi3 respectively
	push the int values 0, 1, 2 and 3.  pushl0 and pushl1
	respectively push the long values 0 and 1.  pushf0 and pushf1
	respectively push the float representation of the floating
	point values 0.0 and 1.0.  pushf0 and pushf1 respectively push
	double representation of the floating point values 0.0 and
	1.0.


push<type>ub

Operation

	Push unsigned byte

Format

	push<type>ub
	ubyte	value

Forms

	pushiub = 17 (0x11)
	pushlub = 19 (0x13)

Operand Stack

	... ->
	..., value

Description

	value is an unsigned byte which is zero-extended and pushed
	onto the operand stack as an int or long, according to whether
	the instruction is pushiub or pushlub.

Notes

	A small negative value may be pushed by a pushiub instruction
	followed by a negi instruction.


push<type>us

Operation

	Push unsigned short

Format

	push<type>us
	ushort	value

Forms

	pushius = 18 (0x12)
	pushlus = 20 (0x14)

Operand Stack

	... ->
	..., value

Description

	value is an unsigned short which is zero-extended and pushed
	onto the operand stack as an int or long, according to whether
	the instruction is pushius or pushlus.

Notes

	A small negative value may be pushed by a pushius instruction
	followed by a negl instruction.


pushnull

Operation

	Push Null

Format

	pushnull

Forms

	pushnull = 16 (0x10)

Operand Stack

	... ->
	..., value

Description

	Push a null reference value onto the operand stack


putcov

Operation

	Store into cov object element

Format

	putcov
	u30	type
	u30	index

Forms

	putcov = 119 (0x77)

Operand Stack

	..., covref, value ->
	...

Description

	type is an index into the top level abc file type array for a
	cov-type descriptor (3.2).  index is an index of an element in
	the cov-type descriptor's type list.

	The type of the value stored by the putcov instruction must be
	compatible (...) with the indexed element's type.  If the
	field type is sbyte, ubyte, short, ushort or bool, then
	value's type must be int.  If the field type is int or uint,
	then value's type be one of int or uint.  If the field type is
	long or ulong, then values's type must be one of long or
	ulong.  If the field type is float or double, then value's
	type must be float or double respectively.  If the field type
	is a struct or reference type, then value must be of a type
	that is assignment compatible (...) with the field type.

	covref and value are popped from the operand stack.  covref
	must be a reference to an object of the referenced cov type.
	value is stored into the referenced element in the object
	referenced by covref.

Runtime Exception

	If the value of covref is null, the putcov instruction
	throws a NullPointerError.

Notes

	Cov object elements are referenced using getcov and putcov
	instructions rather than getfield and putfield, or lda and
	sta.  The VM can therefore choose the representation of cov
	objects independent of those for other objects.


putelement

Operation

	Store into array or vector element

Format

	putelement

Forms

	putelement = 123 (0x7b)

Operand Stack

	..., objectref, index, valueref ->
	...

Description

	index must be a value of type int.

	objectref, index and value are popped from the operand stack.
	If objectref is not a reference to an array or vector object,
	a TypeError is thrown.

	valueref must be an object reference (2.2.8).  The equivalent
	of an "unbox element-type" instruction is executed on
	valueref, where element-type is objectref's type's element
	type, to produce a value.

	If objectref is a reference to an array object, the value is
	stored into the element indexed by index, as for the sta
	instruction.

	If objectref is a reference to a vector object, the value is
	stored into the element indexed by index, as for the stv
	instruction.

Runtime Exceptions

	If objectref is null, a NullPointerError is thrown.

	If objectref does not refer to an array or vector object, a
	TypeError is thrown.

	If valueref does not refer to a class object, a TypeError is
	thrown.

	Other runtime exceptions may be thrown during execution of the
	equivalent of the unbox instruction.


putfield

Operation

	Store into object field

Format

	putfield
	u30	class
	u30	field

Forms

	putfield = 115 (0x73)

Operand Stack

	..., objectref, value ->
	...

Description

	class is an index into the top level abc file type array for a
	class-type descriptor (3.2) for a class.  field is an index
	into the top level abc file string array for the name of a
	field within the referenced class.  The referenced field
	within the referenced class is resolved (...).

	The referenced class is initialized (...) if it has not
	already been initialized.

	value's type must be compatible (...) with the referenced
	field's type.  If the field type is sbyte, ubyte, short,
	ushort or bool, then value's type must be int.  If the field
	type is int or uint, then value's type be one of int or uint.
	If the field type is long or ulong, then values's type must be
	one of long or ulong.  If the field type is float or double,
	then value's type must be float or double respectively.  If
	the field type is a struct or reference type, then value must
	be of a type that is assignment compatible (...) with the
	field type.

	If the referenced field is final, it must be declared in the
	current class (2.3) and the putfield instruction must occur
	within one of the current class's instance initialization
	methods.

	objectref and value are popped from the operand stack.
	objectref must be a reference to an object of the referenced
	class.  value is stored into the referenced field in the
	object referenced by objectref.  If value is of type int, its
	high order bits are truncated as necessary to fit into the
	referenced field.

Linking Exceptions

	Field resolution (...)  may throw an exception.

	If the referenced field is a class static field, an
	IncompatibleClassChangeError is thrown.

	If the referenced field is final and the putfield instruction
	does not occur within one of the current class's instance
	initialization methods, an IllegalAccessError is thrown.

Runtime Exception

	If the value of objectref is null, a NullPointerError is
	thrown.


putfieldstf

Operation

	Store into object field's struct field

Format

	putfieldstf
	u30	class
	u30	field
	u30	struct-field

Forms

	putfieldstf = 1, 115 (0x01, 0x73)

Operand Stack

	..., objectref, value ->
	...

Description

	class is an index into the top level abc file type array for a
	class-type descriptor (3.2) for a class.  field is an index
	into the top level abc file string array for the name of a
	field within the referenced class.  The referenced field
	within the referenced class is resolved (...).  The type of
	the referenced class field must be a struct type.

	struct-field is an index into the top level abc file string
	array for a qualified struct field name (3.1.3).  If
	struct-field does not denote a struct field within the
	referenced class field, a NoSuchFieldError is thrown.

	The referenced class is initialized (...) if it has not
	already been initialized.

	value's type must be compatible (...) with the referenced
	class field's struct field type.  If the field type is sbyte,
	ubyte, short, ushort or bool, then value's type must be int.
	If the field type is int or uint, then value's type must be
	one of int or uint.  If the field type is long or ulong, then
	values's type must be one of long or ulong.  If the field type
	is float or double, then value's type must be float or double
	respectively.  If the field type is a struct or reference
	type, then value must be of a type that is assignment
	compatible (...) with the field type.

	objectref and value are popped from the operand stack.
	objectref must be a reference to an object of the referenced
	class.  value is stored into the referenced struct field in
	the referenced class field in the object referenced by
	objectref.  If value is of type int, its high order bits are
	truncated as necessary to fit into the referenced field.

Linking Exceptions

	Class or struct field resolution (...)  may throw an
	exception.

	if the referenced field is a class static field, an
	IncompatibleClassChangeError is thrown.

	If the referenced field is final and the putfield instruction
	does not occur within one of the current class's instance
	initialization methods, an IllegalAccessError is thrown.

	Class or struct field resolution (...)  may throw an
	exception.

Runtime Exceptions

	If the value of objectref is null, a NullPointerError is
	thrown.

	If struct-field does note denote a struct field within the
	referenced class field, a NoSuchFieldError is thrown.

Notes

	Nested struct values may be stored by the putfieldstf
	instruction.


putprop

Operation

	Store into object field by name

Format

	putprop
	u30	field

Forms

	putprop = 121 (0x79)

Operand Stack

	..., objectref, valueref ->
	...

Description

	field is an index into the top level abc file string array for
	the name of a field within objectref's class.

	objectref and valueref are popped from the operand stack.
	objectref must be a reference to a class object.  The
	referenced field is resolved within objectref's class (...).
	If the referenced field is final, an IllegalAccessError is
	thrown.

	valueref must be an object reference (2.2.8).  The equivalent
	of an "unbox field-type" instruction is executed on valueref,
	where field-type is the type of the discovered field, to
	produce a value.  The value is stored into the referenced
	field in the object referenced by objectref, as for the
	putfield instruction.

Runtime Exceptions

	If objectref is null, a NullPointerError is thrown.

	If objectref or valueref does not refer to a class object, a
	TypeError is thrown.

	Field resolution (...)  may throw an exception.

	If the referenced field is static (that is, is not an instance
	field), an IncompatibleClassChangeError is thrown.

	If the referenced field is final, an IllegalAccessError is
	thrown.

	Other runtime exceptions may be thrown during execution of the
	equivalent of the unbox instruction.

Notes

	The putprop instruction is essentially an auto-reflecting
	putfield instruction.


putstatic

Operation

	Store into class static field

Format

	putstatic
	u30	class
	u30	field

Forms

	putstatic = 117 (0x75)

Operand Stack

	..., value ->
	...

Description

	class is an index into the top level abc file type array for a
	class-type descriptor (3.2) for a class or interface.  field
	is an index into the top level abc file string array for the
	name of a field within the referenced class or interface.  The
	referenced field within the referenced class or interface is
	resolved (...).

	The referenced class or interface is initialized (...) if it
	has not already been initialized.

	value's type must be compatible (...) with the referenced
	field's type.  If the field type is sbyte, ubyte, short,
	ushort or bool, then value's type must be int.  If the field
	type is int or uint, then value's type be one of int or uint.
	If the field type is long or ulong, then values's type must be
	one of long or ulong.  If the field type is float or double,
	then value's type must be float or double respectively.  If
	the field type is a struct or reference type, then value's
	type must be assignment compatible (...) with the field type.

	value is popped from the operand stack and stored into the
	referenced field.

Linking Exceptions

	If the referenced field is not either a class static or an
	interface field, an IncompatibleClassChangeError is thrown.

	Otherwise, if the referenced field is final, it must be
	declared in the current class and the putstatic instruction
	must occur in the current class's initialization method.  If
	not, an IllegalAccessError is thrown.

Notes

	A putstatic instruction may be used to set the value of an
	interface field only once, and only during interface
	initialization.


putstaticstf

Operation

	Store into class static field's struct field

Format

	putstaticstf
	u30	class
	u30	field
	u30	struct-field

Forms

	putstaticstf = 1, 117 (0x01, 0x75)

Operand Stack

	..., value ->
	...

Description

	class is an index into the top level abc file type array for a
	class-type descriptor (3.2) for a class or interface.  field
	is an index into the top level abc file string array for the
	name of a static field within the referenced class or
	interface.  The referenced field within the referenced class
	or interface is resolved (...).  The type of the referenced
	class static or interface field must be a struct type.

	struct-field is an index into the top level abc file string
	array for a qualified struct field name (3.1.3).  It must
	denote a struct field within the referenced class static or
	interface field.

	The referenced class or interface is initialized (...) if it
	has not already been initialized.

	value's type must be compatible (...) with the referenced
	class or interface field's struct field type.  If the field
	type is sbyte, ubyte, short, ushort or bool, then value's type
	must be int.  If the field type is int or uint, then value's
	type must be one of int or uint.  If the field type is long or
	ulong, then values's type must be one of long or ulong.  If
	the field type is float or double, then value's type must be
	float or double respectively.  If the field type is a struct
	or reference type, then value's type must be assignment
	compatible (...)  with the field type.

	value is popped from the operand stack and stored into the
	referenced class static or interface field's struct field.

Linking Exceptions

	If the referenced field is not either a class static or an
	interface field, an IncompatibleClassChangeError is thrown.

	Otherwise, if the referenced field is final, it must be
	declared in the current class and the putstaticstf instruction
	must occur in the current class's initialization method.  If
	not, an IllegalAccessError is thrown.

Notes

	A putstaticstf instruction may be used to set the value of an
	interface field's struct field only once, and only during
	interface initialization.

	Nested struct values may be stored by the putstaticstf
	instruction


ret

Operation

	Return from method

Format

	ret

Forms

	ret = 15 (0x0f)

Operand Stack

	... ->
	[ empty ]

Description

	The current frame is discarded.  Then, if there is no caller
	frame, the current thread exits.  Otherwise, the caller frame
	is made the current frame and control is returned to the
	instruction in the calling method immediately following that
	which invoked the current method.


ret<type>

Operation

	Return value from method

Format

	ret<type>

Forms

	reti = 10 (0x0a)
	retl = 11 (0x0b)
	retf = 12 (0x0c)
	retd = 13 (0x0d)
	retr = 14 (0x0e)

Operand Stack

	..., value ->
	[ empty ]

Description

	The current method must have a return type of
	sbyte/ubyte/bool/short/ushort/int/uint, long/ulong, float,
	double or a reference type, according to whether the
	instruction is reti, retl, retf, retd or retr.  The current
	method's return type is specified by the ret field of the its
	method_info item (3.3.4).

	sbyte, ubyte, bool, short and ushort values are represented on
	the operand stack as int values.  The reti instruction thus
	returns a value of one of these types as an int value.  The
	returned value must be within the range of values for the
	return type.

	The reti and retl instructions respectively return int and
	uint, and long and ulong values.

	For the retr instruction, the return value must be assignment
	compatible (...)  with the current method's return type.

	The current method's return value is on top of the operand
	stack in the current frame (2.4).  It is popped and then
	pushed onto the operand stack in the caller's frame, unless
	there is no caller's frame.  Any remaining values on the
	current method's operand stack are discarded.

	Then, if there is no caller frame, the current thread exits.
	Otherwise, the caller frame is made the current frame and
	control is returned to the instruction in the calling method
	immediately following that which invoked the current method.

Notes

	For sbyte, ubyte, bool, short and ushort return values, an
	explicit down-conversion instruction on the return value may
	be necessary.  For reference type return values, a checkcast
	instruction on the return value may be necessary.


rett

Operation

	Return struct value from method

Format

	rett
	u30	struct

Forms

	rett = 1, 16 (0x01, 0x10)

Operand Stack

	...[, structvalue] ->
	[ empty ]

Description

	struct is an index into the top level abc file type array for
	a struct-type descriptor (3.2) for the struct value to return.
	The current method's return type is specified by the ret field
	of the current method's method_info item (3.3.4), and must
	match struct.

	A return value is on top of the operand stack in the current
	frame (2.4).  It is popped and then pushed onto the operand
	stack in the caller's frame, unless there is no caller frame.
	Any remaining values on the current method's operand stack are
	discarded.

	Then, if there is no caller frame, the current thread exits.
	Otherwise, the caller frame is made the current frame and
	control is returned to the instruction in the calling method
	immediately following that which invoked the current method.

Notes

	The rett instruction can return any value, or no value if
	struct specifies a struct type with no fields.  It is thus a
	generalized return instruction and can be used to replace the
	type-specific return instructions.  Doing so is, however, not
	recommended.  A primitive machine (2.2.1) or reference (2.2.8)
	type return value embedded in a struct value must be packed
	into a struct value in the callee method and then unpacked in
	the calling method, leading to potentially slower execution.


rol

Operation

	Rotate the operand stack left

Format

	rol
	ubyte	n

Forms

	rol = 6 (0x06)

Operand Stack

	..., valuen, value2, ..., value1 ->
	..., value2, ..., value1, valuen

Description

	Shift, from the top of the stack down, n - 1 stack elements
	one slot toward the bottom of the stack.  Push the value that
	was in the overwritten slot (the slot that is n - 1 slots
	below the top of the stack) onto the stack.  The depth of the
	stack is unchanged.

Notes

	"rol 0" is not allowed.  "rol 1" is equivalent to a nop
	instruction.  "rol 2" is equivalent to a swap instruction.


ror

Operation

	Rotate the operand stack right

Format

	ror
	ubyte	n

Forms

	ror = 5 (0x05)

Operand Stack

	..., valuen, ..., value2, value1 ->
	..., value1, valuen, ... value2

Description

	Pop the top operand stack value and shift, starting from the
	top of the stack down, n - 1 stack elements one slot toward
	the top of the stack.  Insert the popped value just below the
	shifted elements.  The depth of the operand stack is
	unchanged.

Notes

	"ror 0" is not allowed.  "ror 1" is equivalent to a nop
	instruction.  "ror 2" is equivalent to a swap instruction.


shli

Operation

	Shift left integer

Format

	shli

Forms

	shli = 192 (0xc0)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 must be of type int or uint.  value2 must also be of
	type int or uint, but value1's type may differ from value2's.
	They are popped from the operand stack.  The result is value1
	shifted left by the number of bits specified by the
	zero-extended low-order five bits of value2.  The high-order
	bits of value2 are ignored.  The vacated low-order bits of the
	shifted result are filled with zero bits.  The result is
	pushed onto the operand stack.


shll

Operation

	Shift left long

Format

	shll

Forms

	shll = 193 (0xc1)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 must be of type long or ulong.  value2 must be of type
	int or uint.  They are popped from the operand stack.  The
	result is value1 shifted left by the number of bits specified
	by the zero-extended low-order six bits of value2.  The
	high-order bits of value2 are ignored.  The vacated low-order
	bits of the shifted result are filled with zero bits.  The
	result is pushed onto the operand stack.


shri

Operation

	Shift right integer

Format

	shri

Forms

	shri = 194 (0xc2)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 must be of type int or uint.  value2 must also be of
	type int or uint, but value1's type may differ from value2's.
	They are popped from the operand stack.  The result is value1
	shifted right by the number of bits specified by the
	zero-extended low-order five bits of value2.  The high-order
	bits of value2 are ignored.  The vacated high-order bits of
	the shifted result are filled with duplicates of value1's most
	significant bit.  The result is pushed onto the operand stack.


shrl

Operation

	Shift right long

Format

	shrl

Forms

	shrl = 195 (0xc3)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 must be of type long or ulong.  value2 must be of type
	int or uint.  They are popped from the operand stack.  The
	result is value1 shifted right by the number of bits specified
	by the zero-extended low-order six bits of value2.  The
	high-order bits of value2 are ignored.  The vacated high-order
	bits of the shifted result are filled with duplicates of
	value1's most significant bit.  The result is pushed onto the
	operand stack.


st<type>

Operation

	Store into local register

Format

	st<type>
	u30	reg

Forms

	sti = 64 (0x40)
	stl = 65 (0x41)
	stf = 66 (0x42)
	std = 67 (0x43)
	str = 68 (0x44)

Operand Stack

	..., value ->
	...

Description

	The value on top of the operand stack is popped and stored
	into local register number <reg>.  The value must be of type
	int/uint, long/ulong, float or double, or an object reference
	or struct value according to whether the instruction is sti,
	stl, stf, std or str.

Notes

	Storing a uint or ulong value is accomplished by a u2i or ul2l
	instruction followed by an sti or stl instruction
	respectively.


sta<type>

Operation

	Store into array element

Format

	sta<type>

Forms

	stab  = 105 (0x69)
	stas  = 107 (0x6b)
	stai  = 109 (0x6d)
	stal  = 110 (0x6e)
	staf  = 111 (0x6f)
	stad  = 112 (0x70)
	star  = 113 (0x71)

Operand Stack

	..., arrayref, index, value ->
	...

Description

	arrayref must be a reference to an array object whose elements
	are of type sbyte/ubyte/bool, short/ushort, int/uint,
	long/ulong, float, double or an object reference type,
	according to whether the instruction is stab, stas, stai,
	stal, staf, stad or star.  The value on top of the stack must
	correspondingly be of type int/uint, long/ulong, float or
	double type according to whether the instruction is
	stab/stas/stai, stal, staf, stad or star.  index must be a
	value of type int.  arrayref, index and value are popped from
	the operand stack.  value is stored into the element of the
	array object indexed by index.

	Values of type sbyte, ubyte, short and ushort are represented
	on the operand stack as values of type int.  For stab and
	stas, the value stored is the low order byte or short of the
	value on top of the operand stack.

	Values of type bool are stored using an stab instruction.  The
	value of the stored byte's bits other than the least
	significant bit must be zero.

Notes

	ubyte, ushort, uint and ulong values are stored using stab,
	stas, stai and stal instructions respectively.


stast

Operation

	Store into array struct element

Format

	stast
	u30	struct

Forms

	stast = 1, 126 (0x01, 0x7e)

Operand Stack

	..., arrayref, index, value ->
	...

Description

	struct is an index into the top level abc file type array for
	a struct-type descriptor.

	arrayref must be a reference to an array object whose elements
	are of the type referenced by struct.  index must be a value
	of type int.  value must be assignment compatible with the
	type referenced by struct.

	arrayref, index and value are popped from the operand stack.
	Then, value is stored into the element of the array object
	indexed by index.


stastf

Operation

	Store into array struct element field

Format

	stastf
	u30	struct-type
	u30	struct-field

Forms

	stastf = 1, 127 (0x01, 0x7f)

Operand Stack

	..., arrayref, index, value ->
	...

Description

	struct-type is an index into the top level abc file type array
	for a struct-type descriptor.  struct-field is an index into
	the top level abc file string array for a qualifield struct
	field name (3.1.3), which must denote a field of either the
	referenced struct type or a struct type nested within the
	referenced struct type.

	arrayref must be a reference to an array object whose element
	type is assignment compatible (...) with the referenced struct
	type.  index must be a value of type int.

	value's type must be compatible (...)  with the referenced
	field's type.  If the field type is sbyte, ubyte, short,
	ushort or bool, then value's type must be int.  If the field
	type is int or uint, then value's type be one of int or uint.
	If the field type is long or ulong, then values's type must be
	one of long or ulong.  If the field type is float or double,
	then value's type must be float or double respectively.  If
	the field type is a struct or reference type, then value must
	be of a type that is assignment compatible (...) with the
	field type.

	arrayref, index and value are popped from the operand stack.
	Then, value is stored into the referenced field of the struct
	element of the array object indexed by index.

Notes

	Nested struct values may be stored by the stastf instruction.


sti<reg>

Operation

	Store integer into local register

Format

	sti<reg>

Forms

	sti1 = 69 (0x45)
	sti2 = 70 (0x46)
	sti3 = 71 (0x47)
	sti4 = 72 (0x48)

Operand Stack

	..., value ->
	...

Description

	The value on top of the operand stack must be of type int.  It
	is popped and stored in local register number <reg>.

Notes

	Storing a uint value is accomplushed by a u2i instruction
	followed by a sti<reg> instruction.


stl<reg>

Operation

	Store long into local register

Format

	stl<reg>

Forms

	stl1 = 73 (0x49)
	stl2 = 74 (0x4a)
	stl3 = 75 (0x4b)

Operand Stack

	..., value ->
	...

Description

	The value on top of the operand stack must be a long value.
	It is popped and stored into local register number <reg>.

Notes

	Storing a ulong value is accomplushed by a ul2l instruction
	followed by an stl<reg> instruction.


stm<type>

Operation

	Store into machine location

Format

	stm<type>

Forms

	stmb = 246 (0xf6)
	stms = 247 (0xf7)
	stmu = 248 (0xf8)
	stml = 249 (0xf9)
	stmf = 250 (0xfa)
	stmd = 251 (0xfb)

Operand Stack

	..., address, value ->
	...

Description

	address is a ulong value that can be used to reference a
	memory location.  Its format is platform and implementation
	dependent.  The value on top of the stack may be of any scalar
	type.

	Pop address and value and use address to store the low order
	one, two, four, eight, four or eight bytes of value into a
	machine location, according to whether the instruction is
	stmub, stmus, stmu, stmul, stmf or stmd.  Whether the byte
	order of the multi-byte stores is little or big-endian is
	platform and implementation dependent.

Notes

	The stm instruction is untyped in the sense that it does not
	require that the value to be stored be of any particular
	primitive machine type (2.2.1).

	The ldm and stm instructions are intended to be used to
	support low level operations on primitive machine type values.
	Code using these instructions is platform and implementation
	dependent, thus only primitive machine types are supported.


str<reg>

Operation

	Store reference into local register

Format

	str<reg>

Forms

	str1 = 76 (0x4c)
	str2 = 77 (0x4d)
	str3 = 78 (0x4e)
	str4 = 79 (0x4f)
	str5 = 80 (0x50)

Operand Stack

	..., value ->
	...

Description

	The value on top of the operand stack must be an object
	reference.  It is popped and stored into local register number
	<reg>.


stst

Operation

	Store struct value into local register

Format

	stst
	u30	reg
	u30	struct-type

Forms

	stst = 1, 69 (0x01, 0x45)

Operand Stack

	..., value ->
	...

Description

	struct-type is an index into the top level abc file type array
	of a struct-type descriptor (3.2).  The value on top of the
	operand stack must be a value of the referenced struct type.
	It is popped and stored into local register number <reg>.


ststf

Operation

	Store into struct field in local register

Format

	ststf
	u30	reg
	u30	struct-type
	u30	struct-field

Forms

	ststf = 1, 141 (0x01, 0x8d)

Operand Stack

	..., value ->
	...

Description

	struct-type is an index into the top level abc file type array
	of a struct-type descriptor (3.2).  struct-field is an index
	the top level abc file string array for a qualifield struct
	field name (3.1.3), which must denote a field of either the
	referenced struct type or a struct type nested within the
	referenced struct type.

	The value in local register number reg must be of the
	referenced struct type.

	value's type must be compatible (...) with the referenced
	field's type.  If the field type is sbyte, ubyte, short,
	ushort or bool, then value's type must be int.  If the field
	type is int or uint, then value's type be one of int or uint.
	If the field type is long or ulong, then values's type must be
	one of long or ulong.  If the field type is float or double,
	then value's type must be float or double respectively.  If
	the field type is a struct or reference type, then value must
	be of a type that is assignment compatible (...) with the
	field type.

	value is popped from the operand stack and stored into the
	referenced field of the struct value in local register reg.
	If value is of type int, its high order bits are truncated as
	necessary to fit into the referenced field.

Notes

	Nested struct values may be stored by the ststf instruction.


stv<type>

Operation

	Store into vector element

Format

	stv<type>

Forms

	stvb  = 1, 105 (0x01, 0x69)
	stvs  = 1, 107 (0x01, 0x6b)
	stvi  = 1, 109 (0x01, 0x6d)
	stvl  = 1, 110 (0x01, 0x6e)
	stvf  = 1, 111 (0x01, 0x6f)
	stvd  = 1, 112 (0x01, 0x70)
	stvr  = 1, 113 (0x01, 0x71)

Operand Stack

	..., vectorref, index, value ->
	...

Description

	vectorref must be a reference to an vector object whose
	elements are of type sbyte/ubyte/bool, short/ushort, int/uint,
	long/ulong, float, double or an object reference type,
	according to whether the instruction is stvb, stvs, stvi,
	stvl, stvf, stvd or star.  The value on top of the stack must
	correspondingly be of type int/uint, long/ulong, float or
	double type according to whether the instruction is
	stvb/stvs/stvi, stvl, stvf, stvd or star.  index must be a
	value of type int.  vectorref, index and value are popped from
	the operand stack.  value is stored into the element of the
	vector object indexed by index.

	Values of type sbyte, ubyte, short and ushort are represented
	on the operand stack as values of type int.  For stvb and
	stvs, the value stored is the low order byte or short of the
	value on top of the operand stack.

	Values of type bool are stored using an stvb instruction.  The
	value of the stored byte's bits other than the least
	significant bit must be zero.

Notes

	ubyte, ushort, uint and ulong values are stored using stvb,
	stvs, stvi and stvl instructions respectively.


stvst

Operation

	Store into vector struct element

Format

	stvst
	u30	struct

Forms

	stvst = 1, 134 (0x01, 0x86)

Operand Stack

	..., vectorref, index, value ->
	...

Description

	struct is an index into the top level abc file type array for
	a struct-type descriptor.

	vectorref must be a reference to an vector object whose
	elements are of the type referenced by struct.  index must be
	a value of type int.  value must be assignment compatible
	(...)  with the type referenced by struct.

	vectorref, index and value are popped from the operand stack.
	Then, value is stored into the element of the vector object
	indexed by index.


stvstf

Operation

	Store into vector struct element field

Format

	stvstf
	u30	struct-type
	u30	struct-field

Forms

	stvstf = 1, 135 (0x01, 0x87)

Operand Stack

	..., arrayref, index, value ->
	...

Description

	struct-type is an index into the top level abc file type array
	for a struct-type descriptor (3.2).  struct-field is an index
	the top level abc file string array for a qualifield struct
	field name (3.1.3), which must denote a field of either the
	referenced struct type or a struct type nested within the
	referenced struct type.

	vectorref must be a reference to an vector object whose
	element type is assignment compatible (...) with the
	referenced struct type.  index must be a value of type int.

	value's type must be compatible (...)  with the referenced
	field's type.  If the field type is sbyte, ubyte, short,
	ushort or bool, then value's type must be int.  If the field
	type is int or uint, then value's type be one of int or uint.
	If the field type is long or ulong, then values's type must be
	one of long or ulong.  If the field type is float or double,
	then value's type must be float or double respectively.  If
	the field type is a struct or reference type, then value must
	be of a type that is assignment compatible (...) with the
	field type.

	vectorref, index and value are popped from the operand stack.
	Then, value is stored into the referenced field of the struct
	element of the vector object indexed by index.

Notes

	Nested struct values may be stored by the stvstf instruction.


subd

Operation

	Subtract double

Format

	subd

Forms

	subd = 167 (0xa7)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	Both value1 and value2 must both be of type double.  They are
	popped from the operand stack.  The double result is value1 -
	value2.  The result is pushed onto the operand stack.

	The result is governed by the rules of IEEE 754 32-bit
	floating point arithmetic.

	Even though overflow, underflow or loss of precision may
	occur, subd never throws a runtime exception.


subf

Operation

	Subtract float

Format

	subf

Forms

	subf = 166 (0xa6)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	Both value1 and value2 must both be of type float.  They are
	popped from the operand stack.  The float result is value1 -
	value2.  The result is pushed onto the operand stack.

	The result is governed by the rules of IEEE 754 32-bit
	floating point arithmetic.

	Even though overflow, underflow or loss of precision may
	occur, subf never throws a runtime exception.


subi

Operation

	Subtract integer

Format

	subi

Forms

	subi = 164 (0xa4)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type int or uint.  They are
	popped from the operand stack.  The int or uint result is
	value1 - value2.  The result is pushed onto the operand stack.

	For int values, value1 - value2 produces the same result as
	value1 + (-value2) and subtraction from zero is the same as
	negation.

	If both operands are int, the result is the low-order 32 bits
	of the true two's-complement mathematical result, represented
	as an int.  On overflow, the sign of the result may not be the
	same as the sign of the mathematical difference.

	If both operands are uint, the result is the low-order 32 bits
	of the true mathematical result, represented as a uint.  That
	is, the mathematical result is truncated to 32 bits.  If
	value1 is less than value2, the 32-bit uint result will be
	greater than value1.

	subi never throws a runtime exception.


subl

Operation

	Subtract long

Format

	subl

Forms

	subl = 165 (0xa5)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type long or ulong.  They
	are popped from the operand stack.  The long or ulong result
	is value1 - value2.  The result is pushed onto the operand
	stack.

	For long values, value1 - value2 produces the same result as
	value1 + (-value2) and subtraction from zero is the same as
	negation.

	If both operands are long, the result is the low-order 64 bits
	of the true two's-complement mathematical result, represented
	as a long.  On overflow, the sign of the result may not be the
	same as the sign of the mathematical difference.

	If both operands are ulong, the result is the low-order 64
	bits of the true mathematical result, represented as a ulong.
	That is, the mathematical result is truncated to 64 bits.  If
	value1 is less than value2, the 64-bit uint result will be
	greater than value1.

	subl never throws a runtime exception.


swap

Operation

	Swap the top two operand stack values

Format

	swap

Forms

	swap = 2 (0x02)

Operand Stack

	..., value2, value1 ->
	..., value1, value2

Description

	Swap the top two operand stack values.


swapn

Operation

	Swap the top operand stack value with another operand stack
	value

Format

	swap
	ubyte	count

Forms

	swapn = 7 (0x07)

Operand Stack

	..., value2, ..., value1 ->
	..., value1, ..., value2

Description

	The top operand stack value is swapped with the operand stack
	value that is count stack slots below the top of the stack.

Notes

	"swapn 0" swaps the top of the stack with itself and is
	equivalent to a nop instruction.  "swapn 1" is equivalent to a
	"swap" instruction.


tableswitch

Operation

	Branch on jump table index

Format

	tableswitch
	u30	 count
	s24	 default_jump_offset
	s24, ... jump_offsets

Forms

	tableswitch = 126 (0x7e)

Operand Stack

	..., index ->
	...

Description

	The tableswitch instructions is a variable length instruction.

	The number of jump_offsets following default_jump_offset is
	(count + 1).  For the purposes of the tableswitch instruction,
	the (count - 1) jump_offsets following default_jump_offset
	constitute a zero-based indexable s24 array, even though s24
	encoded values are variable length.

	An s24 offset value is obtained as follows.

	index must be of type int and is popped off the operand stack.
	If its value is less than zero or greater than count, offset
	is set to default_jump_offset.  Otherwise, index is used as an
	index into the jump_offsets array and offset is set to the
	indexed s24 value.

	The pc register is loaded with offset plus the address of the
	tableswitch instruction opcode.  The new pc value must be the
	address of an instruction opcode within the current method.

Notes

	Unlike other branch instructions, the s24 offset is added to
	the address of the tableswitch instruction rather than to the
	address of the immediately following instruction opcode.


throwe

Operation

	Throw exception

Format

	throwe

Forms

	throwe = 31 (0x1f)

Operand Stack

	..., objectref ->
	objectref

Description

	objectref must be of a reference type and refer to an object
	that is an instance of the Error class or one of its
	subclasses.  It is popped from the operand stack and thrown by
	searching the current method (...) for the first exception
	handler that matches objectref's class, as described in
	section 2.7.

	If a matching handler is found, the pc register is set to the
	handler location, the current frame's operand stack is
	cleared, objectref is pushed onto the operand stack, and
	execution continues at the handler location.

	If no matching handler is found, the current frame is
	discarded.  Then, if there is no caller frame, the current
	thread exits.  Otherwise, the caller frame is made the current
	frame, the pc register is set to the instruction in the
	calling method immediately following that which invoked the
	current method, and objectref is rethrown in the caller frame.

Runtime Exceptions

	If objectref is null, a NullPointerError is thrown instead of
	objectref.

Notes

	The Operand Stack diagram shows the effect on the operand
	stack in the frame for which a matching handler is found,
	whether the current frame or an older caller frame.  If the
	latter, the current frame and all intervening frames up to,
	but not including, the frame for which a handler is found, are
	discarded.


ushri

Operation

	Unsigned shift right integer

Format

	ushri

Forms

	ushri = 196 (0xc4)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 must be of type int or uint.  value2 must also be of
	type int or uint, but value1's type may differ from value2's.
	They are popped from the operand stack.  The result is value1
	shifted right by the number of bits specified by the
	zero-extended low-order five bits of value2.  The high-order
	bits of value2 are ignored.  The vacated high-order bits of
	the shifted result are filled with zero bits.  The result is
	pushed onto the operand stack.


ushrl

Operation

	Unsigned shift right long

Format

	ushrl

Forms

	ushrl = 197 (0xc5)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 must be of type long or ulong.  value2 must be of type
	int or uint.  They are popped from the operand stack.  The
	result is value1 shifted right by the number of bits specified
	by the zero-extended low-order six bits of value2.  The
	high-order bits of value2 are ignored.  The vacated high-order
	bits of the shifted result are filled with zero bits.  The
	result is pushed onto the operand stack.


u2i

Operation

	Convert unsigned to signed integer

Format

	0x01
	i2u

Forms

	u2i = 1, 209 (0x01, 0xd1)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type uint.  It is popped from the operand
	stack and reinterpreted as an int.  The int result is pushed
	onto the operand stack.

Notes

	The u2i instruction changes the type of the top of stack value
	from uint to int.  Otherwise it is equivalent to a nop
	instruction.


u2l

Operation

	Convert unsigned integer to signed long

Format

	0x01
	i2l

Forms

	u2l = 1, 208 (0x01, 0xd0)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type uint.  It is popped from the operand
	stack and zero-extended to a long result.  The long result is
	pushed onto the operand stack.

Notes

	The potential instruction u2ul can be composed from a u2l
	instruction followed by an l2ul instruction.

	The potential instruction u2f can be composed from a u2l
	instruction followed by an l2f instruction.

	The potential instruction u2d can be composed from a u2l
	instruction followed by an l2d instruction.


ul2d

Operation

	Convert unsigned long to double

Format

	ul2d

Forms

	ul2d = 1, 215 (0x01, 0xd7)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type ulong.  It is popped from the operand
	stack and converted to a double result using IEE-754
	round-to-nearest mode.  The double result is pushed onto the
	operand stack.

Notes

	Loss of precision may occur since double values have only 53
	significand bits.


ul2f

Operation

	Convert unsigned long to float

Format

	ul2f

Forms

	ul2f = 1, 214 (0x01, 0xd6)

Operand Stack

	..., value ->
	..., result

Description

	value must be of type ulong.  It is popped from the operand
	stack and converted to a float result using IEE-754
	round-to-nearest mode.  The float result is pushed onto the
	operand stack.

Notes

	Loss of precision may occur since float values have only 24
	significand bits.


unbox

Operation

	Unbox from '*'

Format

	unbox
	u30	type

Forms

	unbox = 125 (0x7d)

Operand Stack

	..., objectref ->
	..., value

Description

	type is an index into the top level abc file type array for
	the type name string for the target type of the value to
	unbox.  objectref must be an object reference (2.2.8).

	If type denotes a class type (2.2), and objectref is a
	reference to an object of that class, the operand stack is
	left unchanged.

	If type denotes the Object class or one of its subclasses, the
	equivalent of a "checkcast type" instruction is executed.

	If type denotes a struct type (2.2.2), a TypeError is thrown
	if objectref is not a reference to an object of the
	corresponding box class (2.2.7).  Then, objectref is popped
	from the operand stack, the boxed struct value is extracted
	from the referenced box object and the extracted struct value
	is pushed onto the operand stack.

	Otherwise, a TypeError is thrown if type does not denote a
	primitive machine type (2.2.1), or if objectref is not a
	reference to a scalar object.  The equivalent of an
	"invokevirtual to<type>" instruction is then executed, where
	"to<type>" is the name of a conversion method on the box
	object's class that attempts to convert the boxed value to a
	value of the target primitive machine type.  Conversion method
	semantics are defined in Appendix A.

	An example of the name of such a method is "toI" for
	conversions from a boxed scalar value to int.  The name of the
	conversion method can be constructed by catenating the string
	"to" with the target type name string.  The conversion method
	name is thus always a three-character string.

	The conversion methods are "almost pure" functions.  They have
	no side effects other than that they may throw an exception.

	If the conversion method returns a result without throwing an
	exception, a primitive machine type value of the specified
	type is returned on top of the stack.  sbyte and short values
	are returned sign-extended, and ubyte, bool and ushort values
	are returned zero-extended to int values.

Runtime Exceptions

	TypeError may be thrown by the unbox instruction.  Other
	runtime exceptions may be thrown during invocation and
	execution of the conversion method or the equivalent of the
	checkcast instruction.

Notes

	The wording "The equivalent of an invokevirtual instruction
	..." allows the virtual machine to implement the conversion
	methods in any way it chooses.

	Because type array entries one through eleven denote the
	eleven scalar types, the type argument can be used to optimize
	execution of an unbox instruction.

	If type denotes the Object type or one of its subtypes, the
	unbox instruction can be used to narrow the type of a
	reference to an object of the '*' type.  A checkcast
	instruction, however, can be used instead.


unpackst

Operation

	Unpack values from a struct value

Format

	unpackst
	u30	struct

Forms

	unpackst = 1, 158 (0x01, 0x9e)

Operand Stack

	..., value
	...[, result1[, ... resultn] ] ->

Description

	struct is an index into the top level abc file type array for
	a struct-type (3.2) descriptor.

	The value on top of the operand stack must be a struct value
	that is assignment compatible (...) with the type denoted by
	struct.  It is popped, and its field values are pushed onto
	the operand stack in canonical order (2.2.2).  The type
	denoted by struct may have no fields, in which case no value
	is pushed.

	Values of type sbyte and short are signed-extended, and values
	of type ubyte, bool and ushort are zero-extended to an int
	value before being pushed onto the operand stack.  The value
	pushed is of type int.


vectorlen

Operation

	Load vector length

Format

	vectorlen

Forms

	vectorlen = 1, 9 (0x01, 0x09)

Operand Stack

	..., vectorref ->
	..., length

Description

	vectorref is a reference to a vector object on top of the
	operand stack.  Pop it and push the current length of the
	referenced vector as an int value.


wide

Operation

	Two-byte opcode prefix

Format

	wide

Forms

	wide = 1 (0x01)

Operand Stack

	... ->
	...

Description

	Modify the meaning of the following instruction.

Notes

	The wide instruction acts as the prefix byte of a two-byte
	opcode.  For example, the one-byte opcode for the newarray
	instruction is 0xe1.  The two-byte opcode for the
	corresponding newvector instruction is 0x01 0xe1.


xori

Operation

	Bitwise exclusive OR integer

Format

	xori

Forms

	xori = 202 (0xca)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type int or uint.  The int
	or uint result is the bitwise exclusive OR of value1 and
	value2.  The result is pushed onto the operand stack.


xorl

Operation

	Bitwise exclusive OR long

Format

	xorl

Forms

	xorl = 203 (0xcb)

Operand Stack

	..., value1, value2 ->
	..., result

Description

	value1 and value2 must both be of type long or ulong.  The
	long or ulong result is the bitwise exclusive OR of value1 and
	value2.  The result is pushed onto the operand stack.


6 Code Generation

6.1 Bind a Virtual Method into a Closure Object

A closure object can be produced from a virtual method by creating a
static method that acts as a trampoline.  The trampoline is the method
bound into a closure created by the newclosure instruction.  The
single bound value is the receiver object reference to be used to
resolve the virtual method.  The trampoline method has a single
element in the closed-over-variable-type descriptor referenced by the
box field in the method's method_body_info, which is the receiver
object's type name.

The creation of a closure object for a virtual method and a call to
the trampoline consists of the following code.

ldr1	    	// Push receiver object reference in local register 1
		// onto the operand stack
newclosure trampoline
	   	// Bind the trampoline and the receiver object reference
		// into a closure object
str2		// Store closure object reference in local register 2
...		// Push virtual method argument values onto the operand
		// stack, left to right
ldr2		// Push closure object reference onto the operand stack
callindirect	// Call the trampoline method

In this example, the trampoline method's method_body_info item's box
field references a closed-over-variable-type descriptor of the form
"C&foo;;", where foo is target virtual method's enclosing class.

The trampoline method consists of the following code.

getvalue 0     // Push the first bound value, which is the receiver
	       // object reference bound into the closure
ldr0	       // push local registers containing method argument values,
...	       // starting with local register 0
invokevirtual method
	       // invoke the virtual method
ret	       // return assuming the virtual method returns no result

In this example, virtual method resolution occurs when the closure is
called, but the compiler is free to generate trampolines that directly
invoke a method (using calldirect) when the target method can be
statically determined.

6.2 Closure Creation and Use

The output of the following AS4 code snippet will be

    a = 11

and the value of "result" will be 23.

static function getNF() : Function {
    var a : int = 2;
    var f : Function = function myFunction(b : int) : int {
        a++;
        trace("a = " + a);
        return a + b;
    }
    a = 10;
    return f;
}

let foo : Function = getNF();
let result = foo(12);

6.2.1 getNF() Metadata

The generated method_info (3.3.4) and method_body_info (3.3.7) items
for getNF():

method_info 20
{
  sig:   "()"		// no formal parameters
  ret:   "&Function;"	// return a Function object
  name:  "getNF"
  class: "..."
  flags: is_static
}

method_body_info
{
  method:          20 -> "getNF"
  box:             0    // no bound values
  max_stack:       3
  local_count:     0
  literal_count:   0
  exception_count: 0
  code_length:     ...
  code:            ...
}

6.2.2 myFunction() Metadata

The generated method_info and method_body_info items for myFunction():

method_info 21
{
  sig:   "(I)"		// a single formal parameter, "b"
  ret:   "I"		// return an int
  name:  "myFunction"
  class: "..."
  flags: is_static
}

method_body_info
{
  method:          21 -> "myFunction"
  box:             "CCI;"	// a single bound value, whose type is "CI;"
  max_stack:       2
  local_count:     1		// formal parameter "b"
  literal_count:   0
  exception_count: 0
  code_length:     ...
  code:            ...
}

myFunction()'s method_body_info item's box field references a cov-type
descriptor (3.2).  The descriptor does not imply that there exists an
actual cov object reference bound into every closure object.  The
descriptor is simply a convenient way to specify a bound value type
list.

6.2.3 Generated Bytecode

getNF:
  newcov "CI;"            // promote 'a' from a primitive int to a cov object
  dup                     // for putcov that initialized 'a'
  pushi2
  putcov "CI;" 0          // a = 2;
  dup                     // for newclosure
  newclosure "myFunction" // f = myFunction ...;
                          // bind reference to cov object containing 'a'
                          // into the closure
  swap                    // reference to cov object containing 'a' to tos
  pushiub 10
  putcov "CI;" 0          // a = 10; f now in tos
  retr                    // return f;

f:
  getvalue 0              // load reference to cov object containing 'a'
                          // for putcov
  dup                     // for getcov
  getcov "CI;" 0          // load 'a'
  pushi1
  addi
  putcov "CI;" 0          // a++; operand stack is empty
  ldcs "a = "
  getvalue 0              // load reference to cov object containing 'a'
  getcov "CI;" 0          // load 'a'
  calldirect "lang.String.concatI"
                          // "a = " + a: concatI() catenates a scalar int value
                          // onto a String, returning a String reference
  calldirect "runtime.trace"
                          // trace(); operand stack is empty
  getvalue 0              // load reference to cov object containing 'a'
  getcov "CI;" 0          // load 'a'
  ldr0                    // load 'b'
  addi                    // a + b
  reti                    // return a + b;

  // use getNF() and f()
  pushiub 12              // argument for callindirect
  calldirect "getNF"      // foo = getNF(); foo now in tos
  callindirect            // result = foo(12);

6.3 Floating Point Comparisons

Both cmpfg/cmpdg and cmpfl/cmpdl are necessary to compare float/double
values.

Given float values x and y on top of the operand stack, the code for
==, !=, <, <=, > and >= is

if (x == y) ...

  cmpfg
  ifzeqi true-label

if (x != y) ...

  cmpfg
  ifzeqi false-label

if (x < y) ...

  cmpfg
  ifzlsi true-label

if (x <= y) ...

  cmpfg
  ifzgt false-label

if (x > y) ...

  cmpfl
  ifzgt true-label

if (x >= y) ...

  cmpfl
  ifzlsi false-label

6.4 Materializing bool Values

Materialize an int comparison:

  push left
  push right
  ifcmp<cond>i 1f
  pushi0
  jump 2f
1f:
  pushi1
2f:

Materialize a long <= comparison:

  push left
  push right
  cmpl
  ifzgti 1f
  pushi1
  jump 2f
1f:
  pushi0
2f:

6.5 Constructors: Extended Example

Given the AS4 source code:

class A {
  var v : int;
  let dateStamp : Date = Date.current();
  let x : X;
  function A(x : X) {
    this.x = x;
  }
}

class B extends A {
  let y : Y;
  function B(x : X, y : Y, k : Key, d : Dictionary) {
    super(x);
    this.y = computeSomething(x, y);
    defer {
      d.add(k, this);
    }
  }
}

class C extends B {
  let z : Z;
  function C(x : X, y : Y, k : Key, d : Dictionary, z : Z) {
    super(x, y, k, d);
    this.z = z;
    print(d);
    defer {
      print(this);
    }
  }
}

The resulting pseudo-code and generated bytecode (%prep% methods are
the methods invoked by the newinstance instruction):

function A.%init%(x : X) : ()=>void {
  def = super.%init%();
  // A’s init code:
  this.v = 0;
  this.dateStamp : Date = Date.current();
  this.x = x;
  return function() {
    def();
  }
}

A.%init%:
  ldr0			// this
  invokesuper "%init%"
  // def in tos
  ldr0			// this, for x
  pushi0
  putfield "A" "v"	// this.v = 0;
  ldr0			// this
  calldirect "Date.current"
  putfield "A" "datestamp"// this.dateStamp = Date.current();
  ldr0			// this
  ldr1	     		// x
  putfield "A" "x"	// this.x = x;
  newclosure "A.%defer%"// bind def
  retr

A.%defer%:
  getvalue 0		// def
  callindirect		// def()
  ret

function A.%prep%(x : X) {
  def = A.%init%(this, x);
  def();
}

A.%prep%:
  ldr0			// this
  ldr1			// x
  invokevirtual %init%
  // def in tos
  callindirect		// def()
  ret

function B.%init%(x : X, y : Y, k : Key, d : Dictionary) : ()=>void {
  def = super.%init%(x); // call super
  this.y = computeSomething(x, y); // B’s init code
  return function() {
    def();
    d.add(k, this); // B’s deferred code
  }
}

B.%init%:
  ldr0			// this
  ldr1			// x
  invokesuper %init%
  // def in tos
  ldr0			// this
  ldr1			// x
  ldr2			// y
  calldirect "computeSomething"
  putfield "B" "y"	// this.y = computeSomething(x, y);
  ldr0			// this
  ldr3			// k
  ldr4			// d
  newclosure "B.%defer%"// bind def, this, k, d
  retr

B.%defer%:
  getvalue 1	// this
  getvalue 0	// def
  callindirect	// def()
  getvalue 3	// d
  getvalue 2	// k
  getvalue 1	// this
  invokevirtual "add"
  ret

function B.%prep%(x : X, y : Y, k : Key, d : Dictionary) {
  def = B.%init%(x, y, k, d);
  def();
}

B.%prep%:
  ldr0			// this
  ldr1			// x
  ldr2			// y
  ldr3			// k
  ldr4			// d
  invokevirtual %init%
  // def in tos
  callindirect		// def()
  ret

function C.%init%(x : X, y : Y, k : Key, d : Dictionary, z : Z)
: ()=>void {
  def = super.%init%(x, y, k, d); // call super
  // C’s init code:
  this.z = z;
  print(d);
  return function() {
    def();
    print(this); // C’s deferred code
  }
}

C.%init%:
  ldr0			// this
  ldr1			// x
  ldr2			// y
  ldr3			// k
  ldr4			// d
  invokesuper %init%
  // def in tos
  ldr0	    		// this
  ldr5			// z
  putfield "C" "z"
  ldr4			// d
  calldirect "print"
  ldr0			// this
  newclosure "C.%defer%"// bind def, this
  retr

C.%defer%:
  getvalue 0		// def
  callindirect		// def()
  getvalue 1		// this
  calldirect "print"
  ret

function C.%prep%(this : C, x : X, y : Y, k : Key, d : Dictionary, z : Z) {
  def = C.%init%(this, x, y, k, d, z);
  def();
}

C.%prep%:
  ldr0			// this
  ldr1			// x
  ldr2			// y
  ldr3			// k
  ldr4			// d
  ldr5			// z
  invokevirtual %init%
  // def in tos
  callindirect		// def()
  ret

----

// Allocate an A

a = new A(x);

  ldr1			// x
  newinstance "&A;" "(&X;)"

----

// Allocate a B

b = new B(x, y, k, d);

  ldr1			// x
  ldr2			// y
  ldr3			// k
  ldr4			// d
  newinstance "&B;" "(&X;&Y;&Key;&Dictionary;)"

----

// Allocate a C

c = new C(x, y, k, d, z);

  ldr1			// x
  ldr2			// y
  ldr3			// k
  ldr4			// d
  ldr5			// z
  newinstance "&C;" "(&X;&Y;&Key;&Dictionary;&Z;)"

----

C() after inlining by a compiler:

function C(x : X, y : Y, k : Key, d : Dictionary, z : Z) :void {
  this.x = x;
  this.y = computeSomething(x, y);
  this.z = z;
  print(d);
  d.add(k, this);
  print(this);
}

C.%init%:
  // as above

C.%defer%:
  // as above

C.%prep%:
  // inline C.%init% and C.%defer%
  ldr0	    		// this
  ldr1			// x
  putfield "C" "z"	// this.x = x
  ldr0	     		// this
  ldr1			// x
  ldr2			// y
  calldirect "computeSomething"
  putfield "C" "y"	// this.y = computeSomething(x, y);
  ldr4			// d
  ldr3			// k
  ldr0			// this
  invokevirtual "add"
  ldr0			// this
  calldirect "print"
  ret


7 Opcode Map

Opcode ranges in the map that are labeled with a count, for example

       0xfc - 0xff	4

are empty and contain that number (in this case, four) of unused
opcode values.

0x00		nop
0x01	   	wide
  0x00 - 0x02	Debug
  0x03 - 0x08	6
  0x09 	 	vectorlen
  0x0a - 0xf	6
  0x10 	 	rett
  0x11 - 0x24	20
  0x25 	 	ldst
  0x26 - 0x44	31
  0x45 	 	stst
  0x46 - 0x5f	26
  0x60 - 0x68	Vector Load
  0x69   	stvb
  0x6a		1
  0x6b		stvs
  0x6c		stvst
  0x6d - 0x71	Vector Store
  0x72 - 0x77	get/put stf
  0x78 - 0x7b	4
  0x7c - 0x7f	ldast, ldastf, stast, stastf
  0x80 - 0x83	4
  0x84 - 0x87	ldvst, ldvstf, stvst, stvstf
  0x88 - 0x8b	4
  0x8c - 0x8d	ldstf, ststf
  0x8f - 0x9c	14
  0x9d - 0x9e	packst, unpackst
  0x9f - 0xcf	49
  0xd0 - 0xd1	u2l, u2i
  0xd2 - 0xd4	3
  0xd5 - 0xd7	ul2l, ul2f, ul2d
  0xd8 - 0xdc	5
  0xdd 	 	d2ul
  0xde - 0xdf	2
  0xe0 	 	newbox
  0xe1		newvector
  0xe2		fillnewvector
  0xe3		cfillnewvector
  0xe4		newboxprop
  0xe5		1
  0xe6		multinewvector
  0xe7 - 0xff	25
0x02 - 0x08	Stack Manipulation
0x09   		arraylen
0x0a - 0x0f	Return
0x10 - 0x1e	Push Immediate
0x1f   		throwe
0x20 - 0x33	Load Register
0x34 - 0x3b	Load Constant
0x3c - 0x3f	ifnull, ifnotnull, ifeqr, ifner
0x40 - 0x53	Store/Load Register
0x54 - 0x5f	ifz, ifcmp
0x60 - 0x68	Array Load
0x69   		stab
0x6a		i2z
0x6b		stas
0x6c		stast
0x6d - 0x71	Array Store
0x72 - 0x7b	get/put
0x7c   		getvalue
0x7d		unbox
0x7e		tableswitch
0x7f		lookupswitch
0x80 - 0x8f	16
0x90   		coerce
0x91   		cmpu
0x92 - 0x95	Narrowing Conversions from int
0x96   		checkcast
0x97 - 0x9c	cmp
0x9d - 0x9e	2
0x9f		isinstanceof
0xa0 - 0xbb	Arithmetic Operations
0xbc - 0xbf	inc/dec Register
0xc0 - 0xcd	Bit Operations
0xce   		label
0xcf		jump
0xd0 - 0xdf	Conversions
0xe0 - 0xe6	new, fill
0xe7 - 0xe8	call, callv
0xe9 - 0xed	invoke
0xee - 0xef	calldirect, callindirect
0xf0 - 0xfb	MOPs
0xfc - 0xff	4


Appendix A: coerce and unpack Conversion Methods

Here are AS4 implementations of the primitive machine type (2.2.1)
conversion methods discussed in the definitions of the coerce and
unpack instructions.  Only the method semantics are part of this
specification.  Virtual machine implementations are not otherwise
bound by the following AS4 code.  The "as if" rule applies.

All values returned from the conversion methods are guaranteed to be
within range for their types.

AS4 does not support the byte, short and ushort primitive machine
types, so the AS4 code below uses int instead.

A.1 bool

There are no legal conversions between bool and primitive machine
types.

public final class bool {
  private let _value : bool;
  private function bool(value : bool) { _value = value; }
  private function unbox() : bool { return _value; }

  private static native function z2z(value : bool) : bool {
    // i2z bytecode instruction
  }

  public static function ZtoZ(value : bool) : bool { return i2z(value); }
  public static function ZtoB(value : bool) : /*sbyte*/int {
    throw new TypeError();
    return 0;
  }
  public static function Ztob(value : bool) : byte {
    throw new TypeError();
    return 0;
  }
  public static function ZtoS(value : bool) : /*short*/int {
    throw new TypeError();
    return 0;
  }
  public static function Ztos(value : bool) : /*ushort*/int {
    throw new TypeError();
    return 0;
  }
  public static function ZtoI(value : bool) : int {
    throw new TypeError();
    return 0;
  }
  public static function Ztoi(value : bool) : uint {
    throw new TypeError();
    return 0;
  }
  public static function ZtoJ(value : bool) : long {
    throw new TypeError();
    return 0;
  }
  public static function Ztoj(value : bool) : ulong {
    throw new TypeError();
    return 0;
  }
  public static function ZtoF(value : bool) : float {
    throw new TypeError();
    return 0;
  }
  public static function ZtoD(value : bool) : double {
    throw new TypeError();
    return 0;
  }

  public function toZ() : bool   { return ZtoZ(unbox()); }
  public function toB() : int    { return ZtoB(unbox()); }
  public function tob() : byte   { return Ztob(unbox()); }
  public function toS() : int    { return ZtoS(unbox()); }
  public function tos() : int    { return Ztos(unbox()); }
  public function toI() : int    { return ZtoI(unbox()); }
  public function toi() : uint   { return Ztoi(unbox()); }
  public function toJ() : long   { return ZtoJ(unbox()); }
  public function toj() : ulong  { return Ztoj(unbox()); }
  public function toF() : float  { return ZtoF(unbox()); }
  public function toD() : double { return ZtoD(unbox()); }
}

A.2 byte

AS4 has no signed byte type, so int is used instead.

public final class sbyte {
  private let _value : /*sbyte*/int;
  private function sbyte(value : /*sbyte*/int) { _value = value; }
  private function unbox() : /*sbyte*/int { return _value; }

  private static native function b2b(value : /*sbyte*/int) : /*sbyte*/int {
    // i2sb bytecode instruction
  }
  private static native function b2ub(value : /*sbyte*/int) : byte {
    // i2ub bytecode instruction
  }
  private static native function b2s(value : /*sbyte*/int) : /*short*/int {
    // i2sb bytecode instruction
  }
  private static native function b2us(value : /*sbyte*/int) : /*ushort*/int {
    // i2ub bytecode instruction
  }
  private static native function b2i(value : /*sbyte*/int) : int {
    // i2sb bytecode instruction
  }
  private static native function b2u(value : /*sbyte*/int) : uint {
    // i2ub, i2u bytecode instructions
  }
  private static native function b2l(value : /*sbyte*/int) : long {
    // i2sb, i2l bytecode instructions
  }
  private static native function b2ul(value : /*sbyte*/int) : ulong {
    // i2ub, i2l, l2ul bytecode instructions
  }
  private static native function b2f(value : /*sbyte*/int) : float {
    // i2sb, i2f bytecode instructions
  }
  private static native function b2d(value : /*sbyte*/int) : double {
    // i2sb, i2d bytecode instructions
  }

  public static function BtoZ(value : int) : bool {
    throw new TypeError();
    return false;
  }
  public static function BtoB(value : /*sbyte*/int) : /*sbyte*/int
                                                             { return b2b(value); }
  public static function Btob(value : /*sbyte*/int) : byte {
    if (value < 0) throw new RangeError();
    return b2ub(value);
  }
  public static function BtoS(value : /*sbyte*/int) : /*short*/int
                                                             { return b2s(value); }
  public static function Btos(value : /*sbyte*/int) : int {
    if (value < 0) throw new RangeError();
    return b2us(value);
  }
  public static function BtoI(value : /*sbyte*/int) : int    { return b2i(value); }
  public static function Btoi(value : /*sbyte*/int) : uint {
    if (value < 0) throw new RangeError();
    return b2u(value);
  }
  public static function BtoJ(value : /*sbyte*/int) : long   { return b2l(value); }
  public static function Btoj(value : /*sbyte*/int) : ulong {
    if (value < 0) throw new RangeError();
    return b2ul(value);
  }
  public static function BtoF(value : /*sbyte*/int) : float  { return b2f(value); }
  public static function BtoD(value : /*sbyte*/int) : double { return b2d(value); }

  public function toZ() : bool   { return BtoZ(unbox()); }
  public function toB() : int    { return BtoB(unbox()); }
  public function tob() : byte   { return Btob(unbox()); }
  public function toS() : int    { return BtoS(unbox()); }
  public function tos() : int    { return Btos(unbox()); }
  public function toI() : int    { return BtoI(unbox()); }
  public function toi() : uint   { return Btoi(unbox()); }
  public function toJ() : long   { return BtoJ(unbox()); }
  public function toj() : ulong  { return Btoj(unbox()); }
  public function toF() : float  { return BtoF(unbox()); }
  public function toD() : double { return BtoD(unbox()); }
}

A.3 ubyte

public final class byte {
  private let _value : byte;
  private function byte(value : byte) { _value = value; }
  private function unbox() : byte { return _value; }

  private static native function ub2b(value : byte) : /*sbyte*/int {
    // i2ub bytecode instruction
  }
  private static native function ub2ub(value : byte) : byte {
    // i2ub bytecode instruction
  }
  private static native function ub2s(value : byte) : /*short*/int {
    // i2ub bytecode instruction
  }
  private static native function ub2us(value : byte) : /*ushort*/int {
    // i2ub bytecode instruction
  }
  private static native function ub2i(value : byte) : int {
    // i2ub bytecode instruction
  }
  private static native function ub2u(value : byte) : uint {
    // i2ub, i2u bytecode instructions
  }
  private static native function ub2l(value : int) : long {
    // i2ub, i2l bytecode instructions
  }
  private static native function ub2ul(value : int) : ulong {
    // i2ub, i2l, l2ul bytecode instructions
  }
  private static native function ub2f(value : int) : float {
    // i2ub, i2f bytecode instructions
  }
  private static native function ub2d(value : int) : double {
    // i2ub, i2d bytecode instructions
  }

  public static function btoZ(value : byte) : bool {
    throw new TypeError();
    return false;
  }
  public static function btoB(value : byte) : /*sbyte*/int  { return ub2b(value);  }
  public static function btob(value : byte) : byte          { return ub2ub(value;  }
  public static function btoS(value : byte) : /*short*/int  { return ub2s(value);  }
  public static function btos(value : byte) : /*ushort*/int { return ub2us(value); }
  public static function btoI(value : byte) : int           { return ub2i(value);  }
  public static function btoi(value : byte) : uint          { return ub2u(value);  }
  public static function btoJ(value : byte) : long          { return ub2l(value);  }
  public static function btoj(value : byte) : ulong         { return ub2ul(value); }
  public static function btoF(value : byte) : float         { return ub2f(value);  }
  public static function btoD(value : byte) : double        { return ub2d(value);  }

  public function toZ() : bool   { return btoZ(unbox()); }
  public function toB() : int    { return btoB(unbox()); }
  public function tob() : byte   { return btob(unbox()); }
  public function toS() : int    { return btoS(unbox()); }
  public function tos() : int    { return btos(unbox()); }
  public function toI() : int    { return btoI(unbox()); }
  public function toi() : uint   { return btoi(unbox()); }
  public function toJ() : long   { return btoJ(unbox()); }
  public function toj() : ulong  { return btoj(unbox()); }
  public function toF() : float  { return btoF(unbox()); }
  public function toD() : double { return btoD(unbox()); }
}

A.4 short

AS4 has no signed short type, so int is used instead.

public final class short {
  private let _value : /*short*/int;
  private function short(value : /*short*/int) { _value = value; }
  private function unbox() : /*short*/int { return _value; }

  private static native function s2b(value : /*short*/int) : /*sbyte*/int {
    // nop bytecode instruction
  }
  private static native function s2ub(value : /*short*/int) : byte {
    // nop bytecode instruction
  }
  private static native function s2s(value : /*short*/int) : /*short*/int {
    // i2s bytecode instruction
  }
  private static native function s2us(value : /*short*/int) : /*ushort*/int {
    // i2us bytecode instruction
  }
  private static native function s2i(value : /*short*/int) : int {
    // i2s bytecode instruction
  }
  private static native function s2u(value : /*short*/int) : uint {
    // i2us, i2u bytecode instructions
  }
  private static native function s2l(value : /*short*/int) : long {
    // i2s, i2l bytecode instructions
  }
  private static native function s2ul(value : /*short*/int) : ulong {
    // i2us, i2l, l2ul bytecode instructions
  }
  private static native function s2f(value : /*short*/int) : float {
    // i2s, i2f bytecode instructions
  }
  private static native function s2d(value : /*short*/int) : double {
    // i2s, i2d bytecode instructions
  }

  public static function StoZ(value : /*short*/int) : bool {
    throw new TypeError();
    return false;
  }
  public static function StoB(value : /*short*/int) : /*sbyte*/int {
    if (value < -128 || value > 127) throw new RangeError();
    return s2b(value);
  }
  public static function Stob(value : /*short*/int) : byte {
    if (value < 0 || value > 255) throw new RangeError();
    return s2ub(value);
  }
  public static function StoS(value : /*short*/int) : /*short*/int
                                                             { return s2s(value); }
  public static function Stos(value : /*short*/int) : /*ushort*/int {
    if (value < 0) throw new RangeError();
    return s2us(value);
  }
  public static function StoI(value : /*short*/int) : int    { return s2i(value); }
  public static function Stoi(value : /*short*/int) : uint {
    if (value < 0) throw new RangeError();
    return s2u(value);
  }
  public static function StoJ(value : /*short*/int) : long   { return s2l(value); }
  public static function Stoj(value : /*short*/int) : ulong {
    if (value < 0) throw new RangeError();
    return s2ul(value);
  }
  public static function StoF(value : /*short*/int) : float  { return s2f(value); }
  public static function StoD(value : /*short*/int) : double { return s2d(value); }

  public function toZ() : bool   { return StoZ(unbox()); }
  public function toB() : int    { return StoB(unbox()); }
  public function tob() : byte   { return Stob(unbox()); }
  public function toS() : int    { return StoS(unbox()); }
  public function tos() : int    { return Stos(unbox()); }
  public function toI() : int    { return StoI(unbox()); }
  public function toi() : uint   { return Stoi(unbox()); }
  public function toJ() : long   { return StoJ(unbox()); }
  public function toj() : ulong  { return Stoj(unbox()); }
  public function toF() : float  { return StoF(unbox()); }
  public function toD() : double { return StoD(unbox()); }
}

A.5 ushort

AS4 has no unsigned short type, so int is used instead.

public final class ushort {
  private let _value : /*ushort*/int;
  private function short(value : /*ushort*/int) { _value = value; }
  private function unbox() : /*ushort*/int { return _value; }

  private static native function us2b(value : /*ushort*/int) : /*sbyte*/int {
    // i2us bytecode instruction
  }
  private static native function us2ub(value : /*ushort*/int) : byte {
    // i2us bytecode instruction
  }
  private static native function us2s(value : /*ushort*/int) : /*short*/int {
    // i2us bytecode instruction
  }
  private static native function us2us(value : /*ushort*/int) : byte {
    // i2us bytecode instruction
  }
  private static native function us2i(value : /*ushort*/int) : int {
    // i2us bytecode instruction
  }
  private static native function us2u(value : /*ushort*/int) : uint {
    // i2us, i2u bytecode instructions
  }
  private static native function us2l(value : /*ushort*/int) : long {
    // i2us, i2l bytecode instructions
  }
  private static native function us2ul(value : /*ushort*/int) : ulong {
    // i2us, i2l, l2ul bytecode instructions
  }
  private static native function us2f(value : /*ushort*/int) : float {
    // i2us, i2f bytecode instructions
  }
  private static native function us2d(value : /*ushort*/int) : double {
    // i2us, i2d bytecode instructions
  }

  public static function stoZ(value : /*ushort*/int) : bool {
    throw new TypeError();
    return false;
  }
  public static function stoB(value : /*ushort*/int) : /*sbyte*/int {
    if (value > 127) throw new RangeError();
    return us2b(value);
  }
  public static function stob(value : /*ushort*/int) : byte {
    if (value > 255) throw new RangeError();
    return us2ub(value);
  }
  public static function stoS(value : /*ushort*/int) : /*short*/int {
    if (value > 32767) throw new RangeError();
    return us2s(value);
  }
  public static function stos(value : /*ushort*/int) : /*ushort*/int
                                                              { return us2us(value); }
  public static function stoI(value : /*ushort*/int) : int    { return us2i(value);  }
  public static function stoi(value : /*ushort*/int) : uint   { return us2u(value);  }
  public static function stoJ(value : /*ushort*/int) : long   { return us2l(value);  }
  public static function stoj(value : /*ushort*/int) : ulong  { return us2ul(value); }
  public static function stoF(value : /*ushort*/int) : float  { return us2f(value);  }
  public static function stoD(value : /*ushort*/int) : double { return us2d(value);  }

  public function toZ() : bool   { return stoZ(unbox()); }
  public function toB() : int    { return stoB(unbox()); }
  public function tob() : byte   { return stob(unbox()); }
  public function toS() : int    { return stoS(unbox()); }
  public function tos() : int    { return stos(unbox()); }
  public function toI() : int    { return stoI(unbox()); }
  public function toi() : uint   { return stoi(unbox()); }
  public function toJ() : long   { return stoJ(unbox()); }
  public function toj() : ulong  { return stoj(unbox()); }
  public function toF() : float  { return stoF(unbox()); }
  public function toD() : double { return stoD(unbox()); }
}

A.6 int

public final class int {
  private let _value : int;
  private function int(value : int) { _value = value; }
  private function unbox() : int { return _value; }

  private static native function i2sb(value : int) : /*sbyte*/int {
    // nop bytecode instruction
  }
  private static native function i2ub(value : int) : byte {
    // nop bytecode instruction
  }
  private static native function i2s(value : int) : /*short*/int {
    // nop bytecode instruction
  }
  private static native function i2us(value : int) : /*ushort*/int {
    // nop bytecode instruction
  }
  private static native function i2u(value : int) : uint {
    // nop bytecode instruction
  }
  private static native function i2l(value : int) : long {
    // i2l bytecode instruction
  }
  private static native function i2ul(value : int) : ulong {
    // i2l, l2ul bytecode instructions
  }
  private static native function i2f(value : int) : float {
    // i2f bytecode instruction
  }
  private static native function i2d(value : int) : double {
    // i2d bytecode instruction
  }

  public static function ItoZ(value : int) : bool {
    throw new TypeError();
    return false;
  }
  public static function ItoB(value : int) : /*sbyte*/int {
    if (value < -128 || value > 127) throw new RangeError();
    return i2sb(value);
  }
  public static function Itob(value : int) : byte {
    if (value < 0 || value > 255) throw new RangeError();
    return i2ub(value);
  }
  public static function ItoS(value : int) : /*short*/int {
    if (value < -32768 || value > 32767) throw new RangeError();
    return i2s(value);
  }
  public static function Itos(value : int) : /*ushort*/int {
    if (value < 0 || value > 65535) throw new RangeError();
    return i2us(value);
  }
  public static function ItoI(value : int) : int    { return value;      }
  public static function Itoi(value : int) : uint {
    if (value < 0) throw new RangeError();
    return i2u(value);
  }
  public static function ItoJ(value : int) : long   { return i2l(value); }
  public static function Itoj(value : int) : ulong {
    if (value < 0) throw new RangeError();
    return i2ul(value);
  }
  public static function ItoF(value : int) : float {
    if (value < -2**24 + 1 || value > 2**24 - 1) throw new RangeError();
    return i2f(value);
  }
  public static function ItoD(value : int) : double { return i2d(value); }

  public function toZ() : bool   { return ItoZ(unbox()); }
  public function toB() : int    { return ItoB(unbox()); }
  public function tob() : byte   { return Itob(unbox()); }
  public function toS() : int    { return ItoS(unbox()); }
  public function tos() : int    { return Itos(unbox()); }
  public function toI() : int    { return unbox();       }
  public function toi() : uint   { return Itoi(unbox()); }
  public function toJ() : long   { return ItoJ(unbox()); }
  public function toj() : ulong  { return Itoj(unbox()); }
  public function toF() : float  { return ItoF(unbox()); }
  public function toD() : double { return ItoD(unbox()); }
}

A.7 uint

public final class uint {
  private let _value : uint;
  private function uint(value : uint) { _value = value; }
  private function unbox() : uint { return _value; }

  private static native function u2b(value : uint) : /*sbyte*/int {
    // nop bytecode instruction
  }
  private static native function u2ub(value : uint) : byte {
    // nop bytecode instruction
  }
  private static native function u2s(value : uint) : /*short*/int {
    // nop bytecode instruction
  }
  private static native function u2us(value : uint) : /*ushort*/int {
    // nop bytecode instruction
  }
  private static native function u2i(value : uint) : int {
    // nop bytecode instruction
  }
  private static native function u2l(value : uint) : long {
    // u2l bytecode instruction
  }
  private static native function u2ul(value : uint) : ulong {
    // u2l, l2ul bytecode instructions
  }
  private static native function u2f(value : uint) : float {
    // u2l, l2f bytecode instructions
  }
  private static native function u2d(value : uint) : double {
    // u2l, l2d bytecode instructions
  }

  public static function itoZ(value : uint) : bool {
    throw new TypeError();
    return false;
  }
  public static function itoB(value : uint) : /*sbyte*/int {
    if (value > 127) throw new RangeError();
    return u2b(value);
  }
  public static function itob(value : uint) : byte {
    if (value > 255) throw new RangeError();
    return u2ub(value);
  }
  public static function itoS(value : uint) : /*short*/int {
    if (value > 32767) throw new RangeError();
    return u2s(value);
  }
  public static function itos(value : uint) : /*ushort*/int {
    if (value > 65535) throw new RangeError();
    return u2us(value);
  }
  public static function itoI(value : uint) : int {
    if (value > 2**31 - 1) throw new RangeError();
    return u2i(value);
  }
  public static function itoi(value : uint) : uint   { return value;       }
  public static function itoJ(value : uint) : long   { return u2l(value);  }
  public static function itoj(value : uint) : ulong  { return u2ul(value); }
  public static function itoF(value : uint) : float {
    if (value > 2**24 - 1) throw new RangeError();
    return u2f(value);
  }
  public static function itoD(value : uint) : double { return u2d(value);  }

  public function toZ() : bool   { return itoZ(unbox()); }
  public function toB() : int    { return itoB(unbox()); }
  public function tob() : byte   { return itob(unbox()); }
  public function toS() : int    { return itoS(unbox()); }
  public function tos() : int    { return itos(unbox()); }
  public function toI() : int    { return itoI(unbox()); }
  public function toi() : int    { return unbox();       }
  public function toJ() : long   { return itoJ(unbox()); }
  public function toj() : ulong  { return itoj(unbox()); }
  public function toF() : float  { return itoF(unbox()); }
  public function toD() : double { return itoD(unbox()); }
}

A.8 long

public final class long {
  private let _value : long;
  private function long(value : long) { _value = value; }
  private function unbox() : long { return _value; }

  private static native function l2b(value : long) : /*sbyte*/int {
    // nop bytecode instruction
  }
  private static native function l2ub(value : long) : byte {
    // nop bytecode instruction
  }
  private static native function l2s(value : long) : /*short*/int {
    // nop bytecode instruction
  }
  private static native function l2us(value : long) : /*ushort*/int {
    // nop bytecode instruction
  }
  private static native function l2i(value : long) : int {
    // nop bytecode instruction
  }
  private static native function l2u(value : long) : uint {
    // nop bytecode instruction
  }
  private static native function l2ul(value : long) : ulong {
    // nop bytecode instruction
  }
  private static native function l2f(value : long) : float {
    // l2f bytecode instruction
  }
  private static native function l2d(value : long) : double {
    // l2d bytecode instruction
  }

  public static function JtoZ(value : long) : bool {
    throw new TypeError();
    return false;
  }
  public static function JtoB(value : long) : /*sbyte*/int {
    if (value < -128 || value > 127) throw new RangeError();
    return l2b(value);
  }
  public static function Jtob(value : long) : byte {
    if (value < 0 || value > 255) throw new RangeError();
    return l2ub(value);
  }
  public static function JtoS(value : long) : /*short*/int {
    if (value < -32768 || value > 32767) throw new RangeError();
    return l2s(value);
  }
  public static function Jtos(value : long) : /*ushort*/int {
    if (value < 0 || value > 65535) throw new RangeError();
    return l2us(value);
  }
  public static function JtoI(value : long) : int    {
    if (value < -2**31 || value > 2**31 - 1) throw new RangeError();
    return l2i(value);
  }
  public static function Jtoi(value : long) : uint {
    if (value < 0 || value > 2**32 - 1) throw new RangeError();
    return l2u(value);
  }
  public static function JtoJ(value : long) : long { return value; }
  public static function Jtoj(value : long) : ulong {
    if (value < 0) throw new RangeError();
    return l2ul(value);
  }
  public static function JtoF(value : long) : float {
    if (value < -2**24 + 1 || value > 2**24 - 1) throw new RangeError();
    return l2f(value);
  }
  public static function JtoD(value : long) : double {
    if (value < -2**53 + 1 || value > 2**53 - 1) throw new RangeError();
    return l2d(value);
  }

  public function toZ() : bool   { return JtoZ(unbox()); }
  public function toB() : int    { return JtoB(unbox()); }
  public function tob() : byte   { return Jtob(unbox()); }
  public function toS() : int    { return JtoS(unbox()); }
  public function tos() : int    { return Jtos(unbox()); }
  public function toI() : int    { return JtoI(unbox()); }
  public function toi() : uint   { return Jtoi(unbox()); }
  public function toJ() : long   { return unbox();       }
  public function toj() : ulong  { return Jtoj(unbox()); }
  public function toF() : float  { return JtoF(unbox()); }
  public function toD() : double { return JtoD(unbox()); }
}

A.9 ulong

public final class ulong {
  private let _value : ulong;
  private function uint(value : ulong) { _value = value; }
  private function unbox() : ulong { return _value; }

  private static native function ul2b(value : ulong) : /*sbyte*/int {
    // ul2l, l2i, i2sb bytecode instructions
  }
  private static native function ul2ub(value : ulong) : byte {
    // ul2l, l2i, i2ub bytecode instructions
  }
  private static native function ul2s(value : ulong) : /*short*/int {
    // ul2l, l2i, i2s bytecode instructions
  }
  private static native function ul2us(value : ulong) : /*ushort*/int {
    // ul2l, l2i, i2us bytecode instructions
  }
  private static native function ul2i(value : ulong) : int {
    // ul2l, l2i bytecode instructions
  }
  private static native function ul2u(value : ulong) : uint {
    // ul2l, l2i, l2u bytecode instructions
  }
  private static native function ul2l(value : ulong) : long {
    // ul2l bytecode instruction
  }
  private static native function ul2f(value : ulong) : float {
    // ul2l, l2f bytecode instructions
  }
  private static native function ul2d(value : ulong) : double {
    // ul2l, l2d bytecode instructions
  }

  public static function jtoZ(value : ulong) : bool {
    throw new TypeError();
    return false;
  }
  public static function jtoB(value : ulong) : /*sbyte*/int {
    if (value > 127) throw new RangeError();
    return ul2b(value);
  }
  public static function jtob(value : ulong) : byte {
    if (value > 255) throw new RangeError();
    return ul2ub(value);
  }
  public static function jtoS(value : ulong) : /*short*/int {
    if (value > 32767) throw new RangeError();
    return ul2s(value);
  }
  public static function jtos(value : ulong) : /*ushort*/int {
    if (value > 65535) throw new RangeError();
    return ul2us(value);
  }
  public static function jtoI(value : ulong) : int {
    if (value > 2**31 - 1) throw new RangeError();
    return ul2i(value);
  }
  public static function jtoi(value : ulong) : uint {
    if (value > 2**32 - 1) throw new RangeError();
    return ul2u(value);
  }
  public static function jtoJ(value : ulong) : long {
    if (value > 2**63 -1 ) throw new RangeError();
    return ul2l(value);
  }
  public static function jtoj(value : ulong) : ulong { return value; }
  public static function jtoF(value : ulong) : float {
    if (value > 2**24 - 1) throw new RangeError();
    return ul2f(value);
  }
  public static function itoD(value : uint) : double {
    if (value > 2**53 - 1) throw new RangeError();
    return ul2d(value);
  }

  public function toZ() : bool   { return jtoZ(unbox()); }
  public function toB() : int    { return jtoB(unbox()); }
  public function tob() : byte   { return jtob(unbox()); }
  public function toS() : int    { return jtoS(unbox()); }
  public function tos() : int    { return jtos(unbox()); }
  public function toI() : int    { return jtoI(unbox()); }
  public function toi() : int    { return jtoi(unbox()); }
  public function toJ() : long   { return jtoJ(unbox()); }
  public function toj() : ulong  { return unbox();       }
  public function toF() : float  { return jtoF(unbox()); }
  public function toD() : double { return jtoD(unbox()); }
}

A.10 float

public final class float {
  private let _value : float;
  private function uint(value : float) { _value = value; }
  private function unbox() : float { return _value; }

  private static native function f2b(value : float) : /*sbyte*/int {
    // f2i, i2sb bytecode instructions
  }
  private static native function f2ub(value : float) : byte {
    // f2i, i2ub bytecode instructions
  }
  private static native function f2s(value : float) : /*short*/int {
    // f2i, i2s bytecode instructions
  }
  private static native function f2us(value : float) : /*ushort*/int {
    // f2i, i2us bytecode instructions
  }
  private static native function f2i(value : float) : int {
    // f2i bytecode instruction
  }
  private static native function f2u(value : float) : uint {
    // f2i, i2u bytecode instructions
  }
  private static native function f2l(value : float) : long {
    // f2l bytecode instruction
  }
  private static native function f2ul(value : float) : ulong {
    // f2ul bytecode instruction
  }
  private static native function f2d(value : float) : double {
    // f2d bytecode instruction
  }

  public static function FtoZ(value : float) : bool {
    throw new TypeError();
    return false;
  }
  public static function FtoB(value : float) : /*sbyte*/int {
    if (value < -128 || floor(value) > 127) throw new RangeError();
    return f2b(value);
  }
  public static function Ftob(value : float) : byte {
    if (value < 0 || floor(value) > 255) throw new RangeError();
    return f2ub(value);
  }
  public static function FtoS(value : float) : /*short*/int {
    if (value < -32768 || floor(value) > 32767) throw new RangeError();
    return f2s(value);
  }
  public static function Ftos(value : float) : /*ushort*/int {
    if (value < 0 || floor(value) > 65535) throw new RangeError();
    return f2us(value);
  }
  public static function FtoI(value : float) : int {
    if (value < -2**31 || floor(value) > 2**31 - 1) throw new RangeError();
    return f2i(value);
  }
  public static function Ftoi(value : float) : uint  {
    if (value < 0 || floor(value) > 2**32 - 1) throw new RangeError();
    return f2u(value);
  }
  public static function FtoJ(value : float) : long {
    if (value < -2**63 || floor(value) > 2**63 - 1) throw new RangeError();
    return f2l(value);
  }
  public static function Ftoj(value : float) : ulong {
    if (value < 0 || floor(value) > 2**64 - 1) throw new RangeError();
    return f2ul(value);
  }
  public static function FtoF(value : float) : float  { return value;      }
  public static function FtoD(value : float) : double { return f2d(value); }

  public function toZ() : bool   { return FtoZ(unbox()); }
  public function toB() : int    { return FtoB(unbox()); }
  public function tob() : byte   { return Ftob(unbox()); }
  public function toS() : int    { return FtoS(unbox()); }
  public function tos() : int    { return Ftos(unbox()); }
  public function toI() : int    { return FtoI(unbox()); }
  public function toi() : int    { return Ftoi(unbox()); }
  public function toJ() : long   { return FtoJ(unbox()); }
  public function toj() : ulong  { return Ftoj(unbox()); }
  public function toF() : float  { return unbox();       }
  public function toD() : double { return FtoD(unbox()); }
}

A.11 double

public final class double {
  private let _value : double;
  private function uint(value : double) { _value = value; }
  private function unbox() : double { return _value; }

  private static native function d2b(value : double) : /*sbyte*/int {
    // d2i, i2sb bytecode instructions
  }
  private static native function d2ub(value : double) : byte {
    // d2i, i2ub bytecode instructions
  }
  private static native function d2s(value : double) : /*short*/int {
    // d2i, i2s bytecode instructions
  }
  private static native function d2us(value : double) : /*ushort*/int {
    // d2i, i2us bytecode instructions
  }
  private static native function d2i(value : double) : int {
    // d2i bytecode instruction
  }
  private static native function d2u(value : double) : uint {
    // d2i, i2u bytecode instructions
  }
  private static native function d2l(value : double) : long {
    // d2l bytecode instruction
  }
  private static native function d2ul(value : double) : ulong {
    // d2ul bytecode instruction
  }
  private static native function d2f(value : double) : float {
    // d2f bytecode instruction
  }

  public static function DtoZ(value : double) : bool {
    throw new TypeError();
    return false;
  }
  public static function DtoB(value : double) : /*sbyte*/int {
    if (value < -128 || floor(value) > 127) throw new RangeError();
    return d2b(value);
  }
  public static function Dtob(value : double) : byte {
    if (value < 0 || floor(value) > 255) throw new RangeError();
    return d2ub(value);
  }
  public static function DtoS(value : double) : /*short*/int {
    if (value < -32768 || floor(value) > 32767) throw new RangeError();
    return d2s(value);
  }
  public static function Dtos(value : double) : /*ushort*/int {
    if (value < 0 || floor(value) > 65535) throw new RangeError();
    return d2us(value);
  }
  public static function DtoI(value : double) : int {
    if (value < -2**31 || floor(value) > 2**31 - 1) throw new RangeError();
    return d2i(value);
  }
  public static function Dtoi(value : double) : uint  {
    if (value < 0 || floor(value) > 2**32 - 1) throw new RangeError();
    return d2u(value);
  }
  public static function DtoJ(value : double) : long {
    if (value < -2**63 || floor(value) > 2**63 - 1) throw new RangeError();
    return d2l(value);
  }
  public static function Dtoj(value : double) : ulong {
    if (value < 0 || floor(value) > 2**64 - 1) throw new RangeError();
    return d2ul(value);
  }
  public static function DtoF(value : double) : float  { return d2f(value); }
  public static function DtoD(value : double) : double { return value;      }

  public function toZ() : bool   { return DtoZ(unbox()); }
  public function toB() : int    { return DtoB(unbox()); }
  public function tob() : byte   { return Dtob(unbox()); }
  public function toS() : int    { return DtoS(unbox()); }
  public function tos() : int    { return Dtos(unbox()); }
  public function toI() : int    { return DtoI(unbox()); }
  public function toi() : int    { return Dtoi(unbox()); }
  public function toJ() : long   { return DtoJ(unbox()); }
  public function toj() : ulong  { return Dtoj(unbox()); }
  public function toF() : float  { return DtoF(unbox()); }
  public function toD() : double { return unbox();       }
}
