e% Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.

% Licensed under the Apache License, Version 2.0 (the "License");
% you may not use this file except in compliance with the License.
% You may obtain a copy of the License at

% http://www.apache.org/licenses/LICENSE-2.0

% Unless required by applicable law or agreed to in writing, software
% distributed under the License is distributed on an "AS IS" BASIS,
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
% See the License for the specific language governing permissions and
% limitations under the License.

\makeatletter{}\documentclass[10pt,oneside]{book}
\usepackage[T1]{fontenc}
\usepackage{microtype}
\DisableLigatures{encoding = *, family = * }
\usepackage{upquote}
\usepackage[usenames,dvipsnames]{color}
\usepackage{fullpage}
\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{amsthm}
\usepackage{../third-party/mathpartir/mathpartir}
\usepackage[usenames,dvipsnames]{color}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\DeclareFixedFont{\slantsf}{T1}{cmss}{m}{sl}{10}
\DeclareFixedFont{\slantsffootnote}{T1}{cmss}{m}{sl}{8}
\DeclareFixedFont{\slantsfsmall}{T1}{cmss}{m}{sl}{9}

\definecolor{WikiBlue}{rgb}{0.2,0.2,.5}

\renewcommand{\labelenumiv}{\Roman{enumiv}.}


\usepackage[linkbordercolor={1 1 1},colorlinks=true,linkcolor=WikiBlue]{hyperref}

\usepackage{listings}
\lstset{language=Java,numbers=left,numberstyle=\tiny,numbersep=5pt,basicstyle=\small\ttfamily,commentstyle=\rmfamily,columns=flexible,frame=none,texcl=true,mathescape=true,lineskip=1pt,escapeinside={/**}{*/},showstringspaces=false,otherkeywords={assert}
}

\setcounter{secnumdepth}{3}

\setlength{\marginparwidth}{1.2in}
\reversemarginpar
\let\oldmarginpar\marginpar
\renewcommand\marginpar[1]{\-\oldmarginpar[\raggedleft\footnotesize #1]%
{\raggedright\footnotesize #1}}

% \makeatletter
% \renewcommand{\l@section}{\@dottedtocline{1}{1.5em}{2.8em}}
% \renewcommand{\l@subsection}{\@dottedtocline{2}{4.3em}{3.6em}}
% \renewcommand{\l@subsubsection}{\@dottedtocline{3}{7.9em}{4.5em}}
% \makeatother

\newcounter{parnum}[section]
\newcommand{\N}{\addtocounter{parnum}{1}\marginpar{\quad\arabic{chapter}.\arabic{section}(\arabic{parnum})}}

\newcounter{prod}
\newcounter{notemark}
\newcounter{tmp}
\newcounter{base}

\newcommand{\tag}[1]{${}_{~\!\!\mathtt{#1}}$}
\newcommand{\note}[1]{{\scriptsize #1}}
\newcommand{\condition}[1]{\note{$\langle$#1$\rangle$}}
\newcommand{\grammarprod}{\addtocounter{prod}{1}\\{\tiny
    \arabic{prod}} \>}
\newcommand{\grammarproD}{\addtocounter{prod}{1}{\tiny
    \arabic{prod}} $~~~~$ \=}
%\newcommand{\grammardef}{}
%\newcommand{\punctuator}[1]{$\mathtt{#1}$}
%\newcommand{\punctuator}[1]{\verb`#1`}
%\newcommand{\nonterminal}[1]{{\it #1}}
\newcommand{\nonterminal}[1]{{\slantsf #1}}
\newcommand{\lexicalnonterminal}[1]{{\sf #1}}
\newcommand{\terminal}[1]{{\tt #1}}
%\renewcommand{\not}{$\neg$}
%\renewcommand{\lor}{$|~$}
%\newcommand{\noxmlwhitespace}{\condition{no
%    \lexicalnonterminal{XMLWhitespace}}}
\newcommand{\nolineterminator}{\condition{\underline{noLineTerminator}}}
\newcommand{\lookaheadnotbegin}{\note{$\langle$lookahead not }}
\newcommand{\lookaheadnotend}{\note{$\rangle$}}
\newcommand{\butnotbegin}{\note{$\langle$\underline{but not} }}
\newcommand{\butnotend}{\note{$\rangle$}}
\newcommand{\butnoembeddedbegin}{\note{$\langle$but no embedded }}
\newcommand{\butnoembeddedend}{\note{$\rangle$}}

\newcommand{\tagbegin}[1]{\note{$\langle$\underline{#1} }}
\newcommand{\tagend}{\note{$\rangle$}}
\newcommand{\ortag}{\underline{or}}

\newtheoremstyle{note}% name of the style to be used
  {5pt}% measure of space to leave above the theorem. E.g.: 3pt
  {5pt}% measure of space to leave below the theorem. E.g.: 3pt
  {}% name of font to use in the body of the theorem
  {}% measure of space to indent
  {\bf}% name of head font
  {.}% punctuation between head and body
  { }% space after theorem head; " " = normal interword space
  {}% Manually specify head

\theoremstyle{note}
\newtheorem{definition}{Definition}[section]

%\renewcommand{\labelitemi}{}

\newenvironment{notes}
{\footnotesize\color{Red}\underline{\arabic{notemark}}}
{\normalsize\vspace*{5pt}}

\newcommand{\marknote}{\setcounter{base}{\value{prod}}\addtocounter{notemark}{1}$\:{}^{\color{Red}\underline{\arabic{notemark}}}$}

\newcommand{\prodnum}[1]
{\setcounter{tmp}{\value{base}}\addtocounter{base}{#1}{\tiny\arabic{base}:}\setcounter{base}{\value{tmp}}}

%MACROS FOR COMMENTS
\newcommand{\avik}[1]{\textcolor{RoyalBlue}{{\bf Avik:} #1}}
\newcommand{\jeff}[1]{\textcolor{RoyalBlue}{{\bf Jeff:} #1}}
\newcommand{\lars}[1]{\textcolor{RoyalBlue}{{\bf Lars:} #1}}
\newcommand{\basil}[1]{\textcolor{RoyalBlue}{{\bf Basil:} #1}}

%Useful markup
\newcommand{\informative}[1]{{\bf Informative note:} #1}
\newcommand{\example}[1]{{\bf Example:} #1}
\newcommand{\rationale}[1]{{\bf Rationale:} #1}
\newcommand{\todo}[1]{\textcolor{Red}{{\bf TODO:} #1}}
\newcommand{\implnote}[1]{{\bf Implementation note:} #1}
\newcommand{\method}[1]{{\tt #1}}
\newcommand{\operator}[1]{{\tt #1}}
\newcommand{\instruction}[1]{{\tt #1}}
\newcommand{\expression}[1]{{\tt #1}}
\newcommand{\subr}[1]{{\bf #1}}
\newcommand{\argument}[1]{{\em #1}}
\newcommand{\typename}[1]{{\bf #1}}
\newcommand{\asvalue}[1]{{\bf #1}}


% NAME RESOLUTION

\newcommand{\packagepublic}[1]{\mathbf{Public}_{#1}}
\newcommand{\packageinternal}[1]{\mathbf{Internal}_{#1}}
\newcommand{\fileinternal}[1]{\mathbf{Program}}
\newcommand{\classprivate}[1]{\mathbf{Private}_{#1}}
\newcommand{\classprotected}[1]{\mathbf{Protected}_{\it #1}}
\newcommand{\classprotectedstatic}[1]{\mathbf{StaticProtected}_{\it #1}}

\newcommand{\pkg}{{\sf pkg}}
\newcommand{\nsval}{{\sf nsval}}
\newcommand{\xname}{{\sf xname}}
\newcommand{\qname}{{\sf qname}}
\newcommand{\id}{{\sf id}}
\newcommand{\xquals}{{\sf XQuals}}
\newcommand{\key}{{\sf key}}
\newcommand{\str}{{\sf id}}
\newcommand{\lexenv}{{\sf LexEnv}}
\newcommand{\slot}{{\sf slot}}
\newcommand{\mname}{{\sf mname}}
\newcommand{\open}{{\sf Open}}
\newcommand{\rname}{{\sf rname}}

\newcommand{\func}[1]{\emph{#1}}


% CONSTANT EVALUATION

\newcommand{\val}{{\sf val}}
\newcommand{\op}{{\sf op}}

\newcommand{\name}{{\sf name}}
\newcommand{\obj}{{\sf obj}}
\newcommand{\rval}{{\sf ref}}
\newcommand{\super}{{\sf super}}
\newcommand{\new}{{\sf new}}
\newcommand{\expr}{{\sf expr}}
\newcommand{\dynenv}{{\sf DynEnv}}
\newcommand{\ty}{{\sf ty}}
\newcommand{\sig}{{\sf sig}}
\newcommand{\body}{{\sf body}}
\newcommand{\envrec}{{\sf EnvRec}}
\newcommand{\envtbl}{{\sf EnvTbl}}

\newcommand{\constenv}{\mathsf{ConstEnv}}

\newcommand{\openavik}{\avik{}\color{RoyalBlue}}
\newcommand{\closeavik}{\color{black}}

\newcommand{\openjeff}{\jeff{}\color{RoyalBlue}}
\newcommand{\closejeff}{\color{black}}

% STATIC VERIFICATION

\newcommand{\delete}{{\sf delete}}
\newcommand{\typeof}{{\sf typeof}}
\newcommand{\void}{{\sf void}}

% EXPRESSIONS

\newcommand{\excon}{{\sf ExCon}}
\newcommand{\num}{{\sf num}}
\newcommand{\lhsexpr}{{\sf lhsexpr}}
\newcommand{\field}{{\sf field}}
\newcommand{\info}{{\sf info}}




\title{ActionScript\textsuperscript{\textregistered} 4.0 Language
  Specification}
\author{Avik Chaudhuri, Bernd Mathiske, Krzysztof
  Palacz, and Basil Hosmer \\
\\
{\it Adobe Systems} \\
{\tt AS4@adobe.com}}
%\date{}                                           % Activate to display a given date or no date

\begin{document}


\maketitle

\pagebreak

\copyright{} 2014 Adobe Systems Incorporated. All rights reserved. %[update year of publication]

{\bf ActionScript\textsuperscript{\textregistered} 4.0 Language Specification}

This user guide is protected under copyright law, furnished for informational use only, is subject
to change without notice, and should not be construed as a commitment by Adobe Systems Incorporated.
Adobe Systems Incorporated assumes no responsibility or liability for any errors or inaccuracies
that may appear in the informational content contained in this guide.

This guide contains links to third-party websites that are not under the control of Adobe Systems
Incorporated, and Adobe Systems Incorporated is not responsible for the content on any linked site.
If you access a third-party website mentioned in this guide, then you do so at your own risk. Adobe
Systems Incorporated provides these links only as a convenience, and the inclusion of the link does
not imply that Adobe Systems Incorporated endorses or accepts any responsibility for the content on
those third-party sites. No right, license, or interest is granted in any third party technology
referenced in this guide.

This user guide is licensed for use under the terms of the Creative Commons Attribution
Non-Commercial 3.0 License. This License allows users to copy, distribute, and transmit the user
guide for noncommercial purposes only so long as (1) proper attribution to Adobe is given as the
owner of the user guide; and (2) any reuse or distribution of the user guide contains a notice that
use of the user guide is governed by these terms. The best way to provide notice is to include the
following link. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/.

Adobe and ActionScript are either registered trademarks or trademarks of
Adobe Systems Incorporated in the United States and/or other countries. All other trademarks are the
property of their respective owners.  No right or license is granted to any Adobe trademark.
%Updated Information/Additional Third Party Code Information
%available at http://www.adobe.com/go/thirdparty.


Adobe Systems Incorporated, 345 Park Avenue, San Jose, California 95110, USA.

\emph{Notice to U.S. Government End Users:} The Software and Documentation are ``Commercial Items,'' as
that term is defined at 48 C.F.R. \S2.101, consisting of ``Commercial Computer Software'' and
``Commercial Computer Software Documentation,'' as such terms are used in 48 C.F.R. \S12.212
or 48 C.F.R. \S227.7202, as applicable. Consistent with 48 C.F.R. \S12.212 or 48 C.F.R.
\S\S227.7202-1 through 227.7202-4, as applicable, the Commercial Computer Software and
Commercial Computer Software Documentation are being licensed to U.S. Government end users (a) only
as Commercial Items and (b) with only those rights as are granted to all other end users pursuant
to the terms and conditions herein. Unpublished-rights reserved under the copyright laws of the
United States. Adobe agrees to comply with all applicable equal opportunity laws including, if
appropriate, the provisions of Executive Order 11246, as amended, Section 402 of the Vietnam Era
Veterans Readjustment Assistance Act of 1974 (38 USC 4212), and Section 503 of the Rehabilitation
Act of 1973, as amended, and the regulations at 41 CFR Parts 60-1 through 60-60, 60-250, and 60-741.
The affirmative action clause and regulations contained in the preceding sentence shall be
incorporated by reference.


\pagebreak

\section*{Change Log}

\begin{description}

\item[Oct 30 2012] Draft released to CAB.

\item[Nov 1 2012] Fixed bug around syntactic ordering of access controls and
  attributes on function definitions and class definitions: cf.
  occurrences of the new nonterminal \nonterminal{Modifier} in the grammar (Chapter
  3) and in the pruning rules (Chapter 4).

\item[Nov 30 2012] Fixed coercion semantics of \verb'as' to perform
  some ``bitcast'' numeric conversions instead of throwing range
  errors: cf. occurrences of ``coercion operator'' in
  type inference (Chapter 7) and the rules for $T'::op(e~{\tt
    coerce}~T)$ (Chapter 8).

\item[Dec 5 2012] Added syntactic support for variable-length unicode
  escape sequences: cf. occurrences of the new nonterminal \lexicalnonterminal{VariableLengthUnicodeEscapeSequence} in the grammar (see Chapter 3).

\item[Dec 5 2012] Extended the syntax of type expressions to include
  array and function types: cf. the nonterminal
  \nonterminal{TypeExpression} in the grammar (Chapter 3).

\item[Dec 5 2012] Fixed bugs in the canonicalization of compound
  assignments and
  prefix/postfix operations: cf. rules for deriving canonical forms (Chapter 5).

\item[Dec 5 2012] Removed the \verb'for-in' construct: cf. the
  nonterminal \nonterminal{ForStatement} in the grammar (Chapter 3)
  and the rules for deriving canonical forms (Chapter 5).

\item[Dec 12 2012] Added singleton types for numeric literals, which
  are now used to type numeric literals; added a notion of numeric
  literals fitting in types to describe the earlier typing scheme
  for numeric literals, and used it to
  extend the notion of promotion and the definition of union; tweaked the rules for typing
  arithmetic operations to perform expected promotions of numeric
  literals (Chapter 7).

\item[Dec 13 2012] Fixed typing rules for shifting, which earlier took
  into account the type of the shift amount in determining the type of the
  result of a shift, instead of simply preserving the type of the value to be
  shifted: the type of the shift amount is now {\tt int} (Chapter 7).

\item[Dec 13 2012] Removed canonicalization rules for conditional
  expressions: constant evaluation
  was not possible earlier due to canonicalization (Chapter 5); fixed
  typing rules for conditional expressions (Chapter 7).

\end{description}

\pagebreak

\tableofcontents

\part{Overview}

% \chapter{Introduction}

% \newcommand{\code}[1]{{\tt #1}}
% %\input{../AS4wp/intro.tex}
% \input{../AS4wp/dropped.tex}
% \input{../AS4wp/changes.tex}
% \input{../AS4wp/new.tex}
% \input{../AS4wp/same.tex}
% \input{../AS4wp/outlook.tex}

\chapter{Syntax and Semantics}

This chapter provides an overview of the syntax and semantics of
ActionScript 4.0 (AS4).

\section{Syntactic Model}

\N
The syntax of the language defines the interpretation of a sequence of
characters (the text of a program) as a syntax tree that represents a
syntactically valid program
in the language. This interpretation involves the following steps:
\begin{enumerate}

\item The processes of \emph{scanning} (Section \ref{sec:lexgrammar}) and
  \emph{parsing} (Section \ref{sec:syngrammar}) translate a sequence of characters
  (the text of a program) to an intermediate syntax tree.

\item The processes of \emph{unit configuration} (Section
  \ref{sec:fileconfig}) and \emph{enforcement of syntactic
    restrictions} (Section \ref{sec:syntax-restrictions}) eliminate
  parts of the syntax tree, and discards the pruned intermediate syntax
  tree unless it satisfies various conditions of syntactic validity.
\end{enumerate}

\N A syntactically valid program consists of several units which
contain type definitions.

\N
An IDE for the language may enforce further restrictions on
the syntax tree of a valid program in the language, the details of
which are not considered further in the specification.

\N
To simplify the presentation of semantics in the remainder of this specification, we assume
that some
forms of syntax trees are encoded away in terms of other canonical
forms (Section \ref{sec:implicit}). An implementation does not need to
perform such encodings; the semantic rules for non-canonical forms
can be derived through those for their corresponding encodings.


\section{Compilation Model}

\N
An \emph{executable} represents some type definitions
and the name of a distinguished
static method of some class among those classes, that serves as the
\emph{entry point}. It is assumed that the code in
an executable has undergone (at least) the processes of
resolution (Chapter \ref{chap:resolution}) and inference (Chapter \ref{chap:inference}).

\N
A \emph{library} is an executable whose entry point is ignored.

\N
A program is \emph{compiled} to an executable, against a set of libraries.

\N
There exists a pre-compiled library, known as the \emph{standard
  library}, that contains definitions of built-in classes
and interfaces, and a trivial entry point. The built-in classes include at least the classes
corresponding to
value types \verb'int', \verb'uint', \verb'long', \verb'ulong',
  \verb'double', \verb'float', \verb'byte', \verb'bool',
  the type \verb'String' that has a method
  \verb'concat(string:String)', the types of reified type objects
  \verb'Class' and \verb'Interface' that can at least reflect on the
  type definitions and the definitions of their members (and in particular, reflect on
  metadata associated with such type definitions and the definitions
  of their members),
the generic types \verb'Array<'$T$\verb'>' (which is a desugaring of \verb'[] '$T$) and
\verb'ArrayList<'$T$\verb'>'  for every type $T$, the type of
regular expressions with syntactic support \verb'RegExp' that has a constructor
\verb'RegExp(pattern:String,flags:String)', and the type of all
objects \verb'Object' that has methods \verb'equal(object:Object):bool',
\verb'identical(object:Object):bool', and \verb'toString():String'. Their
remaining details are not considered further in the specification.

\N
Compilation proceeds as follows:
\begin{enumerate}
\item \emph{Compile-time information} is derived for the classes and interfaces
  that appear in the libraries and the program (Chapter \ref{chap:resolution}).
\item The expressions and statements in the program are
  \emph{statically verified} by inferring types and compile-time constants, yielding an
  executable (Chapter \ref{chap:inference}).
\item Compilation fails if any of the above steps reports a
  compile-time error.
\item Otherwise the executable is returned.
\end{enumerate}

\section{Execution Model}

\N
An executable is executed to produce a sequence of observables,
against a run-time representation of types, which is initially empty and is grown by
executing prior
executables, including the standard library.

\N
Execution of an executable proceeds as follows:
\begin{enumerate}
\item The static method corresponding to the entry point of the executable is executed, which requires
  the \emph{initialization} of the class that contains that static
  method, which may in turn trigger
  the initialization of other classes and interfaces, thereby building
  run-time representations of these
  types (Chapter \ref{chap:runtime}).
\item As part of initialization of types, other methods may be run, which
  involves the evaluation of statements and expressions
  therein, possibly yielding observables and other unobservable
  values (Chapter \ref{chap:evaluation}).
\end{enumerate}

\N
A class must be \emph{linked} before it is initialized. Linking a
class regenerates compile-time information on that class.

\N
A method must be \emph{dynamically verified} before it is
run. Dynamically verifying a method
prior to running it enforces the same constraints as would be by
static verification of that method.

\N A type must be
linked before it participates in verification.

\N
Conceptually, if a program has been compiled
against a library, then executables that define the types (classes
and interfaces) in that
library (which presumably the program relies on) should be executed prior to executing the executable that the
program compiles to so that those types already have run-time representations. In practice, this requirement can be
slightly relaxed: a type must be initialized prior to its
use at run time. This requirement is enforced by regenerating compile-time
information at link time and performing dynamic verification of code
prior to execution.

\chapter{Implementation Notes}

This chapter outlines the criteria for implementation correctness and
points out some degrees of freedom in implementing this
specification.

\section{Correctness}

\N
A runtime for the language is considered correct for an executable
when the executable produces an observable if and only if this
specification predicts that it should produce the same observable
(modulo system constraints).

\N
A compiler for the language is considered correct for a program when
it returns an executable
if and only if this specification predicts that it should return some
executable, and these executables when run by a correct runtime
produce the same observable (modulo system constraints).

\section{Intermediate Representations}

\N
An executable that is returned by compilation
can be encoded in an intermediate representation format, such as
the ActionScript Byte Code format, for mobility, and decoded from that format upon loading
for execution without any loss of information. The details of such formats are not
considered further in
this specification.

\N
The compiler and the runtime share knowledge of a set of intrinsic
operations that manipulate intrinsic data structures (Chapter \ref{chap:runtime}). These intrinsics
serve only to specify a semantic model for the language; they should
otherwise be considered abstract, and can be replaced by efficient
implementations that preserve the same semantic behaviors of their
abstract specifications, i.e., are correct.

\N
Some of the intrinsic operations may be available as language APIs
(with possibly native implementations), whereas others may correspond to
``bytecode instructions.'' The details of such implementation strategies are not
considered further in
this specification.

\N
In this specification, expressions are translated to intrinsic
operations as part of dynamic verification. An implementation may
choose to perform this translation at compile time instead, as part of
generating executable code: in particular, such an implementation could
generate bytecode instructions and language APIs corresponding to
those intrinsic operations. In such an implementation, dynamic
verification would have to be performed on the instrinsic operations
instead. The details of such implementation strategies are not
considered further in this specification.

\N
An executable, along with the libraries used by the compiler to
produce it, could be further compiled ``ahead-of-time'' to native code and
executed as such, without further linking and verification. The
details of such execution strategies are not considered further in
this specification, except to note that the
semantic behavior of such native code should be the same as what is
predicted by this specification, when the same libraries are loaded
prior to executing the same executable.

\part{Syntax}

\chapter{Scanning and Parsing}\label{chap:syntax}

\makeatletter{}
This chapter specifies how a sequence of characters is interpreted as
a syntax tree by the processes of scanning and parsing, to obtain a
program that may not yet be syntactically valid. The next
chapter specifies further rules for pruning such a syntax tree, by the
processes of unit configuration and enforcement of syntactic
restrictions, to
obtain a syntactically valid program.

\section{Preliminaries}

\subsection{Grammars}


\N
A grammar is specified by a set of \emph{rules}. A rule defines a
\emph{nonterminal} by a set of
\emph{productions}. A production is a
sequence of \emph{terminals} and nonterminals, possibly with some side
conditions.

\N
A grammar identifies the sequences of
terminals that \emph{match} a nonterminal.
% A sequence of terminals $A$
% matches
% a nonterminal $B$ if either of the following conditions hold:
% \begin{enumerate}
% \item there is a production in the rule for the nonterminal $B$ that is
%   the same as the sequence of terminals $A$;
% \item there is a production in the rule for the nonterminal $B$ that is
%   $A_1~B_1~\dots~B_{k-1}~A_k$, where $A_1,\dots,A_k$ are sequences of
%   terminals and $B_1,\dots,B_{k-1}$ are nonterminals, and there are
%   sequences of terminals $A'_1,\dots,A'_{k-1}$ that match
%   $B_1,\dots,B_{k-1}$ respectively, such that
%   $A_1~A'_1~\dots~A'_{k-1}~A_k$ is the same as $A$.
% \end{enumerate}
A sequence of terminals $A$
matches
a nonterminal $B$ if there is a production in the rule for the
nonterminal $B$ in the grammar that,
  upon substituting every nonterminal in that production with some sequence
  of terminals that matches it, becomes
  the sequence of terminals $A$.
% the nonterminal can be recursively substituted by that sequence
% of terminals, as follows: the nonterminal can be substituted by any of its productions; in turn, the
% nonterminals in that production can be substituted by any of their productions, and so on, until only
% terminals remain (there are no nonterminals to substitute).
Furthermore, side conditions may
appear in various positions in a production, and the conditions must be
satisfied at those positions. In particular, side conditions may
disambiguate ambiguous matches or restrict possible
matches, based on context.

\N
A \emph{syntax tree} is an ordered tree that represents how a sequence of terminals match a nonterminal.
The terminals are the leaves of the tree, and the nonterminal is the
root. Furthermore, intermediate nonterminals are the
internal nodes of the tree. Any subtree is a syntax tree that represents how
the subsequence of terminals that are leaves of that subtree match the intermediate nonterminal
that is the root of that subtree. The children of any parent are the nonterminals and terminals that
appear in some production of the parent, and they are ordered by the order in which they
appear in that production from left to right.


\N
A syntax tree $A$ is \emph{nested} by another syntax tree $B$ if $A$
is a (proper) subtree of $B$. $A$ is nested by $B$ \emph{without crossing} a
syntax tree $C$ if $A$ is nested by $B$ but either $A$ is not nested
by $C$ or $C$ is not nested by $B$. In particular, if $A$
is nested by $B$, then it follows that $A$ is not $B$, $A$ is
nested by $B$ without crossing $A$, and $A$ is nested by $B$ without crossing $B$.

\N
An \emph{ordered traversal} of a syntax tree is a traversal of the nodes of the tree in which a
parent is visited before its children, and the children of a parent are
visited in order. A node $A$ appears \emph{earlier} or \emph{later} than another node $B$ in the syntax tree
if a ordered traversal visits $A$ before or after $B$, respectively. By extension, a subtree $A$
appears earlier or later than another subtree $B$ if the root of $A$ appears earlier or later than
the root of $B$, respectively.


\subsection{Programs}



\N
The syntax of the language is specified by a \emph{syntactic grammar}, which in 
turn relies on a \emph{lexical grammar}. The nonterminals and terminals of the 
syntactic grammar are \emph{syntactic nonterminals} and 
\emph{syntactic terminals}, respectively. The nonterminals and terminals of the 
lexical grammar are \emph{lexical nonterminals} and \emph{lexical terminals},
respectively.

\N
A lexical terminal is a sequence of Unicode code units. 
A sequence
of lexical terminals that matches the lexical nonterminal
\nonterminal{InputElementOperand} or \nonterminal{InputElementOperator} is an \emph{input element}. 
An input element that is a
syntactic terminal is a \emph{token}. 
Any other input element is a \emph{token separator}.


\N
% A sequence of input elements is produced by a scanner (as defined by
% the lexical grammar) and consumed by a parser (as defined by the syntactic grammar and associated side conditions).
%The lexical grammar defines how sequences of characters (Unicode code
%units) are matched by input elements. 
There are two distinct \emph{parser contexts}
defined by the lexical nonterminals 
\lexicalnonterminal{InputElementOperator} and
\lexicalnonterminal{InputElementOperand}. (These parser contexts are required to disambiguate \verb'/' as the prefix of a
\nonterminal{RegularExpressionLiteral} or as a binary operation.) In a particular parser
context, input elements (tokens and token separators) must match the particular
lexical nonterminal that defines that parser context. The parser
switches into a particular parser context before or after it matches particular
nonterminals (i.e., when the current position immediately precedes or
immediately succeeds some input text that matches particular nonterminals), as described below.

\begin{enumerate}

\item 
The parser is initially in the parser context defined by
\lexicalnonterminal{InputElementOperator}, and switches into
that parser context after matching a \nonterminal{PrimaryExpression}.

\item The parser switches into the parser context defined by \lexicalnonterminal{InputElementOperand} 
before matching a \nonterminal{PrimaryExpression}.

\end{enumerate}

\N
The input elements that serve as token separators are \lexicalnonterminal{Whitespace}, \lexicalnonterminal{LineTerminator}, and 
\lexicalnonterminal{Comment}. By separating tokens, they provide
flexibility in how the text of a program is formatted. Token
separators are discarded from the output of scanning (which then becomes
the input of parsing).



\N
\emph{Scanning} is the process of matching
some text (a sequence of lexical terminals) to a sequence of tokens,
some of which may be 
separated by token separators. The tokens must be maximal, in the
following sense: if both $A$, $B$, and $A\:B$ are tokens, then the text $A\:B$
is scanned as the token $A\:B$, instead of the token $A$ followed by
the token $B$.

\N
\emph{Parsing} is the process
of matching a sequence of tokens to a syntactic nonterminal
(satisfying any associated side conditions). 


\N
A \emph{syntactically valid program} is a sequence of lexical
terminals (the
 text of the program) that, upon scanning, can be parsed to
 the syntactic nonterminal \nonterminal{Program} without any remaining
 text. 



 
%\input{syntax/input-elements.tex}
\makeatletter{}
\subsection{Rules, Productions, Terminals, and Nonterminals}

\N
A rule spans several lines; the first line contains the nonterminal that is 
defined by the rule, and each remaining line contains a production for that 
nonterminal. Rules are separated by blank lines.

\N
A production is a sequence of terminal and nonterminal symbols with optional 
side conditions at various positions in the sequence.

\N
Names of syntactic nonterminals begin with uppercase letters and are in 
slanted sans serif font, e.g., \nonterminal{Expression}. Names of lexical 
nonterminals (which may also be syntactic terminals) begin with uppercase 
letters and are in sans serif font, e.g. \lexicalnonterminal{NumericLiteral}. 
Lexical terminals (which may also be syntactic terminals) represent sequences 
of Unicode code units that are either represented by literal characters in 
typewriter font, e.g. \verb`{` or \terminal{function}, or described by Unicode
categories. 

\N
Identifiers that are represented in typewriter font have special meaning in the context 
in which they occur in the grammar. Such identifiers may or may not be globally 
reserved. Globally reserved identifiers are listed in the lexical nonterminal 
\lexicalnonterminal{Keyword}.

\subsection{Side Conditions}
\label{subsec:side-conditions}

Side conditions rely on the following notation. ($\cal X$ is a metavariable denoting some grammatical entity).

\N
Literal non-blank characters in a typewriter font are taken from the
ISO Latin-1 character set and represent the corresponding Unicode code
units.

\N
$\epsilon$ is matched by the empty sequence.

\N
$\cal X$\tag{opt} is matched by either the empty sequence or
  a sequence that matches $\cal X$.

\N
\terminal{U+} followed by four \lexicalnonterminal{HexadecimalDigit}s
(hexadecimal digits) is standard notation 
for a Unicode code unit.

\N
\condition{\underline{lookahead not} $\cal X$} requires that any
following nonterminal is not matched by a
sequence of 
  Unicode code units that matches $\cal X$

\N
\condition{\underline{but not} $\cal X$} requires that the
  preceding nonterminal is not matched by a sequence of
  Unicode code units that
  matches $\cal X$.

\N
\condition{\underline{any Unicode} $\cal X$} is any
  Unicode code unit denoted by $\cal
  X$.

\N
\note{$\dots$ \ortag{} $\dots$} means choice.


 
\makeatletter{}
\section{Lexical Grammar}\label{sec:lexgrammar}

\subsection{Input Elements}


\phantomsection\label{nt:inputElementOperand}\lexicalnonterminal{InputElementOperand}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:whitespace]{\lexicalnonterminal{Whitespace}} 
\grammarprod \hyperref[nt:lineTerminator]{\lexicalnonterminal{LineTerminator}} 
\grammarprod \hyperref[nt:comment]{\lexicalnonterminal{Comment}} 
\grammarprod \hyperref[nt:identifierOrKeyword]{\lexicalnonterminal{IdentifierOrKeyword}} 
\grammarprod \hyperref[nt:numericLiteral]{\lexicalnonterminal{NumericLiteral}} 
\grammarprod \hyperref[nt:stringLiteral]{\lexicalnonterminal{StringLiteral}} 
\grammarprod \hyperref[nt:punctuator]{\lexicalnonterminal{Punctuator}} \tagbegin{but not}{\scriptsize\verb`/` \ortag{} \verb`/=`}\tagend{} 
\grammarprod \hyperref[nt:regularExpressionLiteral]{\lexicalnonterminal{RegularExpressionLiteral}} 
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}
\begin{notes}
AS3 has four parsing contexts, and correspondingly, four lexical nonterminals to recognize input elements in
those parsing contexts. In contrast, AS4 has just two. This
simplification is possible because AS4 does not syntactically support
E4X XML literals (but continues to support ECMAScript regular-expression literals).


\end{notes}
\phantomsection\label{nt:inputElementOperator}\lexicalnonterminal{InputElementOperator}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:whitespace]{\lexicalnonterminal{Whitespace}} 
\grammarprod \hyperref[nt:lineTerminator]{\lexicalnonterminal{LineTerminator}} 
\grammarprod \hyperref[nt:comment]{\lexicalnonterminal{Comment}} 
\grammarprod \hyperref[nt:identifierOrKeyword]{\lexicalnonterminal{IdentifierOrKeyword}} 
\grammarprod \hyperref[nt:numericLiteral]{\lexicalnonterminal{NumericLiteral}} 
\grammarprod \hyperref[nt:stringLiteral]{\lexicalnonterminal{StringLiteral}} 
\grammarprod \hyperref[nt:punctuator]{\lexicalnonterminal{Punctuator}} 
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}


\subsection{Whitespace and Line Terminators}

\phantomsection\label{nt:whitespace}\lexicalnonterminal{Whitespace}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{U+0009} 
\grammarprod \terminal{U+000B} 
\grammarprod \terminal{U+000C} 
\grammarprod \terminal{U+FEFF} 
\grammarprod \condition{\underline{any Unicode} Zs} 
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}
\begin{notes}
 Any Unicode Cf can be used within comments and strings.
      Outside of comments and strings, the
      following three Unicode code units have
      the given meanings:
      \begin{itemize}
      \item \verb`U+200C` $\rightarrow$ \lexicalnonterminal{IdentifierPart}
      \item \verb`U+200D` $\rightarrow$ \lexicalnonterminal{IdentifierPart}
      \item \verb`U+FEFF` $\rightarrow$ \lexicalnonterminal{Whitespace}
      \end{itemize}


\end{notes}

\phantomsection\label{nt:lineTerminator}\lexicalnonterminal{LineTerminator}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{U+000A} 
\grammarprod \terminal{U+000D} 
\grammarprod \terminal{U+2028} 
\grammarprod \terminal{U+2029} 
\grammarprod \terminal{U+000D} \terminal{U+000A} 
\end{tabbing}
\vspace*{5pt}\subsection{Comments}

\phantomsection\label{nt:comment}\lexicalnonterminal{Comment}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:multiLineComment]{\lexicalnonterminal{MultiLineComment}} 
\grammarprod \hyperref[nt:singleLineComment]{\lexicalnonterminal{SingleLineComment}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:multiLineComment}\lexicalnonterminal{MultiLineComment}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`/*` \hyperref[nt:multiLineCommentCharacters]{\lexicalnonterminal{MultiLineCommentCharacters}}\tag{opt} \verb`*/` 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:multiLineCommentCharacters}\lexicalnonterminal{MultiLineCommentCharacters}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD
\hyperref[nt:sourceCharacter]{\lexicalnonterminal{SourceCharacter}}
\tagbegin{but not}{\scriptsize\verb`*`}\tagend{} 
\label{nt:multiLineCommentCharacters}\lexicalnonterminal{MultiLineCommentCharacters}\tag{opt}
\grammarprod
\verb'*'
\tagbegin{lookahead not}{\scriptsize\verb`/`}\tagend{} 
\label{nt:multiLineCommentCharacters}\lexicalnonterminal{MultiLineCommentCharacters}\tag{opt}
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:singleLineComment}\lexicalnonterminal{SingleLineComment}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`//` \hyperref[nt:singleLineCommentCharacters]{\lexicalnonterminal{SingleLineCommentCharacters}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:singleLineCommentCharacters}\lexicalnonterminal{SingleLineCommentCharacters}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:sourceCharacter]{\lexicalnonterminal{SourceCharacter}} \tagbegin{but not}{\scriptsize\lexicalnonterminal{LineTerminator}}\tagend{} 
\label{nt:singleLineCommentCharacters}\lexicalnonterminal{SingleLineCommentCharacters}\tag{opt}
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:sourceCharacter}\lexicalnonterminal{SourceCharacter}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \condition{\underline{any Unicode} code unit} 
\end{tabbing}
\vspace*{5pt}\subsection{Identifiers}

\phantomsection\label{nt:identifier}\lexicalnonterminal{Identifier}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:identifierOrKeyword]{\lexicalnonterminal{IdentifierOrKeyword}} \tagbegin{but not}{\scriptsize\lexicalnonterminal{Keyword}}\tagend{} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:identifierOrKeyword}\lexicalnonterminal{IdentifierOrKeyword}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:identifierStart]{\lexicalnonterminal{IdentifierStart}} 
\grammarprod \hyperref[nt:identifierOrKeyword]{\lexicalnonterminal{IdentifierOrKeyword}} \hyperref[nt:identifierPart]{\lexicalnonterminal{IdentifierPart}} 
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}
\begin{notes}
 Unicode escape sequences may be used to spell the names of identifiers
that would otherwise be keywords. This is in contrast to ECMAScript.


\end{notes}

\phantomsection\label{nt:identifierStart}\lexicalnonterminal{IdentifierStart}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:unicodeLetter]{\lexicalnonterminal{UnicodeLetter}} 
\grammarprod \verb`$` 
\grammarprod \verb`_` 
\grammarprod \verb`\` \hyperref[nt:fixedLengthUnicodeEscapeSequence]{\lexicalnonterminal{fixedLengthUnicodeEscapeSequence}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:identifierPart}\lexicalnonterminal{IdentifierPart}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:identifierStart]{\lexicalnonterminal{IdentifierStart}} 
\grammarprod \hyperref[nt:unicodeCombiningMark]{\lexicalnonterminal{UnicodeCombiningMark}} 
\grammarprod \hyperref[nt:unicodeDigit]{\lexicalnonterminal{UnicodeDigit}} 
\grammarprod \hyperref[nt:unicodeConnectorPunctuation]{\lexicalnonterminal{UnicodeConnectorPunctuation}} 
\grammarprod \terminal{U+200C} \condition{ZWNJ} 
\grammarprod \terminal{U+200D} \condition{ZWJ} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:unicodeLetter}\lexicalnonterminal{UnicodeLetter}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \condition{\underline{any Unicode} Lu \ortag{} Ll \ortag{} Lt \ortag{} Lm \ortag{} Lo \ortag{} Nl} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:unicodeCombiningMark}\lexicalnonterminal{UnicodeCombiningMark}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \condition{\underline{any Unicode} Mn \ortag{} Mc} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:unicodeDigit}\lexicalnonterminal{UnicodeDigit}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \condition{\underline{any Unicode} Nd} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:unicodeConnectorPunctuation}\lexicalnonterminal{UnicodeConnectorPunctuation}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \condition{\underline{any Unicode} Pc} 
\end{tabbing}
\vspace*{5pt}\subsection{Keywords and Punctuators}

\phantomsection\label{nt:keyword}\lexicalnonterminal{Keyword}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{as} 
\grammarprod \terminal{break} 
\grammarprod \terminal{case} 
\grammarprod \terminal{catch} 
\grammarprod \terminal{class} 
\grammarprod \terminal{continue} 
\grammarprod \terminal{default}
\grammarprod \terminal{defer}
\grammarprod \terminal{do} 
\grammarprod \terminal{else} 
\grammarprod \terminal{false} 
\grammarprod \terminal{finally} 
\grammarprod \terminal{for} 
\grammarprod \terminal{function} 
\grammarprod \terminal{if} 
\grammarprod \terminal{import} 
\grammarprod \terminal{interface} 
\grammarprod \terminal{internal} 
\grammarprod \terminal{is} 
\grammarprod \terminal{let} 
\grammarprod \terminal{new} 
\grammarprod \terminal{null} 
\grammarprod \terminal{package} 
\grammarprod \terminal{private} 
\grammarprod \terminal{protected} 
\grammarprod \terminal{public} 
\grammarprod \terminal{return} 
\grammarprod \terminal{super} 
\grammarprod \terminal{switch} 
\grammarprod \terminal{this} 
\grammarprod \terminal{throw} 
\grammarprod \terminal{true} 
\grammarprod \terminal{try} 
\grammarprod \terminal{var} 
\grammarprod \terminal{void} 
\grammarprod \terminal{while} 
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}
\begin{notes}
 \lexicalnonterminal{Keyword}s are reserved words that have special meanings. 
Some \lexicalnonterminal{Identifier}s have special meanings in some syntactic contexts, but are not \lexicalnonterminal{Keyword}s;
   such \lexicalnonterminal{Identifier}s are contextually reserved. 

The following AS3 keywords are no longer in AS4: 
\verb'delete', \verb'include', \verb'instanceof',
\verb'namespace', \verb'typeof', \verb'use', \verb'with', \verb'in'. The \verb'const' keyword is
replaced by \verb'let'. The keyword \verb'defer' is
introduced in AS4.

\end{notes}

\phantomsection\label{nt:punctuator}\lexicalnonterminal{Punctuator}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`.` 
\grammarprod \verb`!` 
\grammarprod \verb`!=` 
\grammarprod \verb`!==` 
\grammarprod \verb`%` 
\grammarprod \verb`%=` 
\grammarprod \verb`&` 
\grammarprod \verb`&=` 
\grammarprod \verb`&&` 
\grammarprod \verb`&&=` 
\grammarprod \verb`*` 
\grammarprod \verb`*=` 
\grammarprod \verb`+` 
\grammarprod \verb`+=` 
\grammarprod \verb`++` 
\grammarprod \verb`-` 
\grammarprod \verb`-=` 
\grammarprod \verb`--` 
\grammarprod \verb`=` 
\grammarprod \verb`==` 
\grammarprod \verb`===` 
\grammarprod \verb`>` 
\grammarprod \verb`>=` 
\grammarprod \verb`>>` 
\grammarprod \verb`>>=` 
\grammarprod \verb`^` 
\grammarprod \verb`^=` 
\grammarprod \verb`|` 
\grammarprod \verb`|=` 
\grammarprod \verb`||` 
\grammarprod \verb`||=` 
\grammarprod \verb`:` 
\grammarprod \verb`(` 
\grammarprod \verb`)` 
\grammarprod \verb`[` 
\grammarprod \verb`]` 
\grammarprod \verb`{` 
\grammarprod \verb`}` 
\grammarprod \verb`~` 
\grammarprod \verb`,` 
\grammarprod \verb`;` 
\grammarprod \verb`?` 
\grammarprod \verb`@` 
\grammarprod \verb`/` 
\grammarprod \verb`/=` 
\grammarprod \verb`<` 
\grammarprod \verb`<=` 
\grammarprod \verb`<<` 
\grammarprod \verb`<<=` 
\grammarprod \verb`=>`
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}
\begin{notes}
The following AS3 punctuators are no longer in AS4: \verb'.<', \verb'..', 
\verb'::', \verb'>>>', \verb'>>>=', \verb'...'.
The punctuator
\verb'@' is repurposed. The
punctuator \verb'=>' is introduced.

\end{notes}

\subsection{Numeric Literals}

\phantomsection\label{nt:numericLiteral}\lexicalnonterminal{NumericLiteral}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:decimalLiteral]{\lexicalnonterminal{DecimalLiteral}} 
\grammarprod \hyperref[nt:hexadecimalIntegerLiteral]{\lexicalnonterminal{HexadecimalIntegerLiteral}} 
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}
\begin{notes}
 The source character immediately following a
\lexicalnonterminal{NumericLiteral} may be an
\lexicalnonterminal{IdentifierStart}. This is in contrast to
ECMAScript. This might be useful to distinguish literals for unsigned numbers,
floating point numbers, and so on, in the future.


\end{notes}

\phantomsection\label{nt:decimalLiteral}\lexicalnonterminal{DecimalLiteral}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:decimalDigits]{\lexicalnonterminal{DecimalDigits}} \verb`.` \hyperref[nt:decimalDigits]{\lexicalnonterminal{DecimalDigits}}\tag{opt} \hyperref[nt:exponentPart]{\lexicalnonterminal{ExponentPart}}\tag{opt} 
\grammarprod \verb`.` \hyperref[nt:decimalDigits]{\lexicalnonterminal{DecimalDigits}} \hyperref[nt:exponentPart]{\lexicalnonterminal{ExponentPart}}\tag{opt} 
\grammarprod \hyperref[nt:decimalDigits]{\lexicalnonterminal{DecimalDigits}} \hyperref[nt:exponentPart]{\lexicalnonterminal{ExponentPart}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:decimalDigits}\lexicalnonterminal{DecimalDigits}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:decimalDigit]{\lexicalnonterminal{DecimalDigit}} \hyperref[nt:decimalDigits]{\lexicalnonterminal{DecimalDigits}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:decimalDigit}\lexicalnonterminal{DecimalDigit}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`0` 
\grammarprod \verb`1` 
\grammarprod \verb`2` 
\grammarprod \verb`3` 
\grammarprod \verb`4` 
\grammarprod \verb`5` 
\grammarprod \verb`6` 
\grammarprod \verb`7` 
\grammarprod \verb`8` 
\grammarprod \verb`9` 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:exponentPart}\lexicalnonterminal{ExponentPart}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:exponentIndicator]{\lexicalnonterminal{ExponentIndicator}} \hyperref[nt:sign]{\lexicalnonterminal{Sign}}\tag{opt} \hyperref[nt:decimalDigits]{\lexicalnonterminal{DecimalDigits}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:exponentIndicator}\lexicalnonterminal{ExponentIndicator}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`e` 
\grammarprod \verb`E` 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:sign}\lexicalnonterminal{Sign}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`+` 
\grammarprod \verb`-` 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:hexadecimalIntegerLiteral}\lexicalnonterminal{HexadecimalIntegerLiteral}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`0x` \hyperref[nt:hexadecimalDigits]{\lexicalnonterminal{HexadecimalDigits}} 
\grammarprod \verb`0X` \hyperref[nt:hexadecimalDigits]{\lexicalnonterminal{HexadecimalDigits}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:hexadecimalDigits}\lexicalnonterminal{HexadecimalDigits}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:hexadecimalDigit]{\lexicalnonterminal{HexadecimalDigit}} \hyperref[nt:hexadecimalDigits]{\lexicalnonterminal{HexadecimalDigits}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:hexadecimalDigit}\lexicalnonterminal{HexadecimalDigit}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`0` 
\grammarprod \verb`1` 
\grammarprod \verb`2` 
\grammarprod \verb`3` 
\grammarprod \verb`4` 
\grammarprod \verb`5` 
\grammarprod \verb`6` 
\grammarprod \verb`7` 
\grammarprod \verb`8` 
\grammarprod \verb`9` 
\grammarprod \verb`a` 
\grammarprod \verb`b` 
\grammarprod \verb`c` 
\grammarprod \verb`d` 
\grammarprod \verb`e` 
\grammarprod \verb`f` 
\grammarprod \verb`A` 
\grammarprod \verb`B` 
\grammarprod \verb`C` 
\grammarprod \verb`D` 
\grammarprod \verb`E` 
\grammarprod \verb`F` 
\end{tabbing}
\vspace*{5pt}\subsection{String Literals}

\phantomsection\label{nt:stringLiteral}\lexicalnonterminal{StringLiteral}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`"` \hyperref[nt:doubleStringCharacters]{\lexicalnonterminal{DoubleStringCharacters}}\tag{opt} \verb`" ` 
\grammarprod \verb`'` \hyperref[nt:singleStringCharacters]{\lexicalnonterminal{SingleStringCharacters}}\tag{opt} \verb`'` 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:doubleStringCharacters}\lexicalnonterminal{DoubleStringCharacters}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:doubleStringCharacter]{\lexicalnonterminal{DoubleStringCharacter}} \hyperref[nt:doubleStringCharacters]{\lexicalnonterminal{DoubleStringCharacters}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:singleStringCharacters}\lexicalnonterminal{SingleStringCharacters}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:singleStringCharacter]{\lexicalnonterminal{SingleStringCharacter}} \hyperref[nt:singleStringCharacters]{\lexicalnonterminal{SingleStringCharacters}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:doubleStringCharacter}\lexicalnonterminal{DoubleStringCharacter}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:sourceCharacter]{\lexicalnonterminal{SourceCharacter}} \tagbegin{but not}{\scriptsize\verb`"` \ortag{} \verb`\` \ortag{} \lexicalnonterminal{LineTerminator}}\tagend{} 
\grammarprod \verb`\` \hyperref[nt:escapeSequence]{\lexicalnonterminal{EscapeSequence}} 
\grammarprod \hyperref[nt:lineContinuation]{\lexicalnonterminal{LineContinuation}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:singleStringCharacter}\lexicalnonterminal{SingleStringCharacter}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:sourceCharacter]{\lexicalnonterminal{SourceCharacter}} \tagbegin{but not}{\scriptsize\verb`'` \ortag{} \verb`\` \ortag{} \lexicalnonterminal{LineTerminator}}\tagend{} 
\grammarprod \verb`\` \hyperref[nt:escapeSequence]{\lexicalnonterminal{EscapeSequence}} 
\grammarprod \hyperref[nt:lineContinuation]{\lexicalnonterminal{LineContinuation}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:lineContinuation}\lexicalnonterminal{LineContinuation}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`\` \hyperref[nt:lineTerminator]{\lexicalnonterminal{LineTerminator}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:escapeSequence}\lexicalnonterminal{EscapeSequence}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:characterEscapeSequence]{\lexicalnonterminal{CharacterEscapeSequence}} 
\grammarprod \verb`0` \tagbegin{lookahead not}{\scriptsize\lexicalnonterminal{DecimalDigit}}\tagend{} 
\grammarprod \hyperref[nt:hexadecimalEscapeSequence]{\lexicalnonterminal{HexadecimalEscapeSequence}} 
\grammarprod \hyperref[nt:fixedLengthUnicodeEscapeSequence]{\lexicalnonterminal{FixedLengthUnicodeEscapeSequence}} 
\grammarprod \hyperref[nt:variableLengthEscapeSequence]{\lexicalnonterminal{VariableLengthEscapeSequence}} 
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}
\begin{notes}
 During lexical analysis, a \verb`\`\lexicalnonterminal{EscapeSequence} other than \verb`\`\lexicalnonterminal{VariableLengthEscapeSequence} is translated to a single
      Unicode code unit, and a \verb`\`\lexicalnonterminal{VariableLengthEscapeSequence} is translated to a single
      Unicode code point. This means that its interpretation does not affect the lexical
      structure (and therefore syntax) of the program. For example, \verb`\n` is a 
      string character that is interpreted as a line feed. This holds
      for \lexicalnonterminal{UnicodeEscapeSequence} as well, e.g.,
      \verb`\u000A`, in
      contrast to Java's treatment of
      Unicode escape sequences, which are interpreted before lexical analysis.


\end{notes}

\phantomsection\label{nt:characterEscapeSequence}\lexicalnonterminal{CharacterEscapeSequence}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:singleEscapeCharacter]{\lexicalnonterminal{SingleEscapeCharacter}} 
\grammarprod \hyperref[nt:nonEscapeCharacter]{\lexicalnonterminal{NonEscapeCharacter}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:singleEscapeCharacter}\lexicalnonterminal{SingleEscapeCharacter}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`'` 
\grammarprod \verb`"` 
\grammarprod \verb`\` 
\grammarprod \terminal{b} 
\grammarprod \terminal{f} 
\grammarprod \terminal{n} 
\grammarprod \terminal{r} 
\grammarprod \terminal{t} 
\grammarprod \terminal{v} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:nonEscapeCharacter}\lexicalnonterminal{NonEscapeCharacter}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:sourceCharacter]{\lexicalnonterminal{SourceCharacter}} \tagbegin{but not}{\scriptsize\lexicalnonterminal{EscapeCharacter} \ortag{} \lexicalnonterminal{LineTerminator}}\tagend{} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:escapeCharacter}\lexicalnonterminal{EscapeCharacter}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:singleEscapeCharacter]{\lexicalnonterminal{SingleEscapeCharacter}} 
\grammarprod \hyperref[nt:decimalDigit]{\lexicalnonterminal{DecimalDigit}} 
\grammarprod \terminal{x} 
\grammarprod \terminal{u}
\grammarprod \terminal{U}
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:hexadecimalEscapeSequence}\lexicalnonterminal{HexadecimalEscapeSequence}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{x} \hyperref[nt:hexadecimalDigit]{\lexicalnonterminal{HexadecimalDigit}} \hyperref[nt:hexadecimalDigit]{\lexicalnonterminal{HexadecimalDigit}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:fixedLengthunicodeEscapeSequence}\lexicalnonterminal{FixedLengthUnicodeEscapeSequence}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{u} \hyperref[nt:hexadecimalDigit]{\lexicalnonterminal{HexadecimalDigit}} \hyperref[nt:hexadecimalDigit]{\lexicalnonterminal{HexadecimalDigit}} \hyperref[nt:hexadecimalDigit]{\lexicalnonterminal{HexadecimalDigit}} \hyperref[nt:hexadecimalDigit]{\lexicalnonterminal{HexadecimalDigit}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:variableLengthUnicodeEscapeSequence}\lexicalnonterminal{VariableLengthUnicodeEscapeSequence}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{U} \verb'{'
  \hyperref[nt:hexadecimalDigits]{\lexicalnonterminal{HexadecimalDigits}}\tag{opt}
  \verb'}'
\end{tabbing}
\vspace*{5pt}

\vspace*{5pt}\subsection{Regular Expression Literals}

\phantomsection\label{nt:regularExpressionLiteral}\lexicalnonterminal{RegularExpressionLiteral}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`/` \hyperref[nt:regularExpressionBody]{\lexicalnonterminal{RegularExpressionBody}} \verb`/` \hyperref[nt:regularExpressionFlags]{\lexicalnonterminal{RegularExpressionFlags}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}
\begin{notes}
 A \lexicalnonterminal{RegularExpressionBody} is never
      $\epsilon$; instead of representing an 
      empty regular expression, \verb`//` starts a \lexicalnonterminal{SingleLineComment}. To specify an empty regular expression, use \verb`/(?:)/`.


\end{notes}

\phantomsection\label{nt:regularExpressionBody}\lexicalnonterminal{RegularExpressionBody}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:regularExpressionFirstCharacter]{\lexicalnonterminal{RegularExpressionFirstCharacter}} \hyperref[nt:regularExpressionCharacters]{\lexicalnonterminal{RegularExpressionCharacters}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:regularExpressionCharacters}\lexicalnonterminal{RegularExpressionCharacters}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:regularExpressionCharacter]{\lexicalnonterminal{RegularExpressionCharacter}} \hyperref[nt:regularExpressionCharacters]{\lexicalnonterminal{RegularExpressionCharacters}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:regularExpressionFirstCharacter}\lexicalnonterminal{RegularExpressionFirstCharacter}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:regularExpressionNonTerminator]{\lexicalnonterminal{RegularExpressionNonTerminator}} \tagbegin{but not}{\scriptsize\verb`*` \ortag{} \verb`\` \ortag{} \verb`/` \ortag{} \verb`[`}\tagend{} 
\grammarprod \hyperref[nt:regularExpressionBackslashSequence]{\lexicalnonterminal{RegularExpressionBackslashSequence}} 
\grammarprod \hyperref[nt:regularExpressionClass]{\lexicalnonterminal{RegularExpressionClass}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:regularExpressionCharacter}\lexicalnonterminal{RegularExpressionCharacter}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:regularExpressionNonTerminator]{\lexicalnonterminal{RegularExpressionNonTerminator}} \tagbegin{but not}{\scriptsize\verb`\` \ortag{} \verb`/` \ortag{} \verb`[`}\tagend{} 
\grammarprod \hyperref[nt:regularExpressionBackslashSequence]{\lexicalnonterminal{RegularExpressionBackslashSequence}} 
\grammarprod \hyperref[nt:regularExpressionClass]{\lexicalnonterminal{RegularExpressionClass}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:regularExpressionBackslashSequence}\lexicalnonterminal{RegularExpressionBackslashSequence}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`\` \hyperref[nt:sourceCharacter]{\lexicalnonterminal{SourceCharacter}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:regularExpressionNonTerminator}\lexicalnonterminal{RegularExpressionNonTerminator}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:sourceCharacter]{\lexicalnonterminal{SourceCharacter}} \tagbegin{but not}{\scriptsize\lexicalnonterminal{LineTerminator}}\tagend{} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:regularExpressionClass}\lexicalnonterminal{RegularExpressionClass}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`[` \hyperref[nt:regularExpressionClassCharacters]{\lexicalnonterminal{RegularExpressionClassCharacters}}\tag{opt} \verb`]` 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:regularExpressionClassCharacters}\lexicalnonterminal{RegularExpressionClassCharacters}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:regularExpressionClassCharacter]{\lexicalnonterminal{RegularExpressionClassCharacter}} \hyperref[nt:regularExpressionClassCharacters]{\lexicalnonterminal{RegularExpressionClassCharacters}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:regularExpressionClassCharacter}\lexicalnonterminal{RegularExpressionClassCharacter}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:regularExpressionNonTerminator]{\lexicalnonterminal{RegularExpressionNonTerminator}} \tagbegin{but not}{\scriptsize\verb`]` \ortag{} \verb`\`}\tagend{} 
\grammarprod \hyperref[nt:regularExpressionBackslashSequence]{\lexicalnonterminal{RegularExpressionBackslashSequence}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:regularExpressionFlags}\lexicalnonterminal{RegularExpressionFlags}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:identifierPart]{\lexicalnonterminal{IdentifierPart}} \hyperref[nt:regularExpressionFlags]{\lexicalnonterminal{RegularExpressionFlags}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}

% \subsection{Regular Expression Literals}

% \phantomsection\label{nt:regularExpressionLiteral}\lexicalnonterminal{RegularExpressionLiteral}\marknote
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \verb`/` \hyperref[nt:regularExpressionBody]{\lexicalnonterminal{RegularExpressionBody}} \verb`/` \hyperref[nt:regularExpressionFlags]{\lexicalnonterminal{RegularExpressionFlags}}\tag{opt} 
% \end{tabbing}
% \vspace*{5pt}
% \vspace*{-5pt}
% \begin{notes}
%  A \lexicalnonterminal{RegularExpressionBody} is never
%       $\epsilon$; instead of representing an 
%       empty regular expression, \verb`//` starts a \lexicalnonterminal{SingleLineComment}. To specify an empty regular expression, use \verb`/(?:)/`.


% \end{notes}

% \phantomsection\label{nt:regularExpressionBody}\lexicalnonterminal{RegularExpressionBody}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:regularExpressionFirstCharacter]{\lexicalnonterminal{RegularExpressionFirstCharacter}} \hyperref[nt:regularExpressionCharacters]{\lexicalnonterminal{RegularExpressionCharacters}}\tag{opt} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:regularExpressionCharacters}\lexicalnonterminal{RegularExpressionCharacters}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:regularExpressionCharacter]{\lexicalnonterminal{RegularExpressionCharacter}} \hyperref[nt:regularExpressionCharacters]{\lexicalnonterminal{RegularExpressionCharacters}}\tag{opt} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:regularExpressionFirstCharacter}\lexicalnonterminal{RegularExpressionFirstCharacter}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:regularExpressionNonTerminator]{\lexicalnonterminal{RegularExpressionNonTerminator}} \tagbegin{but not}{\scriptsize\verb`*` \ortag{} \verb`\` \ortag{} \verb`/` \ortag{} \verb`[`}\tagend{} 
% \grammarprod \hyperref[nt:regularExpressionBackslashSequence]{\lexicalnonterminal{RegularExpressionBackslashSequence}} 
% \grammarprod \hyperref[nt:regularExpressionClass]{\lexicalnonterminal{RegularExpressionClass}} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:regularExpressionCharacter}\lexicalnonterminal{RegularExpressionCharacter}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:regularExpressionNonTerminator]{\lexicalnonterminal{RegularExpressionNonTerminator}} \tagbegin{but not}{\scriptsize\verb`\` \ortag{} \verb`/` \ortag{} \verb`[`}\tagend{} 
% \grammarprod \hyperref[nt:regularExpressionBackslashSequence]{\lexicalnonterminal{RegularExpressionBackslashSequence}} 
% \grammarprod \hyperref[nt:regularExpressionClass]{\lexicalnonterminal{RegularExpressionClass}} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:regularExpressionBackslashSequence}\lexicalnonterminal{RegularExpressionBackslashSequence}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \verb`\` \hyperref[nt:sourceCharacter]{\lexicalnonterminal{SourceCharacter}} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:regularExpressionNonTerminator}\lexicalnonterminal{RegularExpressionNonTerminator}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:sourceCharacter]{\lexicalnonterminal{SourceCharacter}} \tagbegin{but not}{\scriptsize\lexicalnonterminal{LineTerminator}}\tagend{} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:regularExpressionClass}\lexicalnonterminal{RegularExpressionClass}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \verb`[` \hyperref[nt:regularExpressionClassCharacters]{\lexicalnonterminal{RegularExpressionClassCharacters}}\tag{opt} \verb`]` 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:regularExpressionClassCharacters}\lexicalnonterminal{RegularExpressionClassCharacters}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:regularExpressionClassCharacter]{\lexicalnonterminal{RegularExpressionClassCharacter}} \hyperref[nt:regularExpressionClassCharacters]{\lexicalnonterminal{RegularExpressionClassCharacters}}\tag{opt} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:regularExpressionClassCharacter}\lexicalnonterminal{RegularExpressionClassCharacter}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:regularExpressionNonTerminator]{\lexicalnonterminal{RegularExpressionNonTerminator}} \tagbegin{but not}{\scriptsize\verb`]` \ortag{} \verb`\`}\tagend{} 
% \grammarprod \hyperref[nt:regularExpressionBackslashSequence]{\lexicalnonterminal{RegularExpressionBackslashSequence}} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:regularExpressionFlags}\lexicalnonterminal{RegularExpressionFlags}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:identifierPart]{\lexicalnonterminal{IdentifierPart}} \hyperref[nt:regularExpressionFlags]{\lexicalnonterminal{RegularExpressionFlags}}\tag{opt} 
% \end{tabbing}
% \vspace*{5pt}\subsection{XML Literals}

% \phantomsection\label{nt:xmlMarkup}\lexicalnonterminal{XMLMarkup}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:xmlComment]{\lexicalnonterminal{XMLComment}} 
% \grammarprod \hyperref[nt:xmlCDATA]{\lexicalnonterminal{XMLCDATA}} 
% \grammarprod \hyperref[nt:xmlPI]{\lexicalnonterminal{XMLPI}} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:xmlWhitespaceCharacter}\lexicalnonterminal{XMLWhitespaceCharacter}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \terminal{U+0009} 
% \grammarprod \terminal{U+000A} 
% \grammarprod \terminal{U+000D} 
% \grammarprod \terminal{U+0020} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:xmlWhitespace}\lexicalnonterminal{XMLWhitespace}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:xmlWhitespaceCharacter]{\lexicalnonterminal{XMLWhitespaceCharacter}} \hyperref[nt:xmlWhitespace]{\lexicalnonterminal{XMLWhitespace}}\tag{opt} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:xmlText}\lexicalnonterminal{XMLText}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:sourceCharacters]{\lexicalnonterminal{SourceCharacters}} \tagbegin{but no embedded}{\scriptsize\verb`{` \ortag{} \verb`<`}\tagend{} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:xmlName}\lexicalnonterminal{XMLName}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:xmlNameStart]{\lexicalnonterminal{XMLNameStart}} 
% \grammarprod \hyperref[nt:xmlName]{\lexicalnonterminal{XMLName}} \hyperref[nt:xmlNamePart]{\lexicalnonterminal{XMLNamePart}} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:xmlNameStart}\lexicalnonterminal{XMLNameStart}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:unicodeLetter]{\lexicalnonterminal{UnicodeLetter}} 
% \grammarprod \verb`_` 
% \grammarprod \verb`:` 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:xmlNamePart}\lexicalnonterminal{XMLNamePart}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:unicodeLetter]{\lexicalnonterminal{UnicodeLetter}} 
% \grammarprod \hyperref[nt:unicodeDigit]{\lexicalnonterminal{UnicodeDigit}} 
% \grammarprod \verb`.` 
% \grammarprod \verb`-` 
% \grammarprod \verb`_` 
% \grammarprod \verb`:` 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:xmlComment}\lexicalnonterminal{XMLComment}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \verb`<!--` \hyperref[nt:xmlCommentCharacters]{\lexicalnonterminal{XMLCommentCharacters}}\tag{opt} \verb`-->` 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:xmlCommentCharacters}\lexicalnonterminal{XMLCommentCharacters}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:sourceCharacters]{\lexicalnonterminal{SourceCharacters}} \tagbegin{but no embedded}{\scriptsize\verb`--`}\tagend{} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:xmlCDATA}\lexicalnonterminal{XMLCDATA}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \verb`<![CDATA[` \hyperref[nt:xmlCDATACharacters]{\lexicalnonterminal{XMLCDATACharacters}}\tag{opt} \verb`]]>` 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:xmlCDATACharacters}\lexicalnonterminal{XMLCDATACharacters}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:sourceCharacters]{\lexicalnonterminal{SourceCharacters}} \tagbegin{but no embedded}{\scriptsize\verb`]]>`}\tagend{} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:xmlPI}\lexicalnonterminal{XMLPI}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \verb`<?` \hyperref[nt:xmlPICharacters]{\lexicalnonterminal{XMLPICharacters}}\tag{opt} \verb`?>` 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:xmlPICharacters}\lexicalnonterminal{XMLPICharacters}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:sourceCharacters]{\lexicalnonterminal{SourceCharacters}} \tagbegin{but no embedded}{\scriptsize\verb`?>`}\tagend{} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:xmlAttributeValue}\lexicalnonterminal{XMLAttributeValue}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \verb`"` \hyperref[nt:xmlDoubleStringCharacters]{\lexicalnonterminal{XMLDoubleStringCharacters}}\tag{opt} \verb`"` 
% \grammarprod \verb`'` \hyperref[nt:xmlSingleStringCharacters]{\lexicalnonterminal{XMLSingleStringCharacters}}\tag{opt} \verb`'` 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:xmlDoubleStringCharacters}\lexicalnonterminal{XMLDoubleStringCharacters}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:sourceCharacters]{\lexicalnonterminal{SourceCharacters}} \tagbegin{but no embedded}{\scriptsize\verb`"`}\tagend{} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:xmlSingleStringCharacters}\lexicalnonterminal{XMLSingleStringCharacters}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:sourceCharacters]{\lexicalnonterminal{SourceCharacters}} \tagbegin{but no embedded}{\scriptsize\verb`'`}\tagend{} 
% \end{tabbing}
% \vspace*{5pt}

\section{Syntactic Grammar}\label{sec:syngrammar}


% \phantomsection\label{nt:UnqualifiedName}\nonterminal{UnqualifiedName}\marknote
% \vspace*{-5pt}
% \begin{tabbing}
% \end{tabbing}
% \vspace*{5pt}
% \vspace*{-5pt}
% \begin{notes}

%     Unlike in AS3, where an {\slantsffootnote UnqualifiedName} represents an
%     \lexicalnonterminal{Identifier} that is (implicitly) associated with a
%     set of open namespaces in scope, in AS4 an {\slantsffootnote
%       UnqualifiedName} either exists on its own or is (implicitly)
%     associated with some package name.


% \end{notes}

% \phantomsection\label{nt:QualifiedName}\nonterminal{QualifiedName}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:PackageName]{\nonterminal{PackageName}} \verb`.` \hyperref[nt:identifier]{\lexicalnonterminal{Identifier}} 
% %\grammarprod \hyperref[nt:NamespaceExpression]{\nonterminal{NamespaceExpression}} \verb`::` \hyperref[nt:QualifiedNameIdentifier]{\nonterminal{QualifiedNameIdentifier}} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:QualifiedNameIdentifier}\nonterminal{QualifiedNameIdentifier}\marknote
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \verb`*` 
% \grammarprod \hyperref[nt:identifier]{\lexicalnonterminal{Identifier}} 
% \grammarprod \hyperref[nt:Brackets]{\nonterminal{Brackets}} 
% \end{tabbing}
% \vspace*{5pt}
% \vspace*{-5pt}
% \begin{notes}

%     \prodnum{1}
%     \verb`*` represents an \lexicalnonterminal{Identifier} wildcard and matches all \lexicalnonterminal{Identfier}s that occur in the context that it occurs.

%     \prodnum{3}
%     {\slantsffootnote Brackets} represents an {\slantsffootnote UnqualifiedName} with an {\slantsffootnote Identifier} that is
%     computed at run time.


% \end{notes}


% \phantomsection\label{nt:XMLAttributeName}\nonterminal{XMLAttributeName}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \verb`@` \verb`*` 
% \grammarprod \verb`@` \hyperref[nt:Name]{\nonterminal{Name}} 
% \grammarprod \verb`@` \hyperref[nt:Brackets]{\nonterminal{Brackets}} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:NamespaceName}\nonterminal{NamespaceName}\marknote
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:RestrictedName]{\nonterminal{RestrictedName}} 
% \end{tabbing}
% \vspace*{5pt}
% \vspace*{-5pt}
% \begin{notes}

%     {\slantsffootnote NamespaceName} is called out in the grammar because it is a special use of
%     {\slantsffootnote RestrictedName} that resolves to a namespace value at compile time.


% \end{notes}

% \phantomsection\label{nt:RestrictedName}\nonterminal{RestrictedName}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:UnqualifiedName]{\nonterminal{UnqualifiedName}} 
% \grammarprod \hyperref[nt:ReservedNamespace]{\nonterminal{ReservedNamespace}} \verb`::` \hyperref[nt:Identifier]{\nonterminal{Identifier}} 
% \grammarprod \hyperref[nt:PackageName]{\nonterminal{PackageName}} \verb`.` \hyperref[nt:Identifier]{\nonterminal{Identifier}} 
% \grammarprod \hyperref[nt:RestrictedName]{\nonterminal{RestrictedName}} \verb`::` \hyperref[nt:Identifier]{\nonterminal{Identifier}} 
% \grammarprod \verb`(` \hyperref[nt:RestrictedName]{\nonterminal{RestrictedName}} \verb`)` 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:NamespaceExpression}\nonterminal{NamespaceExpression}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \verb`*` 
% \grammarprod \hyperref[nt:Name]{\nonterminal{Name}} 
% \grammarprod \hyperref[nt:ReservedNamespace]{\nonterminal{ReservedNamespace}} 
% \grammarprod \hyperref[nt:ParenExpression]{\nonterminal{ParenExpression}} 
% \end{tabbing}
% \vspace*{5pt}

\subsection{Types}

\phantomsection\label{nt:TypeName}\nonterminal{TypeName}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:identifier]{\lexicalnonterminal{Identifier}} 
\grammarprod \hyperref[nt:PackageName]{\nonterminal{PackageName}} \verb`.` \hyperref[nt:identifier]{\lexicalnonterminal{Identifier}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:TypedBinding}\nonterminal{TypedBinding}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:identifier]{\lexicalnonterminal{Identifier}} 
\grammarprod \hyperref[nt:identifier]{\lexicalnonterminal{Identifier}} \verb`:` \hyperref[nt:Type]{\nonterminal{Type}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:Type}\nonterminal{Type}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`*` 
\grammarprod \hyperref[nt:StaticType]{\nonterminal{StaticType}}
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:StaticType}\nonterminal{StaticType}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:NominalType]{\nonterminal{NominalType}} 
\grammarprod \hyperref[nt:ArrayType]{\nonterminal{ArrayType}} 
\grammarprod \hyperref[nt:FunctionType]{\nonterminal{FunctionType}} 
\end{tabbing}
\vspace*{5pt}
\begin{notes}
{\slantsffootnote ArrayType} and {\slantsffootnote FunctionType} are new
forms of types in AS4.

\end{notes}

\phantomsection\label{nt:NominalType}\nonterminal{NominalType}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:TypeName]{\nonterminal{TypeName}} 
\grammarprod \hyperref[nt:GenericType]{\nonterminal{GenericType}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:GenericType}\nonterminal{GenericType}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:TypeName]{\nonterminal{TypeName}} \verb`<` \hyperref[nt:Types]{\nonterminal{Types}} \verb`>` 
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}
\begin{notes}
  In AS4, the {\slantsffootnote TypeName} must reference
  the built-in definition of \terminal{ArrayList} (which replaces AS3's
  \terminal{Vector}) or \terminal{Array} (which is new in AS4)  and the
  {\slantsffootnote Types} must be a {\slantsffootnote
    Type}. Furthermore, the punctuator following the
  {\slantsffootnote TypeName} in AS4 is \verb'<', which replaces the
  non-traditional \verb'.<' in AS3.


\end{notes}

\phantomsection\label{nt:FunctionType}\nonterminal{FunctionType}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb'(' \hyperref[nt:Types]{\nonterminal{Types}}\tag{opt} \verb`)`
\verb`=>` \hyperref[nt:Type]{\nonterminal{Type}}
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:Types}\nonterminal{Types}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:Type]{\nonterminal{Type}}
\grammarprod \hyperref[nt:Type]{\nonterminal{Type}} \verb',' \hyperref[nt:Types]{\nonterminal{Types}}
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:ArrayType}\nonterminal{ArrayType}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb'[' \verb']' \hyperref[nt:Type]{\nonterminal{Type}} 
\end{tabbing}
\vspace*{5pt}

\subsection{Primary Expressions}

\phantomsection\label{nt:ArrayInitializer}\nonterminal{ArrayInitializer}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{new} \hyperref[nt:Dimension]{\nonterminal{Dimension}}
\hyperref[nt:Type]{\nonterminal{Type}} 
\grammarprod \terminal{new} \hyperref[nt:ArrayType]{\nonterminal{ArrayType}} \verb`{` \hyperref[nt:ArrayElements]{\nonterminal{ArrayElements}}\tag{opt} \verb`}` 
%\grammarprod \verb`[` \hyperref[nt:ArrayElements]{\nonterminal{ArrayElements}}\tag{opt} \verb`]` 
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}
\begin{notes}
    AS4 introduces new syntactic forms for array initializers. The
    forms of array initializers are restricted so that only
    single-dimensional array initializers can benefit from the special syntax. The
    introduction of multi-dimensional arrays in a future version will
    generalize this special syntax.

\end{notes}

\phantomsection\label{nt:Dimension}\nonterminal{Dimension}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`[` \hyperref[nt:Expression]{\nonterminal{Expression}} \verb`]` %\hyperref[nt:Dimensions]{\nonterminal{Dimensions}}\tag{opt}
\end{tabbing}
\vspace*{5pt}

% \phantomsection\label{nt:Elements}\nonterminal{InitializerElements}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:Element]{\nonterminal{InitializerElement}} 
% \grammarprod \hyperref[nt:Element]{\nonterminal{InitializerElement}} \verb`,` \hyperref[nt:Elements]{\nonterminal{InitializerElements}}\tag{opt} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:Element}\nonterminal{InitializerElement}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:Expression]{\nonterminal{Expression}}
% \grammarprod \verb`{` \hyperref[nt:Elements]{\nonterminal{InitializerElements}}\tag{opt} \verb`}` 
% \end{tabbing}
% \vspace*{5pt}

\phantomsection\label{nt:ArrayElements}\nonterminal{ArrayElements}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:Expression]{\nonterminal{Expression}} 
%\grammarprod \verb`,` \hyperref[nt:ArrayElements]{\nonterminal{ArrayElements}}\tag{opt} 
\grammarprod \hyperref[nt:Expression]{\nonterminal{Expression}} \verb`,` \hyperref[nt:ArrayElements]{\nonterminal{ArrayElements}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}

% \phantomsection\label{nt:VectorInitializer}\nonterminal{VectorInitializer}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \terminal{new} \verb`<` \hyperref[nt:Type]{\nonterminal{Type}} \verb`>` \verb`[` \hyperref[nt:VectorElements]{\nonterminal{VectorElements}}\tag{opt} \verb`]` 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:VectorElements}\nonterminal{VectorElements}\marknote
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:VectorElement]{\nonterminal{VectorElement}} 
% \grammarprod \hyperref[nt:VectorElement]{\nonterminal{VectorElement}} \verb`,` \hyperref[nt:VectorElements]{\nonterminal{VectorElements}}\tag{opt} 
% \end{tabbing}
% \vspace*{5pt}
% \vspace*{-5pt}
% \begin{notes}
 
%     {\slantsffootnote VectorElements} does not allow holes (unlike
%     {\slantsffootnote ArrayElements}), but a trailing comma is allowed. 


% \end{notes}

% \phantomsection\label{nt:VectorElement}\nonterminal{VectorElement}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:Expression]{\nonterminal{Expression}} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:PropertyMapInitializer}\nonterminal{PropertyMapInitializer}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \verb`{` \hyperref[nt:KeyValuePairs]{\nonterminal{KeyValuePairs}}\tag{opt} \verb`}` 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:KeyValuePairs}\nonterminal{KeyValuePairs}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:KeyValuePair]{\nonterminal{KeyValuePair}} 
% \grammarprod \hyperref[nt:KeyValuePair]{\nonterminal{KeyValuePair}} \verb`,` \hyperref[nt:KeyValuePairs]{\nonterminal{KeyValuePairs}}\tag{opt}
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:KeyValuePair}\nonterminal{KeyValuePair}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:stringLiteral]{\lexicalnonterminal{StringLiteral}}  \verb`:` \hyperref[nt:Expression]{\nonterminal{Expression}} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:FieldName}\nonterminal{FieldName}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:identifier]{\lexicalnonterminal{Identifier}} 
% \grammarprod 
% \grammarprod \hyperref[nt:numericLiteral]{\lexicalnonterminal{NumericLiteral}} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:XMLInitializer}\nonterminal{XMLInitializer}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:xmlMarkup]{\lexicalnonterminal{XMLMarkup}} 
% \grammarprod \hyperref[nt:XMLElement]{\nonterminal{XMLElement}} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:XMLElement}\nonterminal{XMLElement}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \verb`<` \hyperref[nt:XMLTagContent]{\nonterminal{XMLTagContent}} \hyperref[nt:xmlWhitespace]{\lexicalnonterminal{XMLWhitespace}}\tag{opt} \verb`/>` 
% \grammarprod \verb`<` \hyperref[nt:XMLTagContent]{\nonterminal{XMLTagContent}} \hyperref[nt:xmlWhitespace]{\lexicalnonterminal{XMLWhitespace}}\tag{opt} \verb`>` \hyperref[nt:XMLElementContent]{\nonterminal{XMLElementContent}}\tag{opt} \verb`</` \hyperref[nt:XMLTagName]{\nonterminal{XMLTagName}} \hyperref[nt:xmlWhitespace]{\lexicalnonterminal{XMLWhitespace}}\tag{opt} \verb`>` 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:XMLTagContent}\nonterminal{XMLTagContent}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:XMLTagName]{\nonterminal{XMLTagName}} \hyperref[nt:XMLAttributes]{\nonterminal{XMLAttributes}}\tag{opt} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:XMLTagName}\nonterminal{XMLTagName}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \verb`{` \hyperref[nt:Expression]{\nonterminal{Expression}} \verb`}` 
% \grammarprod \hyperref[nt:xmlName]{\lexicalnonterminal{XMLName}} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:XMLAttributes}\nonterminal{XMLAttributes}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:xmlWhitespace]{\lexicalnonterminal{XMLWhitespace}} \verb`{` \hyperref[nt:Expression]{\nonterminal{Expression}} \verb`}` 
% \grammarprod \hyperref[nt:XMLAttribute]{\nonterminal{XMLAttribute}} \hyperref[nt:XMLAttributes]{\nonterminal{XMLAttributes}}\tag{opt} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:XMLAttribute}\nonterminal{XMLAttribute}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:xmlWhitespace]{\lexicalnonterminal{XMLWhitespace}} \hyperref[nt:xmlName]{\lexicalnonterminal{XMLName}} \hyperref[nt:xmlWhitespace]{\lexicalnonterminal{XMLWhitespace}}\tag{opt} \verb`=` \hyperref[nt:xmlWhitespace]{\lexicalnonterminal{XMLWhitespace}}\tag{opt} \verb`{` \hyperref[nt:Expression]{\nonterminal{Expression}} \verb`}` 
% \grammarprod \hyperref[nt:xmlWhitespace]{\lexicalnonterminal{XMLWhitespace}} \hyperref[nt:xmlName]{\lexicalnonterminal{XMLName}} \hyperref[nt:xmlWhitespace]{\lexicalnonterminal{XMLWhitespace}}\tag{opt} \verb`=` \hyperref[nt:xmlWhitespace]{\lexicalnonterminal{XMLWhitespace}}\tag{opt} \hyperref[nt:xmlAttributeValue]{\lexicalnonterminal{XMLAttributeValue}} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:XMLElementContent}\nonterminal{XMLElementContent}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \verb`{` \hyperref[nt:Expression]{\nonterminal{Expression}} \verb`}` \hyperref[nt:XMLElementContent]{\nonterminal{XMLElementContent}}\tag{opt} 
% \grammarprod \hyperref[nt:xmlMarkup]{\lexicalnonterminal{XMLMarkup}} \hyperref[nt:XMLElementContent]{\nonterminal{XMLElementContent}}\tag{opt} 
% \grammarprod \hyperref[nt:xmlText]{\lexicalnonterminal{XMLText}} \hyperref[nt:XMLElementContent]{\nonterminal{XMLElementContent}}\tag{opt} 
% \grammarprod \hyperref[nt:XMLElement]{\nonterminal{XMLElement}} \hyperref[nt:XMLElementContent]{\nonterminal{XMLElementContent}}\tag{opt} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:XMLListInitializer}\nonterminal{XMLListInitializer}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \verb`<` \verb`>` \hyperref[nt:XMLElementContent]{\nonterminal{XMLElementContent}}\tag{opt} \verb`</` \verb`>` 
% \end{tabbing}
% \vspace*{5pt}

\phantomsection\label{nt:FunctionInitializer}\nonterminal{FunctionInitializer}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{function} \hyperref[nt:identifier]{\lexicalnonterminal{Identifier}}\tag{opt} \hyperref[nt:FunctionBody]{\nonterminal{FunctionBody}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:FunctionSignature}\nonterminal{FunctionSignature}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`(` \hyperref[nt:Parameters]{\nonterminal{Parameters}}\tag{opt} \verb`)` \hyperref[nt:ResultType]{\nonterminal{ResultType}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:Parameters}\nonterminal{Parameters}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:Parameter]{\nonterminal{Parameter}} 
\grammarprod \hyperref[nt:OptionalParameters]{\nonterminal{OptionalParameters}} 
\grammarprod \hyperref[nt:Parameter]{\nonterminal{Parameter}} \verb`,` \hyperref[nt:Parameters]{\nonterminal{Parameters}} 
\end{tabbing}
\vspace*{5pt}
\begin{notes}
AS4, unlike AS3, does not support rest parameters.

\end{notes}

\phantomsection\label{nt:OptionalParameters}\nonterminal{OptionalParameters}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:OptionalParameter]{\nonterminal{OptionalParameter}} 
\grammarprod \hyperref[nt:OptionalParameter]{\nonterminal{OptionalParameter}} \verb`,` \hyperref[nt:OptionalParameters]{\nonterminal{OptionalParameters}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:OptionalParameter}\nonterminal{OptionalParameter}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:Parameter]{\nonterminal{Parameter}} \verb`=` \hyperref[nt:Expression]{\nonterminal{Expression}} 
\end{tabbing}
\vspace*{5pt}

% \vspace*{-5pt}
% \begin{notes}

%     \prodnum{2} If a {\slantsffootnote RestParameter} has a
%     {\slantsffootnote Type}, the {\slantsffootnote Type} must
%     be \terminal{Array}. (In
%   fact, the {\slantsffootnote Type} must reference the built-in definition of \terminal{Array}.)


% \end{notes}

\phantomsection\label{nt:Parameter}\nonterminal{Parameter}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:TypedBinding]{\nonterminal{TypedBinding}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:ResultType}\nonterminal{ResultType}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`:` \terminal{void} 
\grammarprod \verb`:` \hyperref[nt:Type]{\nonterminal{Type}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:FunctionBody}\nonterminal{FunctionBody}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:FunctionSignature]{\nonterminal{FunctionSignature}} \hyperref[nt:Block]{\nonterminal{Block}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:PrimaryExpression}\nonterminal{PrimaryExpression}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{null} 
\grammarprod \terminal{true} 
\grammarprod \terminal{false} 
\grammarprod \terminal{this} 
\grammarprod \hyperref[nt:numericLiteral]{\lexicalnonterminal{NumericLiteral}} 
\grammarprod \hyperref[nt:stringLiteral]{\lexicalnonterminal{StringLiteral}} 
\grammarprod \hyperref[nt:regularExpressionLiteral]{\lexicalnonterminal{RegularExpressionLiteral}} 
\grammarprod \hyperref[nt:ArrayInitializer]{\nonterminal{ArrayInitializer}} 
%\grammarprod \hyperref[nt:VectorInitializer]{\nonterminal{VectorInitializer}} 
%\grammarprod \hyperref[nt:PropertyMapInitializer]{\nonterminal{PropertyMapInitializer}} 
%\grammarprod \hyperref[nt:XMLInitializer]{\nonterminal{XMLInitializer}} 
%\grammarprod \hyperref[nt:XMLListInitializer]{\nonterminal{XMLListInitializer}} 
\grammarprod \hyperref[nt:FunctionInitializer]{\nonterminal{FunctionInitializer}} 
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}
\begin{notes}
In AS3, primary expressions included {\slantsffootnote VectorInitializer}s,
{\slantsffootnote XMLInitializer}s, and {\slantsffootnote XMLListInitializer}s; these are no longer
supported in AS4. Furthermore, {\slantsffootnote
  ObjectInitializer}s are repurposed in AS4.


\end{notes}

\subsection{Expressions}

\phantomsection\label{nt:ParenExpression}\nonterminal{ParenExpression}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`(` \hyperref[nt:Expression]{\nonterminal{Expression}} \verb`)` 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:Arguments}\nonterminal{Arguments}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`(` \hyperref[nt:ArgumentExpressions]{\nonterminal{ArgumentExpressions}}\tag{opt} \verb`)` 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:ArgumentExpressions}\nonterminal{ArgumentExpressions}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:Expression]{\nonterminal{Expression}} 
\grammarprod \hyperref[nt:ArgumentExpressions]{\nonterminal{ArgumentExpressions}} \verb`,` \hyperref[nt:Expression]{\nonterminal{Expression}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:MemberOperator}\nonterminal{MemberOperator}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`.` \hyperref[nt:Identifier]{\lexicalnonterminal{Identifier}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:IndexOperator}\nonterminal{IndexOperator}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`[` \hyperref[nt:Expression]{\nonterminal{Expression}} \verb`]` 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:SuperExpression}\nonterminal{SuperExpression}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{super}
%\hyperref[nt:ParenExpression]{\nonterminal{ParenExpression}}\tag{opt} 
\hyperref[nt:MemberOperator]{\nonterminal{MemberOperator}} 
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}

\phantomsection\label{nt:ReferenceExpression}\nonterminal{ReferenceExpression}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:Identifier]{\lexicalnonterminal{Identifier}}
\grammarprod \hyperref[nt:NominalType]{\nonterminal{NominalType}} \hyperref[nt:MemberOperator]{\nonterminal{MemberOperator}} 
\grammarprod \hyperref[nt:BaseExpression]{\nonterminal{BaseExpression}} \hyperref[nt:MemberOperator]{\nonterminal{MemberOperator}} 
\grammarprod \hyperref[nt:BaseExpression]{\nonterminal{BaseExpression}} \hyperref[nt:IndexOperator]{\nonterminal{IndexOperator}} 
\end{tabbing}
\vspace*{5pt}

\begin{notes}
There is a parsing ambiguity between {\slantsffootnote PackageName}
\terminal{.} \lexicalnonterminal{Identifier} \terminal{.}
\lexicalnonterminal{Identifier} (produced by
{\slantsffootnote NominalType}
{\slantsffootnote MemberOperator}) and {\slantsffootnote ReferenceExpression}\terminal{.} \lexicalnonterminal{Identifier} \terminal{.}
\lexicalnonterminal{Identifier} (produced by
{\slantsffootnote BaseExpression} {\slantsffootnote MemberOperator}), when both {\slantsffootnote
  PackageName} and {\slantsffootnote ReferenceExpression} are
\lexicalnonterminal{Identifier}s. This ambiguity is resolved by
prefering the latter syntax tree during parsing, and if required, re-interpreting
it as the former syntax tree later when knowledge
of package names is available.

\end{notes}

\phantomsection\label{nt:TypeExpression}\nonterminal{TypeExpression}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb':' \hyperref[nt:StaticType]{\nonterminal{StaticType}}
\end{tabbing}
\vspace*{5pt}

\begin{notes}
In AS3, a {\slantsffootnote StaticType} could appear as a stand-alone
{\slantsffootnote Expression}, and would evaluate to a reified object
corresponding to the type. In this model, static method calls on such a
type were
desugared to instance method calls on the reified object. In contrast,
in AS4 static method calls on a type are distinguished from instance method
calls on the reified object. Accordingly, {\slantsffootnote StaticType}s cannot appear
as stand-alone {\slantsffootnote Expression}s in AS4, instead a new
syntactic form is introduced for {\slantsffootnote TypeExpression}s that
evaluate to reified objects corresponding to types.

\end{notes}

\phantomsection\label{nt:NewExpression}\nonterminal{NewExpression}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{new}
\hyperref[nt:ObjectInitializer]{\nonterminal{ObjectInitializer}}
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:ObjectInitializer}\nonterminal{ObjectInitializer}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD
\hyperref[nt:NominalType]{\nonterminal{NominalType}}
\hyperref[nt:Arguments]{\nonterminal{Arguments}}
\grammarprod
\hyperref[nt:NominalType]{\nonterminal{NominalType}} \tagbegin{lookahead not}{\scriptsize\verb`(`}\tagend{}
\grammarprod 
\hyperref[nt:NominalType]{\nonterminal{NominalType}}
\hyperref[nt:Arguments]{\nonterminal{Arguments}}\tag{opt} \verb'{'
  \hyperref[nt:FieldValuePairs]{\nonterminal{FieldValuePairs}} \verb'}'
\end{tabbing}
\vspace*{5pt}

\begin{notes}
AS4 introduces a new syntactic form for
{\slantsffootnote ObjectInitializer}s which can not only call constructors
but also initialize fields.

\end{notes}

\phantomsection\label{nt:FieldValuePairs}\nonterminal{FieldValuePairs}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:FieldValuePair]{\nonterminal{FieldValuePair}} 
\grammarprod \hyperref[nt:FieldValuePair]{\nonterminal{FieldValuePair}} \verb`,` \hyperref[nt:FieldValuePairs]{\nonterminal{FieldValuePairs}}\tag{opt}
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:FieldValuePair}\nonterminal{FieldValuePair}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:Identifier]{\lexicalnonterminal{Identifier}}  \verb`=` \hyperref[nt:Expression]{\nonterminal{Expression}} 
\end{tabbing}
\vspace*{5pt}


\phantomsection\label{nt:BaseExpression}\nonterminal{BaseExpression}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:PrimaryExpression]{\nonterminal{PrimaryExpression}} 
\grammarprod \hyperref[nt:SuperExpression]{\nonterminal{SuperExpression}} 
\grammarprod \hyperref[nt:NewExpression]{\nonterminal{NewExpression}} 
%\grammarprod \hyperref[nt:MetadataExpression]{\nonterminal{MetadataExpression}} 
\grammarprod \hyperref[nt:ReferenceExpression]{\nonterminal{ReferenceExpression}} 
\grammarprod \hyperref[nt:TypeExpression]{\nonterminal{TypeExpression}} 
\grammarprod \hyperref[nt:ParenExpression]{\nonterminal{ParenExpression}} 
\grammarprod \hyperref[nt:BaseExpression]{\nonterminal{BaseExpression}} \hyperref[nt:Arguments]{\nonterminal{Arguments}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:UnaryExpression}\nonterminal{UnaryExpression}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:BaseExpression ]{\nonterminal{BaseExpression }} 
\grammarprod \hyperref[nt:BaseExpression]{\nonterminal{BaseExpression}} \terminal{is} \hyperref[nt:StaticlType]{\nonterminal{StaticType}} 
\grammarprod \hyperref[nt:BaseExpression]{\nonterminal{BaseExpression}} \terminal{as} \hyperref[nt:Type]{\nonterminal{Type}} 
\grammarprod \hyperref[nt:ReferenceExpression]{\nonterminal{ReferenceExpression}} \verb`++` 
\grammarprod \hyperref[nt:ReferenceExpression]{\nonterminal{ReferenceExpression}} \verb`--` 
%\grammarprod \terminal{delete} \hyperref[nt:ReferenceExpression]{\nonterminal{ReferenceExpression}} 
\grammarprod \verb`++` \hyperref[nt:ReferenceExpression]{\nonterminal{ReferenceExpression}} 
\grammarprod \verb`--` \hyperref[nt:ReferenceExpression]{\nonterminal{ReferenceExpression}} 
\grammarprod \verb`+` \hyperref[nt:UnaryExpression]{\nonterminal{UnaryExpression}} 
\grammarprod \verb`-` \hyperref[nt:UnaryExpression]{\nonterminal{UnaryExpression}} 
\grammarprod \verb`~` \hyperref[nt:UnaryExpression]{\nonterminal{UnaryExpression}} 
\grammarprod \verb`!` \hyperref[nt:UnaryExpression]{\nonterminal{UnaryExpression}} 
\end{tabbing}
\vspace*{5pt}
\begin{notes}
AS4 changes the operator precedence ordering for \verb'is' and
\verb'as' to reduce unintentional errors. The semantics of \verb'as' is also changed to mimic AS3's
function call syntax for coercions, which is in turn removed.

\end{notes}
\phantomsection\label{nt:MultiplicativeExpression}\nonterminal{MultiplicativeExpression}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:UnaryExpression]{\nonterminal{UnaryExpression}} 
\grammarprod \hyperref[nt:MultiplicativeExpression]{\nonterminal{MultiplicativeExpression}} \verb`*` \hyperref[nt:UnaryExpression]{\nonterminal{UnaryExpression}} 
\grammarprod \hyperref[nt:MultiplicativeExpression]{\nonterminal{MultiplicativeExpression}} \verb`/` \hyperref[nt:UnaryExpression]{\nonterminal{UnaryExpression}} 
\grammarprod \hyperref[nt:MultiplicativeExpression]{\nonterminal{MultiplicativeExpression}} \verb`%` \hyperref[nt:UnaryExpression]{\nonterminal{UnaryExpression}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:AdditiveExpression}\nonterminal{AdditiveExpression}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:MultiplicativeExpression]{\nonterminal{MultiplicativeExpression}} 
\grammarprod \hyperref[nt:AdditiveExpression]{\nonterminal{AdditiveExpression}} \verb`+` \hyperref[nt:MultiplicativeExpression]{\nonterminal{MultiplicativeExpression}} 
\grammarprod \hyperref[nt:AdditiveExpression]{\nonterminal{AdditiveExpression}} \verb`-` \hyperref[nt:MultiplicativeExpression]{\nonterminal{MultiplicativeExpression}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:ShiftExpression}\nonterminal{ShiftExpression}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:AdditiveExpression ]{\nonterminal{AdditiveExpression }} 
\grammarprod \hyperref[nt:ShiftExpression]{\nonterminal{ShiftExpression}} \verb`<<` \hyperref[nt:AdditiveExpression]{\nonterminal{AdditiveExpression}} 
\grammarprod \hyperref[nt:ShiftExpression]{\nonterminal{ShiftExpression}} \verb`>>` \hyperref[nt:AdditiveExpression]{\nonterminal{AdditiveExpression}} 
%\grammarprod \hyperref[nt:ShiftExpression]{\nonterminal{ShiftExpression}} \verb`>>>` \hyperref[nt:AdditiveExpression]{\nonterminal{AdditiveExpression}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:RelationalExpression}\nonterminal{RelationalExpression}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:ShiftExpression]{\nonterminal{ShiftExpression}} 
\grammarprod \hyperref[nt:RelationalExpression]{\nonterminal{RelationalExpression}} \verb`<` \hyperref[nt:ShiftExpression]{\nonterminal{ShiftExpression}} 
\grammarprod \hyperref[nt:RelationalExpression]{\nonterminal{RelationalExpression}} \verb`>` \hyperref[nt:ShiftExpression]{\nonterminal{ShiftExpression}} 
\grammarprod \hyperref[nt:RelationalExpression]{\nonterminal{RelationalExpression}} \verb`<=` \hyperref[nt:ShiftExpression]{\nonterminal{ShiftExpression}} 
\grammarprod \hyperref[nt:RelationalExpression]{\nonterminal{RelationalExpression}} \verb`>=` \hyperref[nt:ShiftExpression]{\nonterminal{ShiftExpression}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:EqualityExpression}\nonterminal{EqualityExpression}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:RelationalExpression]{\nonterminal{RelationalExpression}} 
\grammarprod \hyperref[nt:EqualityExpression]{\nonterminal{EqualityExpression}} \verb`==` \hyperref[nt:RelationalExpression]{\nonterminal{RelationalExpression}} 
\grammarprod \hyperref[nt:EqualityExpression]{\nonterminal{EqualityExpression}} \verb`!=` \hyperref[nt:RelationalExpression]{\nonterminal{RelationalExpression}} 
\grammarprod \hyperref[nt:EqualityExpression]{\nonterminal{EqualityExpression}} \verb`===` \hyperref[nt:RelationalExpression]{\nonterminal{RelationalExpression}} 
\grammarprod \hyperref[nt:EqualityExpression]{\nonterminal{EqualityExpression}} \verb`!==` \hyperref[nt:RelationalExpression]{\nonterminal{RelationalExpression}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:BitwiseANDExpression}\nonterminal{BitwiseANDExpression}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:EqualityExpression]{\nonterminal{EqualityExpression}} 
\grammarprod \hyperref[nt:BitwiseANDExpression]{\nonterminal{BitwiseANDExpression}} \verb`&` \hyperref[nt:EqualityExpression]{\nonterminal{EqualityExpression}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:BitwiseXORExpression}\nonterminal{BitwiseXORExpression}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:BitwiseANDExpression]{\nonterminal{BitwiseANDExpression}} 
\grammarprod \hyperref[nt:BitwiseXORExpression]{\nonterminal{BitwiseXORExpression}} \verb`^` \hyperref[nt:BitwiseANDExpression]{\nonterminal{BitwiseANDExpression}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:BitwiseORExpression}\nonterminal{BitwiseORExpression}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:BitwiseXORExpression]{\nonterminal{BitwiseXORExpression}} 
\grammarprod \hyperref[nt:BitwiseORExpression]{\nonterminal{BitwiseORExpression}} \verb`|` \hyperref[nt:BitwiseXORExpression]{\nonterminal{BitwiseXORExpression}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:LogicalANDExpression}\nonterminal{LogicalANDExpression}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:BitwiseORExpression]{\nonterminal{BitwiseORExpression}} 
\grammarprod \hyperref[nt:LogicalANDExpression]{\nonterminal{LogicalANDExpression}} \verb`&&` \hyperref[nt:BitwiseORExpression]{\nonterminal{BitwiseORExpression}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:LogicalORExpression}\nonterminal{LogicalORExpression}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:LogicalANDExpression]{\nonterminal{LogicalANDExpression}} 
\grammarprod \hyperref[nt:LogicalORExpression]{\nonterminal{LogicalORExpression}} \verb`||` \hyperref[nt:LogicalANDExpression]{\nonterminal{LogicalANDExpression}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:Expression}\nonterminal{Expression}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:LogicalORExpression]{\nonterminal{LogicalORExpression}} 
\grammarprod \hyperref[nt:LogicalORExpression]{\nonterminal{LogicalORExpression}} \verb`?` \hyperref[nt:Expression]{\nonterminal{Expression}} \verb`:` \hyperref[nt:Expression]{\nonterminal{Expression}} 
\end{tabbing}
\vspace*{5pt}

\subsection{Statements}

\phantomsection\label{nt:Statement}\nonterminal{Statement}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:BreakStatement]{\nonterminal{BreakStatement}} 
\grammarprod \hyperref[nt:ContinueStatement]{\nonterminal{ContinueStatement}} 
\grammarprod \hyperref[nt:DeferStatement]{\nonterminal{DeferStatement}} 
\grammarprod \hyperref[nt:EmptyStatement]{\nonterminal{EmptyStatement}} 
\grammarprod \hyperref[nt:AssignmentStatement]{\nonterminal{AssignmentStatement}} 
\grammarprod \hyperref[nt:ForStatement]{\nonterminal{ForStatement}} 
\grammarprod \hyperref[nt:IfStatement]{\nonterminal{IfStatement}} 
\grammarprod \hyperref[nt:LabeledStatement]{\nonterminal{LabeledStatement}} 
\grammarprod \hyperref[nt:BlockStatement]{\nonterminal{BlockStatement}} 
\grammarprod \hyperref[nt:ReturnStatement]{\nonterminal{ReturnStatement}} 
\grammarprod \hyperref[nt:SuperStatement]{\nonterminal{SuperStatement}} 
\grammarprod \hyperref[nt:SwitchStatement]{\nonterminal{SwitchStatement}} 
\grammarprod \hyperref[nt:ThrowStatement]{\nonterminal{ThrowStatement}} 
\grammarprod \hyperref[nt:TryStatement]{\nonterminal{TryStatement}} 
\grammarprod \hyperref[nt:WhileStatement]{\nonterminal{WhileStatement}} 
\grammarprod \hyperref[nt:DoStatement]{\nonterminal{DoStatement}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:BlockStatement}\nonterminal{BlockStatement}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:Block]{\nonterminal{Block}} 
%\grammarprod \hyperref[nt:VariableDefinition]{\nonterminal{VariableDefinition}} 
\end{tabbing}
\vspace*{5pt}
\begin{notes}
AS4 introduces block scoping, which replaces the non-traditional scoping rules of AS3
that involved hoisting. Accordingly, AS4 also introduces a new
syntactic form for block statements.

\end{notes}

\phantomsection\label{nt:Block}\nonterminal{Block}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`{` \hyperref[nt:Directives]{\nonterminal{Directives}}\tag{opt} \verb`}` 
\end{tabbing}
\vspace*{5pt}

% \phantomsection\label{nt:Semicolon }\nonterminal{Semicolon }\marknote
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \verb`;` 
% \grammarprod \hyperref[nt:VirtualSemicolon]{\nonterminal{VirtualSemicolon}} 
% \grammarprod $\epsilon$ 
% \end{tabbing}
% \vspace*{5pt}
% \vspace*{-5pt}
% \begin{notes}

%     \prodnum{3} This rule involves a syntactic ambiguity around
%     $\epsilon$, which is disambiguated by a side condition specified in 5(3).


% \end{notes}

% \phantomsection\label{nt:VirtualSemicolon}\nonterminal{VirtualSemicolon}\marknote
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD $\epsilon$ \condition{\textrm{followed by at least one \lexicalnonterminal{LineTerminator}, and preceded by a valid prefix that is invalidated by the following token}} 
% \end{tabbing}
% \vspace*{5pt}
% \vspace*{-5pt}
% \begin{notes}
%  If the $1^{\rm st}$ through the $n^{\rm th}$ tokens of a program
%       can be parsed but the $1^{\rm st}$ through the $n+1^{\rm th}$ tokens cannot and there is 
%       at least one line break between the $n^{\rm th}$ token and the $n+1^{\rm st}$ token, then the parser tries 
%       to parse the program again after inserting a {\slantsffootnote VirtualSemicolon} between the 
%       $n^{\rm th}$ and the $n+1^{\rm st}$ tokens. 

% \end{notes}

\phantomsection\label{nt:EmptyStatement}\nonterminal{EmptyStatement}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`;` 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:Assignment}\nonterminal{Assignment}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:Expression]{\nonterminal{Expression}} 
\grammarprod \hyperref[nt:ReferenceExpression]{\nonterminal{ReferenceExpression}} \verb`=` \hyperref[nt:Expression]{\nonterminal{Expression}} 
\grammarprod \hyperref[nt:ReferenceExpression]{\nonterminal{ReferenceExpression}} \verb`*=` \hyperref[nt:Expression]{\nonterminal{Expression}} 
\grammarprod \hyperref[nt:ReferenceExpression]{\nonterminal{ReferenceExpression}} \verb`/=` \hyperref[nt:Expression]{\nonterminal{Expression}} 
\grammarprod \hyperref[nt:ReferenceExpression]{\nonterminal{ReferenceExpression}} \verb`%=` \hyperref[nt:Expression]{\nonterminal{Expression}} 
\grammarprod \hyperref[nt:ReferenceExpression]{\nonterminal{ReferenceExpression}} \verb`+=` \hyperref[nt:Expression]{\nonterminal{Expression}} 
\grammarprod \hyperref[nt:ReferenceExpression]{\nonterminal{ReferenceExpression}} \verb`-=` \hyperref[nt:Expression]{\nonterminal{Expression}} 
\grammarprod \hyperref[nt:ReferenceExpression]{\nonterminal{ReferenceExpression}} \verb`<<=` \hyperref[nt:Expression]{\nonterminal{Expression}} 
\grammarprod \hyperref[nt:ReferenceExpression]{\nonterminal{ReferenceExpression}} \verb`>>=` \hyperref[nt:Expression]{\nonterminal{Expression}} 
%\grammarprod \hyperref[nt:ReferenceExpression]{\nonterminal{ReferenceExpression}} \verb`>>>=` \hyperref[nt:Expression]{\nonterminal{Expression}} 
\grammarprod \hyperref[nt:ReferenceExpression]{\nonterminal{ReferenceExpression}} \verb`&=` \hyperref[nt:Expression]{\nonterminal{Expression}} 
\grammarprod \hyperref[nt:ReferenceExpression]{\nonterminal{ReferenceExpression}} \verb`^=` \hyperref[nt:Expression]{\nonterminal{Expression}} 
\grammarprod \hyperref[nt:ReferenceExpression]{\nonterminal{ReferenceExpression}} \verb`|=` \hyperref[nt:Expression]{\nonterminal{Expression}} 
\grammarprod \hyperref[nt:ReferenceExpression]{\nonterminal{ReferenceExpression}} \verb`&&=` \hyperref[nt:Expression]{\nonterminal{Expression}} 
\grammarprod \hyperref[nt:ReferenceExpression]{\nonterminal{ReferenceExpression}} \verb`||=` \hyperref[nt:Expression]{\nonterminal{Expression}} 
\end{tabbing}
\vspace*{5pt}
\begin{notes}
In AS3, {\slantsffootnote Assignment}s were {\slantsffootnote
  Expression}s. In AS4, they are restricted to {\slantsffootnote
  Statement}s to reduce unintentional errors and to plan for struct
initializers and function calls with named
parameter passing in the future.

\end{notes}

\phantomsection\label{nt:Assignments}\nonterminal{Assignments}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:Assignment]{\nonterminal{Assignment}} 
\grammarprod \hyperref[nt:Assignment]{\nonterminal{Assignment}}
\verb`,` \hyperref[nt:Assignments]{\nonterminal{Assignments}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:AssignmentStatement}\nonterminal{AssignmentStatement}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \tagbegin{lookahead not}{\scriptsize\verb`{` \ortag{} \terminal{function}}\tagend{} \hyperref[nt:Assignments]{\nonterminal{Assignments}} \verb';' 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:LabeledStatement}\nonterminal{LabeledStatement}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:identifier]{\lexicalnonterminal{Identifier}} \verb`:` \hyperref[nt:Statement]{\nonterminal{Statement}} 
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}

\phantomsection\label{nt:IfStatement}\nonterminal{IfStatement}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{if} \hyperref[nt:ParenExpression]{\nonterminal{ParenExpression}} \hyperref[nt:Statement]{\nonterminal{Statement}} \tagbegin{lookahead not}{\scriptsize\verb`else`}\tagend{} 
\grammarprod \terminal{if} \hyperref[nt:ParenExpression]{\nonterminal{ParenExpression}} \hyperref[nt:Statement]{\nonterminal{Statement}} \terminal{else} \hyperref[nt:Statement]{\nonterminal{Statement}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:SwitchStatement}\nonterminal{SwitchStatement}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{switch} \hyperref[nt:ParenExpression]{\nonterminal{ParenExpression}} \verb`{` \hyperref[nt:CaseClauses]{\nonterminal{CaseClauses}}\tag{opt} \hyperref[nt:DefaultClause]{\nonterminal{DefaultClause}}\tag{opt} \verb`}` 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:CaseClauses}\nonterminal{CaseClauses}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{case} \hyperref[nt:Expression]{\nonterminal{Expression}} \verb`:` \hyperref[nt:Directives]{\nonterminal{Directives}}\tag{opt} \hyperref[nt:CaseClauses]{\nonterminal{CaseClauses}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:DefaultClause}\nonterminal{DefaultClause}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{default} \verb`:`
\hyperref[nt:Directives]{\nonterminal{Directives}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:WhileStatement}\nonterminal{WhileStatement}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{while} \hyperref[nt:ParenExpression]{\nonterminal{ParenExpression}} \hyperref[nt:Statement]{\nonterminal{Statement}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:DoStatement}\nonterminal{DoStatement}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{do}
\hyperref[nt:Statement]{\nonterminal{Statement}}
\terminal{while}
\hyperref[nt:ParenExpression]{\nonterminal{ParenExpression}} \verb';' 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:ForStatement}\nonterminal{ForStatement}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{for} \verb`(` \hyperref[nt:ForInitializer]{\nonterminal{ForInitializer}}\tag{opt} \verb`;` \hyperref[nt:Expression]{\nonterminal{Expression}}\tag{opt} \verb`;` \hyperref[nt:Assignments]{\nonterminal{Assignments}}\tag{opt} \verb`)` \hyperref[nt:Statement]{\nonterminal{Statement}} 
\end{tabbing}
\vspace*{5pt}
\begin{notes}
AS4 drops for-in and for-each-in statements. They may be reintroduced
later as special cases of a general iteration construct.

\end{notes}


\phantomsection\label{nt:ForInitializer}\nonterminal{ForInitializer}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:Assignments]{\nonterminal{Assignments}} 
\grammarprod \hyperref[nt:VariableDefinitionKind]{\nonterminal{VariableDefinitionKind}} \hyperref[nt:VariableBindings]{\nonterminal{VariableBindings}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:ContinueStatement}\nonterminal{ContinueStatement}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{continue} \verb';'
\grammarprod \terminal{continue} \hyperref[nt:identifier]{\lexicalnonterminal{Identifier}} \verb';'
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}

\phantomsection\label{nt:BreakStatement}\nonterminal{BreakStatement}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{break} \verb';'
\grammarprod \terminal{break} \hyperref[nt:identifier]{\lexicalnonterminal{Identifier}} \verb';'
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}

\phantomsection\label{nt:ReturnStatement}\nonterminal{ReturnStatement}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{return} \verb';' 
\grammarprod \terminal{return} \hyperref[nt:Expression]{\nonterminal{Expression}} \verb';'
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}

\phantomsection\label{nt:ThrowStatement}\nonterminal{ThrowStatement}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{throw} \hyperref[nt:Expression]{\nonterminal{Expression}}  \verb';'
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:TryStatement}\nonterminal{TryStatement}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{try} \hyperref[nt:Statement]{\nonterminal{Statement}} \hyperref[nt:CatchClauses]{\nonterminal{CatchClauses}} \tagbegin{lookahead not}{\scriptsize\verb`finally`}\tagend{} 
\grammarprod \terminal{try} \hyperref[nt:Statement]{\nonterminal{Statement}} \terminal{finally} \hyperref[nt:Statement]{\nonterminal{Statement}} 
\grammarprod \terminal{try} \hyperref[nt:Statement]{\nonterminal{Statement}} \hyperref[nt:CatchClauses]{\nonterminal{CatchClauses}} \terminal{finally} \hyperref[nt:Statement]{\nonterminal{Statement}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:CatchClauses}\nonterminal{CatchClauses}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:CatchClause]{\nonterminal{CatchClause}} \hyperref[nt:CatchClauses]{\nonterminal{CatchClauses}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:CatchClause}\nonterminal{CatchClause}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{catch} \verb`(` \hyperref[nt:TypedBinding]{\nonterminal{TypedBinding}} \verb`)` \hyperref[nt:Block]{\nonterminal{Block}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:SuperStatement}\nonterminal{SuperStatement}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{super} \hyperref[nt:Arguments]{\nonterminal{Arguments}}  \verb';'
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}

\phantomsection\label{nt:DeferStatement}\nonterminal{DeferStatement}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{defer} \hyperref[nt:Statement]{\nonterminal{Statement}}
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}
\begin{notes}
AS4 introduces \verb'let', and correspondingly stricter restrictions for
enforcing its semantics, to replace AS3's \verb'const'. To recover
some of the expressiveness lost due to
these restrictions as applied in constructors, AS4 also introduces defer statements.

\end{notes}



\subsection{Definitions}

% \phantomsection\label{nt:AttributedDefinition}\nonterminal{AttributedDefinition}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD
% \hyperref[nt:Attributes]{\nonterminal{Attributes}}\tag{opt} \hyperref[nt:Definition]{\nonterminal{Definition}} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:ConfigCondition}\nonterminal{ConfigCondition}\marknote
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:Identifier]{\nonterminal{Identifier}} \verb`::` \hyperref[nt:Identifier]{\nonterminal{Identifier}} 
% \end{tabbing}
% \vspace*{5pt}
% \vspace*{-5pt}
% \begin{notes}

%     A {\slantsffootnote ConfigCondition} must resolve at parse time to a boolean value (true or false). If the value of a {\slantsffootnote ConfigCondition}
%     is false, the {\slantsffootnote GroupDirective}, {\slantsffootnote Field}, {\slantsffootnote ArrayElement}, 
%     {\slantsffootnote VectorElement}, or {\slantsffootnote AttributedDefinition} in which it appears is erased from the 
%     program. If the value of the {\slantsffootnote ConfigCondition} is true, only the {\slantsffootnote ConfigCondition}
%     is erased. See 7(13).


% \end{notes}

% \phantomsection\label{nt:Flags}\nonterminal{Flags}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:Flag]{\nonterminal{Flag}}
% \grammarprod \hyperref[nt:Flag]{\nonterminal{Flag}}
% \verb','
% \hyperref[nt:Flags]{\nonterminal{Flags}}
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:Flag}\nonterminal{Flag}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:Identifier]{\lexicalnonterminal{Identifier}}
% \verb'='
% \hyperref[nt:StringLiteral]{\lexicalnonterminal{StringLiteral}}
% \grammarprod \hyperref[nt:Identifier]{\lexicalnonterminal{Identifier}}
% \verb'='
% \hyperref[nt:NumericLiteral]{\lexicalnonterminal{NumberLiteral}}
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:Attributes}\nonterminal{Attributes}\marknote
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:Attribute]{\nonterminal{Attribute}} \hyperref[nt:Attributes]{\nonterminal{Attributes}}\tag{opt} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:Attribute}\nonterminal{Attribute}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:SemanticAttribute]{\nonterminal{SemanticAttribute}}
% \grammarprod \hyperref[nt:AccessAttribute]{\nonterminal{AccessAttribute}}
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:SemanticAttribute}\nonterminal{SemanticAttribute}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \terminal{final} 
% \grammarprod \terminal{native} 
% \grammarprod \terminal{static} 
% \grammarprod \terminal{override} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:AccessAttribute}\nonterminal{AccessAttribute}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \terminal{private} 
% \grammarprod \terminal{protected} 
% \grammarprod \terminal{public} 
% \grammarprod \terminal{internal} 
% \end{tabbing}
% \vspace*{5pt}



% \phantomsection\label{nt:Definition}\nonterminal{Definition}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:VariableDefinition]{\nonterminal{VariableDefinition}} 
% \grammarprod \hyperref[nt:FunctionDefinition]{\nonterminal{FunctionDefinition}} 
% \grammarprod \hyperref[nt:ClassDefinition]{\nonterminal{ClassDefinition}} 
% \grammarprod \hyperref[nt:InterfaceDefinition]{\nonterminal{InterfaceDefinition}} 
% \end{tabbing}
% \vspace*{5pt}

\phantomsection\label{nt:VariableDefinition}\nonterminal{VariableDefinition}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:VariableDefinitionKind]{\nonterminal{VariableDefinitionKind}} \hyperref[nt:VariableBindings]{\nonterminal{VariableBindings}}  \verb';'
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}

\phantomsection\label{nt:VariableDefinitionKind}\nonterminal{VariableDefinitionKind}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{let} 
\grammarprod \terminal{var} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:VariableBindings}\nonterminal{VariableBindings}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:VariableBinding]{\nonterminal{VariableBinding}} 
\grammarprod \hyperref[nt:VariableBindings]{\nonterminal{VariableBindings}} \verb`,` \hyperref[nt:VariableBinding]{\nonterminal{VariableBinding}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:VariableBinding}\nonterminal{VariableBinding}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:TypedBinding]{\nonterminal{TypedBinding}} \hyperref[nt:VariableInitialization]{\nonterminal{VariableInitialization}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:VariableInitialization}\nonterminal{VariableInitialization}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`=` \hyperref[nt:Expression]{\nonterminal{Expression}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:FunctionDefinition}\nonterminal{FunctionDefinition}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD 
\terminal{function} \hyperref[nt:AccessorKind]{\nonterminal{AccessorKind}}\tag{opt} \hyperref[nt:identifier]{\lexicalnonterminal{Identifier}} \hyperref[nt:OptionalFunctionBody]{\nonterminal{OptionalFunctionBody}} 
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}

\phantomsection\label{nt:Attribute}\nonterminal{Attribute}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{native}
\grammarprod \terminal{final}
\grammarprod \terminal{override}
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:Static}\nonterminal{Static}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb'static'
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:AccessControl}\nonterminal{AccessControl}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{public}
\grammarprod \terminal{private}
\grammarprod \terminal{protected}
\grammarprod \terminal{internal}
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:AccessorKind}\nonterminal{AccessorKind}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{get} 
\grammarprod \terminal{set} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:OptionalFunctionBody}\nonterminal{OptionalFunctionBody}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:FunctionBody]{\nonterminal{FunctionBody}} 
\grammarprod \hyperref[nt:FunctionSignature]{\nonterminal{FunctionSignature}}  \verb';' 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:ClassDefinition}\nonterminal{ClassDefinition}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD
\terminal{class} \hyperref[nt:identifier]{\lexicalnonterminal{Identifier}} \hyperref[nt:ClassBody]{\nonterminal{ClassBody}} 
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}

\phantomsection\label{nt:ClassInheritance}\nonterminal{ClassInheritance}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{extends} \hyperref[nt:NominalType]{\nonterminal{NominalType}} 
\grammarprod \terminal{implements} \hyperref[nt:NominalTypes]{\nonterminal{NominalTypes}} 
\grammarprod \terminal{extends} \hyperref[nt:NominalType]{\nonterminal{NominalType}} \terminal{implements} \hyperref[nt:NominalTypes]{\nonterminal{NominalTypes}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:NominalTypes}\nonterminal{NominalTypes}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:NominalType]{\nonterminal{NominalType}} 
\grammarprod \hyperref[nt:NominalTypes]{\nonterminal{NominalTypes}} \verb`,` \hyperref[nt:NominalType]{\nonterminal{NominalType}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:ClassBody}\nonterminal{ClassBody}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:ClassInheritance]{\nonterminal{ClassInheritance}}\tag{opt} \verb'{'
  \hyperref[nt:ClassDirectives]{\nonterminal{ClassDirectives}} \verb'}' 

\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:InterfaceDefinition}\nonterminal{InterfaceDefinition}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{interface} \hyperref[nt:identifier]{\lexicalnonterminal{Identifier}} \hyperref[nt:InterfaceBody]{\nonterminal{InterfaceBody}} 
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}

\phantomsection\label{nt:InterfaceInheritance}\nonterminal{InterfaceInheritance}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{extends} \hyperref[nt:NominalTypes]{\nonterminal{NominalTypes}} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:InterfaceBody}\nonterminal{InterfaceBody}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:InterfaceInheritance]{\nonterminal{InterfaceInheritance}}\tag{opt} \verb'{'
  \hyperref[nt:InterfaceDirectives]{\nonterminal{InterfaceDirectives}} \verb'}' 
\end{tabbing}
\vspace*{5pt}\subsection{Directives}

\phantomsection\label{nt:Configurations}\nonterminal{Configurations}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD
\verb'#' \hyperref[nt:Identifier]{\nonterminal{Identifier}}
\verb'=' \hyperref[nt:Expression]{\nonterminal{Expression}} \verb';' 
\hyperref[nt:Configurations]{\nonterminal{Configurations}}\tag{opt}
\end{tabbing}
\vspace*{5pt}
\begin{notes}
In AS3, configuration constants were defined and used with special
namespaces. With the removal of namespaces in AS4, a new syntactic
mechanism is introduced for those purposes, and the configuration
constants are restricted to be booleans.

\end{notes}

\phantomsection\label{nt:ConfigurationExpression}\nonterminal{ConfigurationExpression}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`#` \hyperref[nt:Expression]{\nonterminal{Expression}}
\end{tabbing}
\vspace*{5pt}



\phantomsection\label{nt:Directives}\nonterminal{Directives}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:ConfigurationExpression]{\nonterminal{ConfigurationExpression}}\tag{opt} \hyperref[nt:FunctionDefinition]{\nonterminal{FunctionDefinition}}
\hyperref[nt:Directives]{\nonterminal{Directives}}\tag{opt} 
\grammarprod \hyperref[nt:ConfigurationExpression]{\nonterminal{ConfigurationExpression}}\tag{opt} \hyperref[nt:FunctionDefinition]{\nonterminal{VariableDefinition}}
\hyperref[nt:Directives]{\nonterminal{Directives}}\tag{opt} 
\grammarprod \hyperref[nt:Statement]{\nonterminal{Statement}}
\hyperref[nt:Directives]{\nonterminal{Directives}}\tag{opt} 
\grammarprod
\hyperref[nt:ConfigurationExpression]{\nonterminal{ConfigurationExpression}}
\verb'{'   
\hyperref[nt:Directives]{\nonterminal{Directives}} \verb'}'
\hyperref[nt:Directives]{\nonterminal{Directives}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:ClassDirectives}\nonterminal{ClassDirectives}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD
\hyperref[nt:ConfigurationExpression]{\nonterminal{ConfigurationExpression}}\tag{opt} \hyperref[nt:Metadata]{\nonterminal{Metadata}}\tag{opt} \hyperref[nt:Modifiers]{\nonterminal{Modifiers}}\tag{opt} \hyperref[nt:FunctionDefinition]{\nonterminal{FunctionDefinition}}
\hyperref[nt:ClassDirectives]{\nonterminal{ClassDirectives}}\tag{opt} 
\grammarprod
\hyperref[nt:ConfigurationExpression]{\nonterminal{ConfigurationExpression}}\tag{opt} \hyperref[nt:Metadata]{\nonterminal{Metadata}}\tag{opt} \hyperref[nt:Modifiers]{\nonterminal{Modifiers}}\tag{opt} \hyperref[nt:VariableDefinition]{\nonterminal{VariableDefinition}}
\hyperref[nt:ClassDirectives]{\nonterminal{ClassDirectives}}\tag{opt} 
\grammarprod
\hyperref[nt:Static]{\nonterminal{Static}}\tag{opt} \hyperref[nt:Block]{\nonterminal{Block}}
\hyperref[nt:ClassDirectives]{\nonterminal{ClassDirectives}}\tag{opt} 
\grammarprod
\hyperref[nt:ConfigurationExpression]{\nonterminal{ConfigurationExpression}}
\verb'{'   
\hyperref[nt:ClassDirectives]{\nonterminal{ClassDirectives}} \verb'}'
\hyperref[nt:ClassDirectives]{\nonterminal{ClassDirectives}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:InterfaceDirectives}\nonterminal{InterfaceDirectives}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD
\hyperref[nt:ConfigurationExpression]{\nonterminal{ConfigurationExpression}}\tag{opt} \hyperref[nt:Metadata]{\nonterminal{Metadata}}\tag{opt} \hyperref[nt:FunctionDefinition]{\nonterminal{FunctionDefinition}}
\hyperref[nt:InterfaceDirectives]{\nonterminal{InterfaceDirectives}}\tag{opt} 
\grammarprod
\hyperref[nt:ConfigurationExpression]{\nonterminal{ConfigurationExpression}}
\verb'{'   
\hyperref[nt:InterfaceDirectives]{\nonterminal{InterfaceDirectives}} \verb'}'
\hyperref[nt:InterfaceDirectives]{\nonterminal{InterfaceDirectives}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}

% \phantomsection\label{nt:MetadataExpression}\nonterminal{MetadataExpression}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \verb`@`
% \hyperref[nt:ObjectInitializer]{\nonterminal{ObjectInitializer}}
% \end{tabbing}
% \vspace*{5pt}

\phantomsection\label{nt:Metadata}\nonterminal{Metadata}\marknote
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \verb`@`
\hyperref[nt:ObjectInitializer]{\nonterminal{ObjectInitializer}}
\hyperref[nt:Metadata]{\nonterminal{Metadata}}\tag{opt}
\end{tabbing}
\vspace*{5pt}
\begin{notes}
AS4 introduces new syntax for metadata to replace AS3's syntax. The
new syntax reuses the syntax for object initializers, and as such
metadata is typechecked.

\end{notes}

% \phantomsection\label{nt:IncludeDirective}\nonterminal{IncludeDirective}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \terminal{include} \hyperref[nt:stringLiteral]{\lexicalnonterminal{StringLiteral}}  \verb';'
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:ConfigNamespaceDirective}\nonterminal{ConfigNamespaceDirective}\marknote
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \terminal{config} \nolineterminator{} \terminal{namespace} \hyperref[nt:identifier]{\lexicalnonterminal{Identifier}}  \verb';' 
% \end{tabbing}
% \vspace*{5pt}
% \vspace*{-5pt}
% \begin{notes}
%  Further syntactic restrictions on program configuration constructs
% appear in Section 7.1.


% \end{notes}

\phantomsection\label{nt:PackageName}\nonterminal{PackageName}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \hyperref[nt:identifier]{\lexicalnonterminal{Identifier}} 
\grammarprod \hyperref[nt:PackageName]{\nonterminal{PackageName}} \verb`.` \hyperref[nt:identifier]{\lexicalnonterminal{Identifier}} 
\end{tabbing}
\vspace*{5pt}
\vspace*{-5pt}

% \phantomsection\label{nt:Package}\nonterminal{Package}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \terminal{package} \hyperref[nt:PackageName]{\nonterminal{PackageName}} \verb';'
% \end{tabbing}
% \vspace*{5pt}
% \vspace*{-5pt}

\phantomsection\label{nt:Import}\nonterminal{Import}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD \terminal{import} \hyperref[nt:PackageName]{\nonterminal{PackageName}} \verb`.` \verb`*`  \verb';'
\grammarprod \terminal{import} \hyperref[nt:PackageName]{\nonterminal{PackageName}} \verb`.` \hyperref[nt:identifier]{\lexicalnonterminal{Identifier}}  \verb';'
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:Imports}\nonterminal{Imports}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD
\hyperref[nt:Import]{\nonterminal{Import}}
\grammarprod
\hyperref[nt:ConfigurationExpression]{\nonterminal{ConfigurationExpression}}
\verb'{' \hyperref[nt:Imports]{\nonterminal{Imports}} \verb'}' \hyperref[nt:Imports]{\nonterminal{Imports}}\tag{opt}
\end{tabbing}
\vspace*{5pt}



% \phantomsection\label{nt:UseDirective}\nonterminal{UseDirective}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \terminal{use} \terminal{namespace} \hyperref[nt:NamespaceName]{\nonterminal{NamespaceName}}  \verb';'
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:GroupDirective}\nonterminal{GroupDirective}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD \hyperref[nt:ConfigCondition]{\nonterminal{ConfigCondition}}\tag{opt} \hyperref[nt:Block]{\nonterminal{Block}} 
% \end{tabbing}
% \vspace*{5pt}

% \phantomsection\label{nt:ScriptUnit}\nonterminal{ScriptUnit}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD
% \hyperref[nt:Configurations]{\nonterminal{Configurations}}\tag{opt}
% \hyperref[nt:Imports]{\nonterminal{Imports}}\tag{opt}
% \hyperref[nt:Directives]{\nonterminal{Directives}}
% \end{tabbing}
% \vspace*{5pt}



\phantomsection\label{nt:Modifiers}\nonterminal{Modifiers}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD
\hyperref[nt:Static]{\nonterminal{Static}} \hyperref[nt:Modifiers]{\nonterminal{Modifiers}}\tag{opt} 
\grammarprod
\hyperref[nt:Attribute]{\nonterminal{Attribute}} \hyperref[nt:Modifiers]{\nonterminal{Modifiers}}\tag{opt} 
\grammarprod
\hyperref[nt:AccessControl]{\nonterminal{AccessControl}} \hyperref[nt:Modifiers]{\nonterminal{Modifiers}}\tag{opt} 
\end{tabbing}
\vspace*{5pt}


\phantomsection\label{nt:TypeDefinitions}\nonterminal{TypeDefinitions}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD
\hyperref[nt:ConfigurationExpression]{\nonterminal{ConfigurationExpression}}\tag{opt} \hyperref[nt:Metadata]{\nonterminal{Metadata}}\tag{opt} \hyperref[nt:Modifiers]{\nonterminal{Modifiers}}\tag{opt} 
\hyperref[nt:ClassDefinition]{\nonterminal{ClassDefinition}} \hyperref[nt:TypeDefinitions]{\nonterminal{TypeDefinitions}}\tag{opt}
\grammarprod
\hyperref[nt:ConfigurationExpression]{\nonterminal{ConfigurationExpression}}\tag{opt} \hyperref[nt:Metadata]{\nonterminal{Metadata}}\tag{opt} \hyperref[nt:AccessControl]{\nonterminal{AccessControl}}\tag{opt} 
\hyperref[nt:InterfaceDefinition]{\nonterminal{InterfaceDefinition}} \hyperref[nt:TypeDefinitions]{\nonterminal{TypeDefinitions}}\tag{opt}
\end{tabbing}
\vspace*{5pt}



\phantomsection\label{nt:Unit}\nonterminal{Unit}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD
\verb'package' \hyperref[nt:PackageName]{\nonterminal{PackageName}}\tag{opt} \verb'{'
\hyperref[nt:Configurations]{\nonterminal{Configurations}}\tag{opt} 
\hyperref[nt:Imports]{\nonterminal{Imports}}\tag{opt}
\hyperref[nt:TypeDefinitions]{\nonterminal{TypeDefinitions}} \verb'}'
\end{tabbing}
\vspace*{5pt}

% \phantomsection\label{nt:ScriptUnits}\nonterminal{ScriptUnits}
% \vspace*{-5pt}
% \begin{tabbing}
% \grammarproD
% \hyperref[nt:ScriptUnit]{\nonterminal{ScriptUnit}} \hyperref[nt:ScriptUnits]{\nonterminal{ScriptUnits}}\tag{opt}
% \end{tabbing}
% \vspace*{5pt}


\phantomsection\label{nt:Units}\nonterminal{Units}
\vspace*{-5pt}
\begin{tabbing}
\grammarproD
\hyperref[nt:Unit]{\nonterminal{Unit}} \hyperref[nt:Units]{\nonterminal{Units}}\tag{opt}
\end{tabbing}
\vspace*{5pt}

\phantomsection\label{nt:Program}\nonterminal{Program}\marknote
\vspace*{-5pt}
\begin{tabbing}
%\grammarproD \hyperref[nt:ScriptUnits]{\nonterminal{ScriptUnits}} \hyperref[nt:TypeDefinitionUnits]{\nonterminal{TypeDefinitionUnits}}\tag{opt} 
\grammarproD
\hyperref[nt:Units]{\nonterminal{Units}}
\end{tabbing}
\vspace*{5pt}
\begin{notes}
Unlike in AS3, where top-level definitions could include those for
variables and functions, in AS4 the only top-level definitions are for
classes and interfaces.

\end{notes}
 
%\input{syntax/syntactic-ambiguities.tex}
%\input{syntax/include-processing.tex}
%\input{syntax/glossary.tex}
\chapter{Pruning}

\makeatletter{}
The syntax trees obtained by scanning and parsing, as described in the
previous chapter, undergo pruning in order to obtain a syntactically
valid program. This chapter describes pruning, which involves the processes of unit configuration
and enforcement of syntactic restrictions.

\section{Unit Configuration}
\label{sec:fileconfig}

\N
Unit configuration proceeds by traversing a parsed unit in
textual order, and as the traversal progresses, building a map from
identifiers to boolean values, and simplifying syntax trees that are
guarded by expressions involving such identifiers that evaluate to such boolean values.

\N
\nonterminal{Expression}s in \nonterminal{Configurations} and
\nonterminal{ConfigurationExpression}s must be composed
of \nonterminal{Identifier}s, \verb'true', \verb'false', \verb'!',
\verb'&&', and \verb'||'. Such
\nonterminal{Expressions} evaluate only to boolean values.

\N
A syntax tree nested by some \nonterminal{Configurations}, of
the form \verb'#' \nonterminal{Identifier} \verb'='
\nonterminal{Expression}, is processed as follows. The
\nonterminal{Expression} is 
evaluated to a boolean value, possibly by looking up the map, and the
\nonterminal{Identifier} is then mapped to that boolean
value.

\N
A syntax tree guarded by a \nonterminal{ConfigurationExpression} of
the form \verb'#' \nonterminal{Expression} is
processed as follows. The
\nonterminal{Expression} is 
evaluated to a boolean value, possibly by looking up the map. If the
value is 
\verb'false', the syntax tree is eliminated. If the value is 
\verb'true', the syntax tree is retained but the guard, along with any
pair of braces \verb'{' and \verb'}' that it introduces, is
eliminated. Otherwise, an error is reported.

% %\renewcommand{\labelenumi}{\arabic{chapter}.\arabic{section}.\arabic{enumi}}

% % At this point, we assume that we have successfully parsed programs.
% % The phases in the subsequent sections define several context-sensitive syntactic
% % restrictions and transformations on such programs.

% \N
% A \nonterminal{Program} is treated as if it had a
% \nonterminal{ConfigNamespaceDirective} with
% \lexicalnonterminal{Identifier} \verb'CONFIG' before its \nonterminal{Directive}s.

% \begin{definition}[Configuration namespace]\label{def:config-namespace}
% A \emph{configuration
%   namespace} is an \nonterminal{UnqualifiedName} $A$ that is defined by a \nonterminal{ConfigNamespace\-Directive} whose
% \lexicalnonterminal{Identifier} is $A$.
% \end{definition}

% % \begin{definition}[Configuration constant]\label{config-constant-def}
% % A \emph{configuration constant} is any \lexicalnonterminal{Identifier}
% % that appears in a \nonterminal{VariableDefinition} whose
% % \nonterminal{VariableDefinitionKind} is \terminal{const} and whose
% % \nonterminal{NamespaceAttribute} is a
% % \hyperref[def:config-namespace]{configuration namespace}. 
% % % The configuration constant is defined by that
% % %  \nonterminal{VariableDefinition}.
% % \end{definition}

% % \begin{definition}[Configuration name, configuration name definition]\label{config-name}
% % A \emph{configuration name} is a \nonterminal{QualifiedName}
% % whose \nonterminal{NamespaceExpression} is a \hyperref[def:config-namespace]{configuration namespace} and whose
% % \nonterminal{QualifiedNameIdentifier} is a \hyperref[def:config-constant]{configuration constant}. % defined in that configuration namespace.
% % \end{definition}

% \begin{definition}[Configuration name]\label{config-name}
% A \emph{configuration name} is a \nonterminal{QualifiedName} $A::B$ that is defined by a \nonterminal{VariableDefinition} whose
% \nonterminal{VariableDefinitionKind} is \terminal{const},  
% whose 
% \nonterminal{NamespaceAttribute} is a
% \hyperref[def:config-namespace]{configuration namespace} $A$, 
% and
% whose \lexicalnonterminal{Identifier} is $B$. 
% % The configuration constant is defined by that
% %  \nonterminal{VariableDefinition}.
% \end{definition}

% \N
% Program configuration is the process of evaluating
% \hyperref[def:config-name]{configuration names} and erasing various constructs based on their
% values. This process is done after the mutually recursive processes of
% scanning, parsing, resolution of
% syntactic ambiguities, and expansion of include directives. It transforms a valid program such that it does not have any 
% \hyperref[def:config-namespace]{configuration namespaces} and \hyperref[def:config-name]{configuration names}.

% \subsection{Syntactic Restrictions on Configuration Constructs}

% \begin{definition}[Global context]\label{def:global-context}
% A syntax tree is in a \emph{global context} if it is nested by a
% \nonterminal{Program} without crossing
% a \nonterminal{ClassBody}, \nonterminal{InterfaceBody}, or \nonterminal{FunctionBody}. 
% \end{definition}

% \N
% The following syntactic restrictions ensure that \hyperref[def:config-name]{configuration names}
% can be evaluated by a simple depth-first traversal of the
% \nonterminal{Program}, and 
% definitions of \hyperref[def:config-namespace]{configuration namespaces} and \hyperref[def:config-name]{configuration names} can be safely erased after
% replacing \hyperref[def:config-name]{configuration names} by their values.

% \N
%  A \hyperref[def:config-namespace]{configuration namespace} definition
%   must appear in a \hyperref[def:global-context]{global context}
%   without crossing a \nonterminal{Statement}.

% \N
%  A \hyperref[def:config-name]{configuration name} definition must appear in a
%   \hyperref[def:global-context]{global context} without crossing a \nonterminal{Statement}.

% \N
% There must be a unique definition for every \hyperref[def:config-namespace]{configuration namespace},
% and a unique definition for every \hyperref[def:config-name]{configuration name}.

% \N
% A \hyperref[def:config-namespace]{configuration namespace} may appear
% only as the \nonterminal{NamespaceAttribute} in a \hyperref[def:config-name]{configuration name} definition, or
% as the \nonterminal{NamespaceExpression} in a \hyperref[def:config-name]{configuration name}. 
% % In
% % particular, this implies that no \nonterminal{Definition} in the
% % \nonterminal{Program} may have a configuration namespace as its
% % \lexicalnonterminal{Identifier}, and a configuration namespace cannot
% % appear in any \nonterminal{Name} other than
% % a configuration name.

% \N
% For any \hyperref[def:config-name]{configuration name} $A \verb'::' B$, the definition of the
% \hyperref[def:config-namespace]{configuration namespace} $A$ must appear earlier than the definition of
% the \hyperref[def:config-name]{configuration name} $A \verb'::' B$,
% and the definition of $A
%  \verb'::' B$ must appear earlier than any use of $A \verb'::' B$ in the program.

% \N
%  The definition of a \hyperref[def:config-name]{configuration name} must have an initializer that is a \nonterminal{NonAssignmentExpression} 
% in which: any \nonterminal{UnaryExpression} must be a boolean
% literal, numeric literal, string literal, \terminal{null}, or \hyperref[def:config-name]{configuration name};
% and any \lexicalnonterminal{Punctuator} must be \verb`!`, \verb`||`, \verb`&&`,
% \verb`!=`, \verb`==`, \verb'!==', \verb'===', \verb`+`, \verb`-`, \verb`*`, \verb`/`,
% \verb`%`, \verb`<`, \verb`<=`, \verb`>`, \verb`>=`, \verb`<<`,
% \verb`>>`, \verb`>>>`, \verb`&`, \verb`|`, \verb`^`, or \verb'?'\dots\verb':'.

% \N
%  A \nonterminal{ConfigCondition} must be a
%  \hyperref[def:config-name]{configuration name}.

% \subsection{Evaluation of Configuration Names}

% \begin{definition}[Metadata association] 
% A \nonterminal{MetadataStatement} is associated with an
% \nonterminal{AttributedDefinition} if the 
% \nonterminal{MetadataStatement} is immediately followed by that
% \nonterminal{AttributedDefinition}, or is immediately followed by another
% \nonterminal{MetadataStatement} that is associated with that
% \nonterminal{AttributedDefinition}.
% \end{definition}

% \N
% \hyperref[def:config-name]{Configuration names} are evaluated in the order in which they are defined in
%   the program, as follows:
% \begin{enumerate} 
% \item The value of a \hyperref[def:config-name]{configuration
%     name} $A \verb'::' B$ is the
%   value of the \nonterminal{NonAssignmentExpression} in 
%   the definition of $A \verb'::' B$. The evaluation semantics is exactly that of 
%   expressions (with a redundant lookup structure), as defined elsewhere. \avik{Expressions}

% \item
% A \nonterminal{ConfigCondition} must have the value of either true or false. A \nonterminal{ConfigCondition} whose value is true is erased
%   from the syntax tree. In contrast, a \nonterminal{ConfigCondition} whose value is
%   false causes the \nonterminal{Field},
%   \nonterminal{ArrayElement}, \nonterminal{VectorElement}, \nonterminal{GroupDirective},
%   or \nonterminal{AttributedDefinition}  that it is part of,  as well as any
%   \nonterminal{MetadataStatement} that is associated with such a \nonterminal{AttributedDefinition}, to be erased 
% from the syntax tree.

% \item 
% Any other \hyperref[def:config-name]{configuration name} in the program is replaced by its value.
% \end{enumerate}

% \N
% Finally, the definitions of any \hyperref[def:config-namespace]{configuration namespaces}
%   and \hyperref[def:config-name]{configuration names} are erased
%   from the syntax tree.

 

\makeatletter{}
\section{Enforcement of Syntactic Restrictions}\label{sec:syntax-restrictions}

%\N The process of enforcing syntactic restrictions follows program configuration.

%\renewcommand{\labelenumi}{\arabic{chapter}.\arabic{section}.\arabic{subsection}.\arabic{enumi}}

\begin{definition}[Global context]\label{def:global-context}
A syntax tree is in a \emph{global context} if it is nested by a
\nonterminal{Program} without crossing
a \nonterminal{ClassBody}, \nonterminal{InterfaceBody}, or \nonterminal{FunctionBody}. 
\end{definition}

\begin{definition}[Class context]\label{def:class-context}
 A syntax tree is in a \emph{class context} if it is nested by a \nonterminal{ClassBody} without crossing
a \nonterminal{FunctionBody}. 
\end{definition}

\begin{definition}[Interface context]\label{def:interface-context}
 A syntax tree is in an \emph{interface context} if it is nested by an \nonterminal{InterfaceBody}. 
\end{definition}

\begin{definition}[Constructor]\label{def:constructor}
A \emph{constructor} is a \nonterminal{FunctionDefinition} that is in
a \hyperref[def:class-context]{class context}, and whose name has an identifier that matches the identifier
of that class.

%A class is always assumed to have a constructor (even if the constructor is not explicit in code).
\end{definition}

\begin{definition}[Getter/Setter]\label{def:getter-setter}
A \emph{getter} is a \nonterminal{FunctionDefinition} whose
\nonterminal{AccessorKind} is \terminal{get}. A \emph{setter} is a \nonterminal{FunctionDefinition} whose
\nonterminal{AccessorKind} is \terminal{set}.
\end{definition}

\begin{definition}[Result type]\label{def:result-type}
The \emph{result type} of a \nonterminal{FunctionInitializer} or \nonterminal{FunctionDefinition} that has
a \nonterminal{ResultType} is that \nonterminal{ResultType}. The
\emph{result type} of a \nonterminal{FunctionInitializer} or
\nonterminal{FunctionDefinition} that does not
have
a \nonterminal{ResultType} is missing.
\end{definition}

\begin{definition}[Mark]\label{def:mark}
Any \nonterminal{AccessControl}, \nonterminal{Attribute}, or
the keyword \verb'static' preceding a \nonterminal{ClassDefinition},
\nonterminal{InterfaceDefinition}, \nonterminal{FunctionDefinition},
or \nonterminal{VariableDefinition} is said to \emph{mark} it.
\end{definition}

\begin{definition}[Bodyless]\label{def:bodyless}
A \nonterminal{FunctionDefinition} is \emph{bodyless} if it does not
have a  \nonterminal{FunctionBody}.
\end{definition}

\begin{definition}[Return expression]\label{def:return-expression}
A \nonterminal{FunctionInitializer} or \nonterminal{FunctionDefinition}
has a \emph{return expression} if a
\nonterminal{ReturnStatement} is nested by it without crossing
another \nonterminal{FunctionBody}, and the
\nonterminal{ReturnStatement} has an \nonterminal{Expression}.
\end{definition}

\begin{definition}[Iterator statement] An \emph{iterator} statement is
  a \nonterminal{WhileStatement}, a \nonterminal{DoStatement}, a
  \nonterminal{ForStatement}, or a 
  \nonterminal{LabeledStatement} whose \nonterminal{Statement} is an
  iterator statement.
\end{definition}

% \begin{definition}[Mutually exclusive attributes]\label{def:mutually-exclusive}
% A set of attributes is \emph{mutually exclusive} if at most one of those attributes can \hyperref[def:mark]{mark} a definition.
% \end{definition}
 
The following side conditions must be satisfied to ensure that a
syntax tree is in the language.


% \subsection{Package Directives}

% \N
%  A \nonterminal{PackageDirective} must appear in a
%  \hyperref[def:global-context]{global context} without crossing a \nonterminal{Statement}.

% \N
% A \nonterminal{PackageDirective} must not be nested by another \nonterminal{PackageDirective}.

% \subsection{Import Directives}

% \N
%  An \nonterminal{ImportDirective} must appear in a global context without crossing a
%  \nonterminal{Statement}.

\subsection{Class Definitions}

% \N
%  A \nonterminal{ClassDefinition} must appear in a
%  \hyperref[def:global-context]{global context} without crossing a
%  \nonterminal{Statement}
% .

\N
 The only \nonterminal{AccessControl}s that may \hyperref[def:mark]{mark} a
  \nonterminal{ClassDefinition} are \terminal{public} and 
  \terminal{internal}. 

\N
The only \nonterminal{Attribute} that may \hyperref[def:mark]{mark} a
  \nonterminal{ClassDefinition} is
  \terminal{final}.


\N
A \nonterminal{ClassDefinition} must not be marked \verb'static'.

\N
 A particular \nonterminal{Modifier}
must not \hyperref[def:mark]{mark} a \nonterminal{ClassDefinition} more than once.

\subsection{Interface Definitions}

\N
 The only \nonterminal{AccessControl}s that may \hyperref[def:mark]{mark} an
  \nonterminal{InterfaceDefinition} are \terminal{public} and 
  \terminal{internal}. 

\subsection{Function Definitions}

\N
A \nonterminal{FunctionDefinition} that is \hyperref[def:mark]{marked} \terminal{static}
must not be \hyperref[def:mark]{marked} by \terminal{final} or \terminal{override}.

\N
 A particular \nonterminal{Modifier}
must not \hyperref[def:mark]{mark} a \nonterminal{FunctionDefinition} more than once.


\N
 A \nonterminal{FunctionDefinition} is
 \hyperref[def:bodyless]{bodyless} if and only if it is in an
  \hyperref[def:interface-context]{interface context} or is 
  \hyperref[def:mark]{marked} \terminal{native}. 

% \N
%  The \nonterminal{FunctionSignature} of a \hyperref[def:constructor]{constructor} must not have a non-\terminal{void} \nonterminal{ResultType}.

\subsubsection{Getters and Setters}

\N
 A \hyperref[def:getter-setter]{getter} or
 \hyperref[def:getter-setter]{setter} may appear only in a class
  context or \hyperref[def:interface-context]{interface context}.

\N
 The \nonterminal{FunctionSignature} of a \hyperref[def:getter-setter]{getter} must not have
  \nonterminal{Parameters}.

\N
 The result type of a \hyperref[def:getter-setter]{getter} must not be \verb'void'.

\N
 The \nonterminal{FunctionSignature} of a
  \hyperref[def:getter-setter]{setter} must have
  \nonterminal{Parameters}, which must be exactly one \nonterminal{Parameter}.

\N
The \hyperref[def:result-type]{result type} of a \hyperref[def:getter-setter]{setter} must be
\terminal{void} or missing.

\subsubsection{Constructors}

\N
 A \hyperref[def:constructor]{constructor} must not be a \hyperref[def:getter-setter]{getter} or \hyperref[def:getter-setter]{setter}.

\N
 No \nonterminal{Attribute} may \hyperref[def:mark]{mark} a
 \hyperref[def:constructor]{constructor}.

\N
A constructor must not be marked \verb'static'.

\N
 The \hyperref[def:result-type]{result type} of a
 \hyperref[def:constructor]{constructor} must be \terminal{void} or missing.


\subsection{Variable Definitions}

\N
 A \nonterminal{VariableDefinition} must not be marked by an
 \nonterminal{Attribute}.

\N
No \nonterminal{Modifier} may mark a \nonterminal{VariableDefinition}
more than once.



% \subsection{Namespace Definitions}

% \N
%  A \nonterminal{NamespaceDefinition} must be nested by a
%  \nonterminal{Program}, \nonterminal{ClassBody}, or \nonterminal{FunctionBody} without crossing a
%  \nonterminal{Statement}.
 
% \subsubsection{Namespace Attributes of Namespace Definitions}

% \N
%  A \nonterminal{NamespaceAttribute} may \hyperref[def:mark]{mark} a
%   \nonterminal{NamespaceDefinition} only in a \hyperref[def:class-context]{class context} 
%   or in a \hyperref[def:global-context]{global context}. % was: package context...

% \N
%  The only \nonterminal{NamespaceAttribute} that may \hyperref[def:mark]{mark} a
%   \nonterminal{NamespaceDefinition} in a
%   \hyperref[def:global-context]{global context} that is not nested  by a
%   \nonterminal{PackageDirective} is \terminal{internal}. % was: package context

% \N
%  The only \nonterminal{NamespaceAttribute}s that may \hyperref[def:mark]{mark} a
%   \nonterminal{NamespaceDefinition} in a
%   \hyperref[def:global-context]{global context} nested by a
%   \nonterminal{PackageDirective} are \terminal{public} and
%   \terminal{internal}.

% \N
% At most one \nonterminal{NamespaceAttribute} may \hyperref[def:mark]{mark} a
% \nonterminal{NamespaceDefinition}, and that \nonterminal{NamespaceAttribute}
% must not \hyperref[def:mark]{mark} the \nonterminal{NamespaceDefinition} more than once. 

% \subsubsection{Modifier Attributes of Namespace Definitions}

% \N
%  No \nonterminal{ModifierAttribute} may \hyperref[def:mark]{mark} a
%   \nonterminal{NamespaceDefinition}.


\subsection{Super Statements}

\N
A \nonterminal{SuperStatement} must be the first
\nonterminal{Directive} in the \nonterminal{FunctionBody} of a 
\hyperref[def:constructor]{constructor}.

\subsection{Defer Statements}

\N
A \nonterminal{DeferStatement} must be the last
\nonterminal{Directive} in the \nonterminal{FunctionBody} of a 
\hyperref[def:constructor]{constructor}.

\subsection{Labeled Statements}

\N
The label of a \nonterminal{LabeledStatement} must not be the
  label of another \nonterminal{LabeledStatement} that nests it
  without crossing a \nonterminal{FunctionBody}. 

\subsection{Break Statements}

\N
A \nonterminal{BreakStatement} must be nested by a
  \nonterminal{WhileStatement}, a \nonterminal{DoStatement}, \nonterminal{ForStatement}, a
  \nonterminal{SwitchStatement}, or a \nonterminal{LabeledStatement}
  without crossing a \nonterminal{FunctionBody}.

\N
A \nonterminal{BreakStatement} must carry a label if it is not
  nested by a \nonterminal{WhileStatement}, a
  \nonterminal{DoStatement}, a \nonterminal{ForStatement}, or a \nonterminal{SwitchStatement}. 

\N
The label of a \nonterminal{BreakStatement} must be the label of a
  \nonterminal{LabeledStatement} that nests it without crossing a \nonterminal{FunctionBody}.

\subsection{Continue Statements}

\N
A \nonterminal{ContinueStatement} must be nested by an iterator statement
  without crossing a \nonterminal{FunctionBody}.

\N
The label of a 
  \nonterminal{ContinueStatement} must be the label of a
  \nonterminal{LabeledStatement} that nests it without crossing a
  \nonterminal{FunctionBody}, and is an iterator statement.

\subsection{Return Statements}

\N
A \nonterminal{ReturnStatement} must be nested by a
\nonterminal{FunctionInitializer} or \nonterminal{FunctionDefinition}.

\N
A \nonterminal{FunctionInitializer} or \nonterminal{FunctionDefinition}
must have a
 \hyperref[def:return-expression]{return expression} if and only if
 its \hyperref[def:result-type]{result type} is not \terminal{void} or
 missing.

\N
Any return statement in any constructor or setter
must not have a
 \hyperref[def:return-expression]{return expression}.

\N
A getter must have \nonterminal{ReturnStatement}s that have return expressions.

\subsection{Expressions}

\N
 The keyword \terminal{this} must be nested by a
 \nonterminal{VariableDefinition}
 or \nonterminal{FunctionDefinition} that is in a class context and is not \hyperref[def:mark]{marked}
 \terminal{static}.

\N
 A \nonterminal{SuperExpression} must be nested by a
  \nonterminal{VariableDefinition} or \nonterminal{FunctionDefinition}
  that is in a \hyperref[def:class-context]{class context} and is not
  \hyperref[def:mark]{marked} \terminal{static}, without crossing a
  \nonterminal{FunctionBody}.

\N
% A \nonterminal{MetadataExpression} must be nested by some
% \nonterminal{Metadata}, and 
Any \nonterminal{Expression}s in the \nonterminal{ObjectInitializer}s of 
\nonterminal{Metadata} must be \verb'null', or \verb'true',
or \verb'false', or a \nonterminal{NumericLiteral},
or a \nonterminal{StringLiteral}, or a \nonterminal{TypeExpression}. % or a \nonterminal{MetadataExpression}.

\chapter{Canonicalization}

This chapter specifies the equivalence of certain forms of syntax trees with
other, canonical forms. 
Considering only canonical forms of syntax trees helps simplify the description of
compilation and execution algorithms in the sequel: by narrowing the
set of syntactic forms under consideration, the semantic rules become
more concise. Importantly, an implementation does not need to canonicalize syntax
trees: the semantic rules for non-canonical forms of syntax
trees can be readily and unambiguously derived from those for their equivalent canonical
forms.

\section{Canonical Forms}\label{sec:implicit}


% \N
% A \nonterminal{Program} is treated as if it were a sequence of
% (metadata-associated) \nonterminal{PackageDirective}s followed by an 
% \emph{entry point} as defined later. Any maximal contiguous sequence of (metadata-associated) \nonterminal{Directive}s
% which are not nested by a \nonterminal{PackageDirective} and are not
% themselves (metadata-associated) \nonterminal{PackageDirective}s is treated as
% if it were the \nonterminal{Directives} of the \nonterminal{Block} of an anonymous \nonterminal{PackageDirective}.
% Furthermore, a \nonterminal{PackageDirective} is treated as if it were a sequence of
% (metadata-associated) \nonterminal{ImportDirective}s,
% (metadata-associated, attributed) \nonterminal{ClassDefinition}s, and
% (metadata-associated, attributed) \nonterminal{InterfaceDefinition}s. Thus, any maximal contiguous
% sequence of (metadata-associated, attributed) \nonterminal{FunctionDefinition}s,
% \nonterminal{VariableDefinition}s, and \nonterminal{Statement}s
% which are not nested by a \nonterminal{ClassDefinition} or \nonterminal{InterfaceDefinition} is treated as
% if it were the \nonterminal{Directives} of the \nonterminal{Block} of
% a {\tt public static} \nonterminal{FunctionDefinition} named
% \verb'main' of a {\tt public} \nonterminal{ClassDefinition} whose name
% is fresh. The entry point of a \nonterminal{Program} is a {\tt public static} \nonterminal{FunctionDefinition} named
% \verb'main' of a {\tt public} \nonterminal{ClassDefinition} whose name
% is associated with the \nonterminal{Program}, where the
% body of the main calls all other mains in the order they appear in the program.

\N
A \nonterminal{VariableDefinition} with multiple \nonterminal{VariableBinding}s is treated as if it were a sequence of
\nonterminal{VariableDefinition}s, each with the same
\nonterminal{VariableDefinitionKind} and a single \nonterminal{VariableBinding}.

\N
An \nonterminal{Assignments} with multiple \nonterminal{Assignment}s is treated as if it were a sequence of
\nonterminal{Statement}s, each with a single \nonterminal{Assignment}.


\N
A missing \nonterminal{AccessControl} is treated as if
it were \verb'internal'.
% \begin{enumerate}
% \item If the \nonterminal{InterfaceDefinition} is nested by a
%   \nonterminal{PackageDirective} whose \nonterminal{PackageName} is
%   $\pkg$, the \nonterminal{Definition} is treated as if it had
%   {\bf public}(\verb`"`$\pkg {\tt:}I$\verb`"`) as its \nonterminal{NamespaceAttribute}.
% \item If the \nonterminal{InterfaceDefinition} is nested by a
%   \nonterminal{PackageDirective} that does not have a \nonterminal{PackageName}, the \nonterminal{Definition} is treated as if it had
%   {\bf public}(\verb`"`$I$\verb`"`) as its \nonterminal{NamespaceAttribute}.
% \item If the \nonterminal{InterfaceDefinition} is not nested by a
%   \nonterminal{PackageDirective}, the \nonterminal{Definition} is treated as if it had
%   {\bf public}(\verb`"`$I$\verb`"`) as its
%   \nonterminal{NamespaceAttribute}. 
% \end{enumerate}


% \N
% The base class of a \nonterminal{ClassDefinition} that has
% a \nonterminal{ClassInheritence} with \verb'extends' \nonterminal{TypeName} is that
% \nonterminal{TypeName}. The base class of any other
% \nonterminal{ClassDefinition} is the distinguished \emph{root class}.

\N
If a \nonterminal{ClassDefinition} whose
\nonterminal{Identifier} is $C$ does not nest
a constructor, a \nonterminal{FunctionDefinition} is added to the
the \nonterminal{ClassDefinition}, which is not marked \verb'static', has 
\nonterminal{AccessAttribute} \verb'public',
whose \nonterminal{Identifier} is $C$, whose
\nonterminal{FunctionBody} has an empty \nonterminal{Directives}, and
whose \nonterminal{FunctionSignature} has empty
\nonterminal{Parameters} and whose \nonterminal{ResultType} is {\tt void}.

\N
If a constructor does not nest a \nonterminal{SuperStatement}, a
\nonterminal{SuperStatement} is added to the top of the
\nonterminal{Directives} of its \nonterminal{FunctionBody}, whose
\nonterminal{Arguments} is empty.

\N Any \nonterminal{VariableInitializer}s corresponding to
\nonterminal{VariableDefinition}s not marked \verb'static' in a \nonterminal{ClassDefinition} are
treated as if they were \nonterminal{AssignmentStatement}s, and alongwith any
\nonterminal{Block}s in the \nonterminal{ClassDefinition} that are not
marked \verb'static', are moved in order to the top of the constructor just below the \nonterminal{SuperStatement}.

\N A \nonterminal{FunctionDefinition} called the \emph{static
  constructor} is added to a \nonterminal{ClassDefinition} named $C$ whose
\nonterminal{Identifier} is ${\bf static}::C$, which is marked \verb'static', has 
\nonterminal{AccessAttribute} \verb'public', has no \nonterminal{Parameter}s, whose
return type is \verb'void', and 
whose \nonterminal{Identifier} is $C$. Any \nonterminal{VariableInitializer}s corresponding to
\nonterminal{VariableDefinition}s marked \verb'static' in the \nonterminal{ClassDefinition} are
treated as if they were \nonterminal{AssignmentStatement}s, and alongwith any
\nonterminal{Block}s in the \nonterminal{ClassDefinition} that are 
marked \verb'static', are moved in order to the
\nonterminal{FunctionBody} of the static constructor.

% \N
% A \nonterminal{ClassDefinition} called the main class is added to the
% \nonterminal{Program}, that is marked \verb'public' and whose
% \nonterminal{Identifier} is {\bf \$main}. A
% \nonterminal{FunctionDefinition} that serves as the static constructor of the
% main class is added to the main class, which is marked \verb'static', has no
% \nonterminal{AccessAttribute}, has no \nonterminal{Parameter}s, whose
% return type is \verb'void', and 
% whose \nonterminal{Identifier} is {\bf \$static}. Any
% \nonterminal{Directives} in the \nonterminal{ScriptUnit} are
% moved in order to the
% \nonterminal{FunctionBody} of the main static constructor.

% \N
% An \nonterminal{ArrayInitializer} of the form \verb'[...]' is treated
% as if it were the \nonterminal{ArrayInitializer} \verb'new []*{...}'.

% \N
% An \nonterminal{InitializerElement} of the form \verb'{...}' is treated
% as if it were the \nonterminal{ArrayInitializer} \verb'new []*{...}'.

\N
Constructors are moved to the top of the instance scopes of their
class bodies, and static constructors are moved to the top of the static scopes of their class bodies.

% \N
% A \nonterminal{ForStatement} of the form 
% \verb'for ('\nonterminal{TypedBinding} \verb'in'
% \nonterminal{Expression}\verb') '\nonterminal{Statement} 
% is  treated as if it were 
% the syntax tree \verb'let x = '\nonterminal{Expression}\verb'.length; for (var'
% \nonterminal{TypedBinding}\verb' = 0; i<x; ++i;)'
% \nonterminal{Statement} where \verb'i' is the
% \lexicalnonterminal{Identifier} of the \nonterminal{TypedBinding}.


\N
A \nonterminal{ForStatement} of the form \verb'for (' \nonterminal{ForInitializer}\tag{opt} \verb';'
\nonterminal{Expression}\tag{opt} \verb';' \nonterminal{Assignments}\tag{opt}
\verb')' \nonterminal{Statement} is treated as if it were
\verb'{' \nonterminal{ForInitializer}\tag{opt} \verb';' \verb'while (' 
\nonterminal{Expression} \verb') {' \nonterminal{Statement}
  \nonterminal{Assignments}\tag{opt}
\verb'} }'. 

\N
A \nonterminal{DoStatement} of the form \verb'do'
\nonterminal{Statement} \verb'while' \nonterminal{ParenExpression} is treated as if it were
\nonterminal{Statement} \verb'while (' 
\nonterminal{Expression} \verb')' \nonterminal{Statement}. 

\N
An \nonterminal{IfStatement} of the form \verb'if' \nonterminal{ParenExpression} 
\nonterminal{Statement} is treated as if it were
\verb'if' \nonterminal{ParenExpression} 
\nonterminal{Statement} \verb'else ;'.

\N
\nonterminal{Metadata} is treated as if it were an
\nonterminal{ArrayInitializer} of the form \verb'new []Object{'$e_1,\dots,e_n$\verb'}', where each $e_i$ ($i \in 1..n$) is
of the form \verb'new '\nonterminal{ObjectInitializer} derived from a
corresponding syntax tree of the form 
\verb'@'\nonterminal{ObjectInitializer} in the \nonterminal{Metadata}.

\N
A \nonterminal{NewExpression} of the form \verb'new' \nonterminal{NominalType} is treated as
if it were \verb'new' \nonterminal{NominalType} \verb'()'. 
A
\nonterminal{NewExpression} of the form \verb'new'
\nonterminal{NominalType} \nonterminal{Arguments} \verb'{x1 = e1,'\dots\verb',xn = en}' is treated as
if it were the syntax tree \verb'function (o :'\nonterminal{NominalType}\verb') {o.x1 = e1,'\dots\verb',o.xn = en} (new'
\nonterminal{NominalType} \nonterminal{Arguments}\verb')'.

\N
A \nonterminal{FunctionInitializer} of the form \verb'function'
\lexicalnonterminal{Identifier} 
\nonterminal{FunctionBody} is treated as if it were \verb'function () {' \verb'function'
\lexicalnonterminal{Identifier} 
\nonterminal{FunctionBody}\verb'; return'
\lexicalnonterminal{Identifier}\verb'; } ()'.

\N
An assignment of the form \nonterminal{ReferenceExpression}
$\emph{binop}$= \nonterminal{Expression}, where
\nonterminal{ReferenceExpression} is an \nonterminal{Identifier} or of
the form \nonterminal{NominalType} \nonterminal{MemberOperator}, is treated as if it were \nonterminal{ReferenceExpression}
= \nonterminal{ReferenceExpression} $\emph{binop}$
\nonterminal{Expression}.
An assignment of the form \nonterminal{ReferenceExpression}
$\emph{binop}$= \nonterminal{Expression}, where
\nonterminal{ReferenceExpression} is of the form
\nonterminal{BaseExpression} \nonterminal{MemberOperator}, is treated as if it were \verb'let x = '\nonterminal{BaseExpression}\verb'; x' \nonterminal{MemberOperator}
= \verb' x' \nonterminal{MemberOperator} $\emph{binop}$
\nonterminal{Expression}.
An assignment of the form \nonterminal{ReferenceExpression}
$\emph{binop}$= \nonterminal{Expression}, where
\nonterminal{ReferenceExpression} is of the form
\nonterminal{BaseExpression} \verb'[' \emph{index} \verb']', is
treated as if it were \verb'let x = '\nonterminal{BaseExpression}\verb'; let y = '\emph{index}\verb'; x[y] = x[y]' $\emph{binop}$
\nonterminal{Expression}.

\N
A prefix operation of the form $\emph{prefixop}~$\nonterminal{ReferenceExpression}, where
\nonterminal{ReferenceExpression} is an \nonterminal{Identifier} or of
the form \nonterminal{NominalType} \nonterminal{MemberOperator}, is
treated as if it were \verb'function() { '\nonterminal{ReferenceExpression} =
  \nonterminal{ReferenceExpression} $\emph{binop}$ \verb'1; return'
  \nonterminal{ReferenceExpression}\verb'; } ()', where \emph{binop} is
the binary operation
corresponding to \emph{prefixop}.
A prefix operation of the form $\emph{prefixop}~$\nonterminal{ReferenceExpression}, where
\nonterminal{ReferenceExpression} is of the form
\nonterminal{BaseExpression} \nonterminal{MemberOperator}, is treated as if
it were the syntax tree \verb'function() { let x = '\nonterminal{BaseExpression}\verb'; x' \nonterminal{MemberOperator}
= \verb' x' \nonterminal{MemberOperator} $\emph{binop}$
\verb'1; return'
  \verb' x' \nonterminal{MemberOperator}\verb'; } ()', where \emph{binop} is
the binary operation
corresponding to \emph{prefixop}.
A prefix operation of the form $\emph{prefixop}~$\nonterminal{ReferenceExpression}, where
\nonterminal{ReferenceExpression} is of the form
\nonterminal{BaseExpression} \verb'['\emph{index}\verb']', is treated as if
it were the syntax tree \verb'function() { let x = '\nonterminal{BaseExpression}\verb'; let y = '\emph{index}\verb'; x[y] = x[y]' $\emph{binop}$ \verb'1; return' \verb' x[y]; } ()', where \emph{binop} is
the binary operation
corresponding to \emph{prefixop}.

\N
A postfix operation of the form \nonterminal{ReferenceExpression}$~\emph{postfixop}$, where
\nonterminal{ReferenceExpression} is an \nonterminal{Identifier} or of
the form \nonterminal{NominalType} \nonterminal{MemberOperator}, is
treated as if it were \verb'function() { let y = '\nonterminal{ReferenceExpression}\verb'; '\nonterminal{ReferenceExpression} \verb' = y '$\emph{binop}$ \verb'1; return y; } ()', where \emph{binop} is
the binary operation
corresponding to \emph{postfixop}.
A postfix operation of the form \nonterminal{ReferenceExpression}$~\emph{postfixop}$, where
\nonterminal{ReferenceExpression} is of the form
\nonterminal{BaseExpression} \nonterminal{MemberOperator}, is treated as if
it were the syntax tree \verb'function() { let x = '\nonterminal{BaseExpression} \verb'; let y = x'\nonterminal{MemberOperator}\verb'; x' \nonterminal{MemberOperator}
= \verb' y' $\emph{binop}$
\verb'1; return y; } ()', where \emph{binop} is
the binary operation
corresponding to \emph{postfixop}.
A postfix operation of the form \nonterminal{ReferenceExpression}$~\emph{postfixop}$, where
\nonterminal{ReferenceExpression} is of the form
\nonterminal{BaseExpression} \verb'['\emph{index}\verb']', is treated as if
it were the syntax tree \verb'function() { let x = '\nonterminal{BaseExpression}\verb'; let z = '\emph{index}\verb'; let y = x[z]; x[z] = y' $\emph{binop}$
\verb'1; return y; } ()', where \emph{binop} is
the binary operation
corresponding to \emph{postfixop}.

\N
A unary plus operation of the form \verb'+'\nonterminal{Expression}
is treated as if it were \nonterminal{Expression}. A unary minus operation of the form \verb'-'\nonterminal{Expression}
is treated as if it were \verb'0 -' \nonterminal{Expression}.

% \N
% A conditional expression of the form \nonterminal{IfExpression} \verb'?'
% \nonterminal{ThenExpression} \verb':' \nonterminal{ElseExpression} is
% treated as if it were \verb'function() { let x; if ('\nonterminal{IfExpression}\verb') x = '\nonterminal{ThenExpression}\verb'; else x = '\nonterminal{ElseExpression}\verb'; return x; } ()'.

\section{Non-Canonical Forms}

\N
As a consequence of canonicalization, the following syntactic forms
are assumed to be encoded away, and are not considered when specifying semantic rules in the sequel:

\begin{enumerate}
\item \nonterminal{VariableDefinition}s with multiple
  \nonterminal{VariableBinding}s
\item \nonterminal{Assignments} with multiple
  \nonterminal{Assignment}s
\item missing \nonterminal{AccessControl}s
\item missing constructors in \nonterminal{ClassDefinition}s
\item missing \nonterminal{SuperStatement}s
\item \nonterminal{VariableInitializer}s of \nonterminal{VariableDefinition}s, marked \verb'static' or not,
  in \nonterminal{ClassDefinitions}
\item \nonterminal{ForStatement}s
\item \nonterminal{DoStatement}s
\item \nonterminal{IfStatement}s without \verb'else'
  \nonterminal{Statement}s
\item \nonterminal{Metadata}
\item \nonterminal{NewExpression}s without \nonterminal{Arguments}, or
  with \nonterminal{FieldValuePairs}
\item \nonterminal{FunctionInitializer}s with
  \nonterminal{Identifier}s
\item compound \nonterminal{Assignment}s of the form \emph{op}\verb'='
\item prefix and postfix operations \verb'--' and \verb'++'
\item unary \verb'-' and \verb'+' operations
%\item conditional \nonterminal{Expression}s (of the form \dots\verb'?' \dots \verb':'\dots)
\end{enumerate} 
%\input{syntax/preprocessing-packages-imports.tex}
%\input{syntax/erasing-use-namespace-directives.tex}
%\input{syntax/hoisting.tex}


\part{Compilation}



\chapter{Resolution and Lexical Environments}\label{chap:resolution}

\makeatletter{}
This chapter describes the process of deriving compile-time information for types defined by a program and the set
of libraries it is compiled against. The compile-time information is
recorded as \emph{lexical environments}. Along the way, identifiers
are lexically resolved to various kinds of references: to local variables and functions, to
instance members, to static members, and to package-qualified types.

\section{References}

\N References to definitions are looked up for various purposes at compile time and run
time. Some references correspond to syntactic forms, whereas others
are generated during \emph{resolution}, as described below.

\begin{definition}[Reference]
A \emph{reference} is either an \lexicalnonterminal{Identifier}, or
  of the form \nonterminal{NominalType}, or of the form {\tt
    super.}\lexicalnonterminal{Identifier}, or of the form \nonterminal{NominalType}\verb'.'\lexicalnonterminal{Identifier}, or of the form {\bf static}{\tt.}\lexicalnonterminal{Identifier}, or of the form
\nonterminal{Expression}{\tt.}\lexicalnonterminal{Identifier} (member
reference), or of the form
\nonterminal{Expression}$_1${\tt[}\nonterminal{Expression}$_2${\tt ]}
(index reference).
\end{definition}

\subsection{Scopes}

\N
Scopes are identified with specific forms of syntax trees, and can be nested (like syntax
trees).

\N
A \nonterminal{ClassBody} is conceptually partitioned into a pair of scopes: a \emph{static
  scope} and an \emph{instance scope}. The static scope contains
variables and functions marked \verb'static', including the static
constructor. The instance scope 
contains
variables and functions not marked \verb'static', including the (instance)
constructor. 

\begin{definition}[Scope]\label{def:scope} A
  \emph{scope} is either a global scope or a local scope. A global
  scope is the instance
  scope or the static scope of a 
\nonterminal{ClassBody}, or an \nonterminal{InterfaceBody}. A local
scope is a 
\nonterminal{FunctionBody}, a \nonterminal{CatchClause}, or a \nonterminal{Block}.
\end{definition}

% \begin{definition}[Slot] A \emph{slot} $\slot$ is a value of the
%   abstract data type {\bf Slot}. A slot must be constructed in any of
%   the following ways (with the corresponding function and arguments):
% \begin{enumerate}
% \item ${\bf namespace}(\emph{namespaceInfo})$, where
%   \emph{namespaceInfo} is a record with the following fields:
% \begin{enumerate}
% \item $\mathsf{val}$, which is a \hyperref[def:nsval]{namespace value}
% \end{enumerate}
% \item ${\bf class}(\emph{classInfo})$, where \emph{classInfo} is a
%   record with the following fields:
% \begin{enumerate}
% \item $\mathsf{final}$, which contains a boolean 
% \item $\mathsf{dynamic}$, which contains a boolean 
% \item $\mathsf{baseClass}$, which contains a \hyperref[def:qname]{QName}
% \item $\mathsf{baseInterfaces}$, which contains a set of
%   \hyperref[def:qname]{QNames}
% \item $\mathsf{instanceTraits}$, which contains an environment table (see
%   below)
% \item $\mathsf{staticTraits}$, which contains an environment table (see below)
% \end{enumerate}
% \item ${\bf interface}(\emph{interfaceInfo})$, where
%   \emph{interfaceInfo} is a record with the following fields:
% \begin{enumerate}
% \item  $\mathsf{baseInterfaces}$, which contains a set of \hyperref[def:qname]{QNames}
% \item  $\mathsf{traits}$, which contains an environment table (see below)
% \end{enumerate}
% \item ${\bf var}(\emph{varInfo})$, where \emph{varInfo} is a record
%   with the following fields:
% \begin{enumerate}
% \item $\mathsf{const}$, which
%   contains a boolean
% \item $\mathsf{type}$, which
%   contains a type (defined later)
% \item $\mathsf{val}$, which
%   optionally contains a value
% \end{enumerate}
% \item ${\bf
%     function}(\emph{functionInfo})$,
%   where \emph{functionInfo} is a record with the following fields:
% \begin{enumerate}
%  \item $\mathsf{const}$, which contains a boolean 
%  \item $\mathsf{accessor}$, which contains a boolean 
% \item $\mathsf{final}$, which contains a boolean 
% \item $\mathsf{override}$, which contains a boolean
% \item $\mathsf{native}$, which contains a  boolean
% \item $\mathsf{argtypes}$, which contains an ordered list of types
% \item $\mathsf{defaultargtypes}$, which contains an ordered list of types
% \item $\mathsf{restargs}$, which contains a boolean
% \item $\mathsf{returntype}$, which contains a type
% \end{enumerate}
% \item ${\bf any}$, which models information that is unknown at compile time
% \end{enumerate}
% \end{definition}

\subsection{Lexical Environments}\label{sec:resolution-of-names}


\N Every \hyperref[def:scope]{scope} is associated
with a lexical environment, which is used to store lexical
bindings for definitions in that scope and to look up names in that
scope. Lexical environments provide information at compile time as well
as run time (upon regeneration).

\begin{definition}[Lexical environment and lexical bindings]\label{def:lexenv} A
  \emph{lexical environment} is a container for \hyperref[def:lexbinding]{lexical bindings}. A \emph{lexical binding}
  a (\emph{name}, \nonterminal{Definition}) pair.
\end{definition}


% \N The following partial functions are defined on values of the
% abstract data type {\bf Slot} (reporting an error where undefined):
% \begin{enumerate}
% \item $\func{QnameBaseCls}({\bf class}(\qname,
%   \{\qname_1,\dots,\qname_k\}, \dots)) = \qname$
% \item $\func{qnamesBaseInterfaces}({\bf class}(\qname,
%   \{\qname_1,\dots,\qname_k\}, \dots)) = \{\qname_1,\dots,\qname_k\}$
% \item $\func{qnamesBaseInterfaces}({\bf interface}(\{\qname_1,\dots,\qname_k\},\dots)) = \{\qname_1,\dots,\qname_k\}$
% \end{enumerate}

%
% \avik{It would be nice to maintain the illusion that dynamic objects in the scope chain
% ``scramble'' the lexical environment. Unfortunately, the $\mathtt{global}$
% object, which is a dynamic object at the bottom of the scope chain,
% behaves differently. In the future, we could consider the following: when \nonterminal{WithStatement}s
% introduce dynamic objects in scope, the effects
% could be similar to that of the $\mathtt{global}$ object at the
% bottom of the scope chain; on the other hand, when \nonterminal{WithStatement}s introduce
% static objects, type inference could be refined.}

% \N
% The dynamic environment table $\{\}^\star$ is denoted by $\star$.

% \begin{definition}[Final environment table] An environment table is
%   final if it is of the form $\emph{EnvTable}^\dagger$. A
%   final environment table contains exactly the same lexical bindings
%   as the corresponding environment table.
% \end{definition}



% % \begin{definition}[Dynamic lexical environment] A lexical
% %   environment is dynamic if its first element is a dynamic environment table.
% % \end{definition}

\N
In addition, there is a \emph{global lexical environment} that maps the
fully qualified names for types (classes and interfaces) that are
defined in the set of 
libraries and the \nonterminal{Program} to their definitions, with no name conflicts. The name of such a defined type is fully
qualified as $P.\id$ or ${\bf internal::}P.\id$ according as whether
the definition is marked \verb'public' or not, where $P$ is the name of the package in which it
is defined (which is empty if no such package is specified, meaning
the default package) and $\id$ is the identifier in that definition.%\openavik{}

% Access control modifiers:

% compiler has knowledge of packages (via package directives or
% configuration switches)

% import directives affect code that follows it in the immediately
% surrounding block

% the anonymous package is imported everywhere

% public class C in package p is available to any code that imports p.C

% class C is available only to code inside the surrounding package (but
% not necessarily in the surrounding package directive)

% public member m can be accessed by any code

% private member m can be accessed only by code in the surrounding class

% protected member m is visible by inheritance to code in the surrounding class
% and its subclasses, and can be accessed via reference only by code in
% the surrounding class and its superclasses

% member m is available to any code inside the surrounding package

% Block scope:

% Directives outside package directives are treated ``en block'' as parts of 
% blocks of intermittent package directives for the anonymous package

% Directives inside package directives that are outside class
% definitions form script blocks.

% A class definition consists effectively of two blocks: the instance
% block that consists of variable definitions and function definitions
% that are not marked static, which is nested by the static block that
% consists of everything else.

% A substatement that consists of a statement is considered to be a
% substatement block.

% Package blocks, script blocks, static blocks, instance blocks, and
% function blocks (i.e., all blocks other than substatement blocks) are
% visited in breadth first order. Thus, we know all packages first. Then
% we know all classes (and their inheritance hierarchy). Then we look at
% inner blocks in turn.

% When visiting the static block of a class,  the lexical environment of the
% static block of the subclass is in scope (if it exists). 
% When visiting the instance block of a class,  the lexical environment of the
% instance block of the subclass is in scope (if it exists), followed by
% the lexical environment of the immediately nesting block. 
% When visiting any other block, the lexical environment of the
% immediately nesting block
% is in scope. 

% When visiting a block, all function definitions are processed
% first. Then, other variable definitions and statements are
% processed. Every definition introduces an entry in the lexical
% environment, and every lexical reference must bind to entries that
% appear in the lexical environment in scope.



%\closeavik{}

% \section{Introduction}

% \N
% This chapter describes how definitions in a program are organized and referenced using names and 
% lexical environments. 

% \N
% A definition is associated with a scope and
% denoted by a 
% name, which consists of a namespace and 
% an identifier. The scope is
% determined by the context in which the definition appears, and the
% name is determined by the definition itself. The contexts in
% which the definition can be referenced 
% are controlled by its namespace as well as by its scope. 

% \N
% A lexical 
% environment is a structured collection of named definitions ordered by
% scopes. 

% % \N
% % In 
% % certain syntactic contexts names have a restricted form,
% % \nonterminal{RestrictedName}. Unlike names that appear in other
% % contexts, whose evaluation may involve the evaluation of arbitrary
% % expressions at run time, 
% % \nonterminal{RestrictedName}s are evaluated at compile
% % time. \nonterminal{RestrictedName}s are important for
% % lexical-environment building and static verification, and may denote namespace attributes of definitions, namespace
% % initializers of namespace definitions, namespaces that are opened by
% % use directives and import directives,
% % class types and interface types that are inherited, as well as type
% % annotations. 

% \N
% The various sections of this chapter describe the 
% process of building lexical environments, and the process of resolving
% names of references to 
% names of definitions in lexical environments.


% \N
% Sections \ref{sec:names-and-namespaces}, \ref{sec:scope} and \ref{sec:resolution-of-names} develop 
% the required concepts around names, while Sections \ref{sec:lexenv} and \ref{sec:pre-static-verif} 
% rely on those concepts to present algorithms for the construction of lexical environments and the
% resolution of names. (The reader should note that the
% contents of the sections in this chapter have some cyclic
% dependencies:  the resolution of names depends on the state of lexical environments, and the building of the 
% lexical environments depends on the resolution of names. Therefore, the reader may not get the full picture of how names 
% and lexical environments work without reading the whole chapter.)

% \section{Glossary}

% % {\bf Slot}. A \emph{slot} is a record of static information on a
% % definition. Distinct kinds of slots, corresponding to distinct kinds of definitions, are
% % constructed with various constructors of an abstract data type {\bf
% %   Slot}. (See Definition
% % \ref{def:lexbinding}.)

% {\bf Lexical binding}. A \emph{lexical binding} maps a QName to a \nonterminal{Definition}, and is the result of
% interpreting a definition at compile time. (See Definition
% \ref{def:lexbinding}.)

% {\bf Environment table}. An \emph{environment table} is a container
% for lexical bindings. (See Definition
% \ref{def:envtable}.)

% {\bf Lexical environment}. A \emph{lexical environment} is an ordered
% list of environment tables. Names are looked up in those environment
% tables in the order in which they appear in the lexical environment. (See Definition
% \ref{def:lexenv}.)

% % {\bf Statically resolved name}. A \emph{statically resolved name} is a resolvable name that can be 
% % reduced to a Multiname at compile time.

% % {\bf Dynamically evaluated name}. A \emph{dynamically evaluated name}
% % is a name that is partly unknown or consists of 
% % an expression that depends on run time evaluation. Specifically, they do not depend soley on the 
% % name resolution algorithms defined in this chapter.

% %{\bf Scope}. A \emph{scope} is a continuous region of program text denoted by a syntax tree.

% {\bf Binding scope}. A \emph{binding scope} is a region of
% program text within which some lexical bindings
% can be introduced and can shadow lexical bindings with the same QNames in
% outer binding scopes. (See Definition
% \ref{def:binding-scope}.)

% {\bf Qualifier association}. A \emph{qualifier association},
% introduced by a use directive, import directive, package directive,
% class definition, or program, is a mapping of a particular identifier 
% or all identifiers to a namespace value. Qualifier associations are used to map 
% unqualified names to Multinames. (See Definition
% \ref{def:qualifier-assoc}.)

% {\bf Opening scope}. An \emph{opening scope} is a region of
% program text within
% which any unqualified names are implicitly qualified by some set of
% namespace values, as determined by qualifier associations, to yield
% Multinames. (See Definition
% \ref{def:opening-scope}.)

% {\bf Defining scope}. A \emph{defining scope} is a region of program text
% within which definitions may appear. All defining scopes are binding
% scopes, but not vice versa. All defining scopes are opening scopes,
% but not vice versa. (See Definition
% \ref{def:defining-scope}.)

% % {\bf Expansion}. \emph{Expansion} is the process of deriving an
% % expanded name from a restricted name, by successively mapping the unqualified names within 
% % the restricted name to Multinames. (See Definition
% % \ref{def:expansion}.)

% {\bf Resolution}. \emph{Resolution} is the process of evaluating a
% name to a Multiname. (See Definition
% \ref{def:resolution}.)

% {\bf Lookup}. \emph{Lookup} is the process of narrowing a Multiname to
% a QName in the lexical environment and finding the lexical
% binding corresponding to that QName in the
% lexical environment. (See Definition
% \ref{def:lookup}.)

% % {\bf Qualified name}. A \emph{qualified name} is an identifier qualified by an expression that
% % denotes a set of namespace values, which together form a Multiname. \emph{Qualified names} are not
% % to be confused with \emph{QNames}, which is a particular kind of \emph{Multiname}.

% % {\bf Unqualified name}. An \emph{unqualified name} is an identifier that denotes one of a set of 
% % candidate names that match a binding in a lexical environment, type or value. 
% % \emph{Unqualified names} are expanded to \emph{Multinames} using the \emph{qualifier associations}
% % that are in scope.

% %{\bf Identifier}. An \emph{identifier} is a sequence of characters that is a part of a name.

% % {\bf Reserved namespace}. A \emph{reserved namespace} is a system defined namespace that is denoted
% % by one of the reserved identifiers: public, private, protected and internal.

% % {\bf Definition}. A \emph{definition} is a syntactic form that introduces a name into an environment
% % table and associates with it a slot and possible constant value with a QName in an environment table.

% % {\bf Namespace attribute}. A \emph{namespace attribute} is a restricted name that denotes
% % a namespace value.

% % {\bf Namespace initializer}. A \emph{namespace initializer} is restricted name that denotes
% % a namespace value.

% % {\bf Type annotation}. A \emph{type annotation} is a name
% % that must denote a 
% % \emph{type} that constrains the set of values that may be stored in the slot it annotates.

% % {\bf Static}. A \emph{static} process or value is one that comes into existence at compile time and 
% % is constant over time.

% % {\bf Dynamic}. A \emph{dynamic} process or value is one that come into existence at run time and may
% % vary during run time.

% % {\bf Run time}. \emph{Run time} is the final phase of interpretation, when code is executed.

% % {\bf Compile time}. \emph{Compile time} encompasses the sequence of logical phases that occur before 
% % run time.

% % {\bf Static verification}. \emph{Static verification} is the compile time phase in which certain
% % semantic properties are checked based on lexical environments. Static verification occurs after lexical environment building and 
% % before run time.

% % {\bf Namespace name}. A \emph{namespace name} is a statically
% % evaluated name  which denotes a
% % namespace value.

% % {\bf Type name}. A \emph{type name} is a statically evaluated name which denotes a type value.

% % {\bf Package name}. A \emph{package name} is a sequence of characters used to construct public and
% % internal package namespaces.



% \N
% \nonterminal{RestrictedName}s appear in the following syntactic
% contexts (as \nonterminal{NamespaceName}s
% or \nonterminal{TypeName}s):
% \begin{description} 
% \item[Namespace attributes] e.g., the name $N$ in the syntax tree
%   $N$ \verb'var x', $N$ \verb'function f() {...}', or $N$ \verb'namespace L'.
% \item[Namespace initializers] e.g., the name $N$ in the syntax
%   tree \verb'namespace L = '$N$
% \item[Inheritance clauses] e.g., the name $T$ in the syntax tree
%   \verb'class C extends T', \verb'class C implements T', or
%   \verb'interface I extends T'
% \item[Type annotations] e.g., the name $T$ in
%   the syntax tree \verb'var x:' $T$ or \verb'function f():' $T$\verb' {...}' or \verb'function (x:' $T$\verb') {...}'
% \end{description}


% \N
% Like other names, \nonterminal{RestrictedName}s are transformed
% prior to evaluation to
% syntactic forms that can be viewed as multinames, and such multinames are resolved by mapping them to QNames of definitions during evaluation.

% transformed to a \emph{restricted name}, by desugaring 
% \nonterminal{ReservedNamespace}s and \nonterminal{PackageName}s in a context-sensitive manner as 
% shown in Section \ref{sec:reserved-ns}, and dropping parentheses. A restricted name 
% must be evaluated during \hyperref[def:lexenv]{lexical environment} building or static verification as a \hyperref[def:nsval]{namespace value} 
% or a type definition. Evaluation involves expanding the \nonterminal{UnqualifiedName}s in the 
% restricted name to \hyperref[def:Multiname]{Multinames}, yielding an \emph{expanded name} that
% is then resolved to the \hyperref[def:lexbinding]{lexical binding} of a 
% definition.

% \begin{definition}[Resolvable name] A \emph{resolvable name} is a name that evaluates to a 
% \emph{\hyperref[def:Multiname]{Multiname}} by name resolution alone.
% \end{definition}

% \begin{definition}[Computed name] A \emph{computed name} is a name that requires some run time
% computation to evaluate to a \emph{mutliname}.
% \end{definition}

% \subsubsection{Restricted Names}\label{sec:rname}

% \begin{definition}[Restricted name]\label{def:rname} A \emph{restricted name} $\rname$ is either a \hyperref[def:Multiname]{Multiname}, or an 
% \lexicalnonterminal{Identifier}, or a \emph{restricted qualified name} of the form $\rname' {\tt::} \id$ 
% where $\rname'$ is a restricted name and $\id$ is an \lexicalnonterminal{Identifier}.
% \end{definition}

% \N 
% Syntax trees that match \nonterminal{RestrictedName} are transformed to \hyperref[def:rname]{restricted names} by 
% desugaring reserved namespaces and package names in a context-sensitive manner, as shown in 
% Section \ref{sec:reserved-ns}. In particular, identifiers qualified by package names and identifiers
% qualified by reserved namespaces are transformed to \hyperref[def:Multiname]{Multinames}. 

% \N
% {\bf Example.} In the following code, \nonterminal{RestrictedName}s on various lines are shown in corresponding 
% comments on those lines. Some of the \hyperref[def:nsval]{namespace values} in these \nonterminal{RestrictedName}s rely on the 
% contextual expansion of \nonterminal{ReservedNamespace}s such as
% \verb'public' and \verb'internal' and \nonterminal{PackageName}s such
% as \verb'p.q',
% described in Section \ref{sec:reserved-ns}.

% \begin{lstlisting}
% package p.q {
%     public namespace N;
%     public class A {
%         N namespace O;                 // \verb'N' is an {\slantsfsmall UnqualifiedName}
%         N::O var x;                    // \verb'N::O' is a name qualified by an {\slantsfsmall UnqualifiedName}
%         public::N var y;               // \verb'public::N' is (desugared to) a \hyperref[def:Multiname]{Multiname}
%         function f() {
%             return public::N::y        // \verb'public::N::y' is (desugared to) a name qualified by a Multiname
%         }
%     }
% }

% class B extends p.q.A {                // \verb'p.q.A' is (desugared to) a \hyperref[def:Multiname]{Multiname}
% }

%\end{lstlisting}

% \subsubsection{Expanded Names}\label{sec:rname}

% \N Evaluation of \hyperref[def:rname]{restricted names} involves two steps: expansion and resolution.
% \begin{enumerate}
% \item \hyperref[def:rname]{restricted names} are expanded to eliminate unqualified names, as
% shown in Section \ref{sec:expansion}.
% \item The resulting expanded names, which are either \hyperref[def:Multiname]{Multinames}, or identifiers 
% qualified by expanded names, are resolved to 
% \hyperref[def:lexbinding]{lexical bindings}, as
% shown in Section \ref{sec:evaluation-of-names-of-expanded}.
% \end{enumerate}

% \N
% Expanded names may also arise by partial evaluation of names in other
% contexts, as described in Section \ref{sec:tx-unqual-mname}. In general,
% expanded names are resolved when the values they denote are needed, which might be 
% during lexical-environment building, static verification, or even dynamic execution. Until then, 
% names remain in the form of expanded names.

% \begin{definition}[Expanded name]\label{def:xname} An \emph{expanded name} is either a \hyperref[def:Multiname]{Multiname}, or an 
% \emph{expanded qualified name} of the form $\xname {\tt::} \id$, where
%   $\xname$ is a expanded name and $\id$ is an \lexicalnonterminal{Identifier}.
% \end{definition}


%\section{Data Structures and Operations on Names}\label{sec:resolution-of-names}
%
%This section describes core data structures and operations on the
%\hyperref[def:rname]{restricted names} defined in Section
%\ref{sec:evaluation-of-names}.
%
%\begin{enumerate}
%\item Various kinds of \emph{scopes}, defined in Section \ref{sec:scope},
%  are associated with various data structures that are used by the algorithms of the
%  later sections.
%\item \nonterminal{UseDirective}s and \nonterminal{ImportDirective}s
%  in a program introduce \emph{\hyperref[def:qualifier-assoc]{qualifier associations}}, which in turn
%  are used to transform \hyperref[def:rname]{restricted names} to \hyperref[def:xname]{expanded name}s, as defined in
%  Section \ref{sec:expansion}. 
%\item \nonterminal{Definition}s in a program introduce \emph{\hyperref[def:lexbinding]{lexical bindings}},
%  which are stored in lexical
%  environments so that they may be retrieved by resolving \hyperref[def:Multiname]{Multinames}, as defined
%  in Section \ref{sec:lexical-environments}.
%\item \hyperref[def:xname]{expanded name}s are transformed to
%  \hyperref[def:Multiname]{Multinames} to facilitate such retrieval, as defined in Section \ref{sec:evaluation-of-names-of-expanded}.
%\end{enumerate}

% \subsection{Expansion of Restricted Names}\label{sec:expansion}

% \N those 
% A \hyperref[def:rname]{restricted name} is expanded by a set of \hyperref[def:qualifier-assoc]{qualifier associations} to an \hyperref[def:xname]{expanded name}.

% \jeff{Since \hyperref[def:qualifier-assoc]{qualifier associations} are (key, nsval) pairs, \hyperref[def:rname]{restricted names} are always expanded
% to \hyperref[def:xname]{expanded names}. In ASC used namespaces that haven't yet been defined are in fact 
% ignored. By this spec, such forward references are static errors. We need a Jira LANGUAGE CHANGE bug
% to record this.}


% \begin{definition}[Expansion of restricted names]\label{def:expansion} Let $\xquals$ be a set of \hyperref[def:qualifier-assoc]{qualifier associations} 
% and $\rname$ be a \hyperref[def:rname]{restricted name}. Then $\func{expand}(\rname,\xquals)$ is an \hyperref[def:xname]{expanded name} that denotes the 
% \emph{expansion} of $\rname$ with $\xquals$, and is defined recursively as follows. 

% \begin{enumerate}
% \item If $\rname$ is a \hyperref[def:Multiname]{Multiname} $\mname$, return $\mname$.
% \item If $\rname$ is an \lexicalnonterminal{Identifier} $\id$, then:
% \begin{enumerate}
% \item Let $\{\nsval_1, \dots, \nsval_k\}$ be the set of all \hyperref[def:nsval]{namespace values} $\nsval$
%   such that $(\id, \nsval) \in \xquals$ or
%   $({\tt*}, \nsval) \in \xquals$.
% \item Return $\{\nsval_1,\dots,\nsval_k\} {\tt::} \id$.
% \end{enumerate}
% \item Otherwise, $\rname$ is a restricted qualified name of the form $\rname' {\tt::} \id$.
% \begin{enumerate}
% \item Let $\xname = \func{expand}(\rname',\xquals)$.
% \item Return $\xname {\tt::} \id$.
% \end{enumerate}
% % \item Otherwise, $\rname$ is a restricted parenthesized name of the form
% %   $\verb'('\rname'\verb')'$; return $\func{expand}(\xquals, \rname')$.
% \end{enumerate}
% \end{definition}

% \N
% {\bf Example.} In the following code we show how the
% \nonterminal{RestrictedName}s of the previous example are
% \hyperref[def:expansion]{expanded} with \hyperref[def:qualifier-assoc]{qualifier associations}. (Only the expansions
% that are significant to the uses are shown.)

% \begin{lstlisting}
% package p.q {
%     public namespace N;
%     public class A {
%         N namespace O;             // \verb'N' is \hyperref[def:expansion]{expanded} to a \hyperref[def:Multiname]{Multiname} of the form $\{\dots\}$\verb'::N'
%         N::O var x;                // \verb'N::O' is \hyperref[def:expansion]{expanded} to a name qualified by a Multiname, of the form $\{\dots\}$\verb'::N::O'
%         public::N var y;           
%         function f() {
%             return public::N::y    
%         }
%     }
% }

% class B extends p.q.A {            
% }

% \end{lstlisting}


% \N
% The various kinds of scopes (as defined above) respectively control the following operations on 
% names:

% \begin{enumerate}
% \item Defining scopes control the storage of information on
%   \nonterminal{Definition}s.
% \item Opening scopes control the expansion of names,
%   based on \nonterminal{UseDirective}s and
%   \nonterminal{ImportDirective}s.
% \item Binding scopes control the resolution of names to retrieve
%   information on \nonterminal{Definitions}.
% \end{enumerate}

% \subsection{Qualifier Associations}

% \begin{definition}[Qualifier association]\label{def:qualifier-assoc}
% A \emph{qualifier association} is of the form $(\key, \nsval)$, where $\key$ is an \lexicalnonterminal{Identifier} or 
% \verb'*' and $\nsval$ is a \hyperref[def:nsval]{namespace value}.
% \end{definition}

% \N
% A \hyperref[def:qualifier-assoc]{qualifier association}, introduced by a
% \nonterminal{UseDirective}, \nonterminal{ImportDirective},
% \nonterminal{PackageDirective}, \nonterminal{ClassDefinition}, or \nonterminal{Program}, pairs a \hyperref[def:nsval]{namespace value} with either a specific \lexicalnonterminal{Identifier} or all \lexicalnonterminal{Identifier}s
% (\verb'*'). 
% The \hyperref[def:nsval]{namespace value} may be used to qualify any
% \nonterminal{Identifier}s paired with it by the \hyperref[def:qualifier-assoc]{qualifier association}.

% \N
% Upon visiting an \hyperref[def:opening-scope]{opening scope}, a set of \hyperref[def:qualifier-assoc]{qualifier
% associations} is created for that opening scope, which are used to qualify any \nonterminal{UnqualifiedName}s
% that are nested by that \hyperref[def:opening-scope]{opening scope} without crossing another \hyperref[def:opening-scope]{opening
% scope}.


\section{Resolution}

\N
At compile time, \nonterminal{ReferenceExpression}s that
are \lexicalnonterminal{Identifier}s are transformed to references,
as follows. Let $\id$ be an identifier that is nested by a scope $\emph{Scope}$ without
crossing another scope. Then $\id$ is transformed to
the reference $\emph{ref}$, returned by
the following computation.

\begin{enumerate}
\item 
 If there is a lexical binding of the form $(\id, \emph{def})$ in the lexical environment
associated with $\emph{Scope}$, return $\id$. Furthermore, if the
enclosing scope \emph{Scope'} of \emph{def} nests 
\emph{Scope}, then record the
fact that $\id$ is resolved in all scopes that nest \emph{Scope}
without crossing \emph{Scope'}.
\item If $\emph{Scope}$ is enclosed by the instance scope of a
  \nonterminal{ClassDefinition} that has a lexical binding of the form
  $(\id,\emph{def})$, then
% \begin{enumerate}
% \item Let $P.C$
%   be the qualified class name of the \nonterminal{ClassDefinition} nesting \emph{def}. 
% \item If $P.C$ is the
%   qualified class name of \emph{Scope}, or if \emph{def} is marked {\tt
%     public} or {\tt protected}, or if $P.C'$ is the
%   qualified class name of \emph{Scope} and \emph{def} is marked {\tt
%     internal}, then 
return the member reference \verb'this'.\id. 
\item If $\emph{Scope}$ is enclosed by the static scope of a
  \nonterminal{ClassDefinition} that has a lexical binding of the form
  $(\id,\emph{def})$, then return the lexical reference
  ${\bf static}.\id$.  
\item If $\id$ appears where a
  \nonterminal{NominalType} is expected, it must resolve to a type (class or interface).  If there is a unique $P$ such that either a type of the form
${\bf internal::}P.\id$ in the global lexical environment and $P$ is the package name of the
enclosing unit, or a type of the form $P.\id$ is in the global lexical
environment and either $P$ is empty, or $P$ is
the package name of the enclosing unit, or there is an import of the form $P.\id$
  or $P.\verb'*'$ in the enclosing unit, then return the fully
  qualified name of the
  type. 
\item Otherwise, report an error.
% \item If there is a lexical binding for $\id$ in the static scope of
%   the main class, return ${\bf .main}.\id$.
\end{enumerate}



\section{Building Lexical Environments}

\subsection{Global Scopes}

\N
The definition corresponding to each fully qualified name in a
\nonterminal{ClassInheritance} must be a
\nonterminal{ClassDefinition}, and the definition corresponding to each fully qualified name in a
\nonterminal{InterfaceInheritance} must be a
\nonterminal{InterfaceDefinition}, otherwise an error is reported.

\N
A class must not recursively extend itself, and an interface must not
recursively extend itself, otherwise an error is reported.

\N
At compile time, definitions of classes and interfaces are visited in
topologically-sorted order following the \verb'extends' relation.

% \subsection{Visiting the Main Class}

% \N
% The lexical environment of the static scope of the main class contains lexical
%   bindings for the names
%   and definitions of 
%   variables functions in it, including the static
%   constructor. Synthesizing these lexical bindings involves resolving
%   the type of each such variable, and the types of the parameters and
%   the result of each such function. Furthermore:
% \begin{enumerate}
% \item A name must correspond to either a variable, or a function
%   without an accessor kind, or a function with an accessor kind
%   (getter or setter).
% \item For any variable, if there are multiple
%   lexical bindings with the same name, then their types and access
%   controls must match, and
%   only one is retained.
% \item For any function without an accessor kind, or for any getter or
%   setter, there must be exactly one definition with
%   a function body, unless it is marked \verb'native'.
% \item For any function without an accessor kind, or for any getter or
%   setter with the same accessor kind, if there are multiple
%   lexical bindings with the same name,
%   then their signatures (the types of the parameters and the result of
%   each of their definitions), access controls, and attributes must match, and only the one whose
%   definition has a
%   function body or is marked \verb'native' is retained.
% \item For any pair of functions with the same name but complementary
%   accessor kinds (i.e., forming a getter/setter pair), their signatures must be complementary.
% \end{enumerate}


\N
Upon visiting an \nonterminal{InterfaceDefinition}, any
types appearing in its metadata must be resolved. The lexical environment of an interface body contains lexical
  bindings for the names
  and definitions of 
  functions in it, as well as the lexical bindings of any interface it
  extends. These involve the resolution of types in their signatures and metadata. 
\begin{enumerate}
\item A name must correspond to either a function
  without an accessor kind, or a getter or setter.
\item If there
  are multiple definitions with the same name in this scope, an error
  is reported unless they form a getter/setter pair. 
\item If there
  are multiple lexical bindings with the same name for a
  function, and the function does not have an
  accessor kind  or is a getter or setter with the same accessor kind, then
  their signatures must match, and only one is retained. 
\item If there
  is a getter/setter pair, then
  their signatures must be complementary.
\end{enumerate}

\N
Upon visiting a \nonterminal{ClassDefinition}, any types appearing in
its metadata must be resolved. The class extended by the class must not be marked \verb'final'.
\begin{enumerate}
\item 
 The lexical environment of the static scope of a class body contains lexical
  bindings for the names
  and definitions of 
  variables and functions in it, including the static constructor, as
  well as any non-conflicting lexical bindings (i.e., with distinct identifiers) of the static scope
  for any class it extends. These involve the resolution of the types
  and metadata of the variables and the types in the signatures and
  the metadata of the functions that appear in
  it.
\begin{enumerate}
 \item If there are multiple variables or functions with the same name
  in this scope, an error is reported unless they form a getter/setter
  pair. 
\item If there
  is a getter/setter pair, then
  their signatures must be complementary.
\end{enumerate}

\item 
 The lexical environment of the instance scope of a class body contains lexical
  bindings for the names
  and definitions of 
  variables and functions in it, including the (instance) constructor,
  as well as the lexical bindings of the instance scope
  for any class it extends. These involve the resolution of the types
  and metadata of the variables and the types in the signatures and
  the metadata of the functions that appear in
  it.
\begin{enumerate}
\item There must not be any conflicts between the lexical bindings of
  the instance scope and the static scope of the class body.
\item A name must correspond to either a variable, or a function
  without an accessor kind, or a getter or setter.
\item If there
  are multiple definitions with the same name in this scope, an error
  is reported unless they form a getter/setter pair. 
\item For any variable, if there are two
  lexical bindings with the same name, an error is reported.
\item If there
  are two lexical bindings with the same name for a
  function:
\begin{enumerate} 
\item If there
  is a getter/setter pair, then
  their signatures must be complementary.
\item For a function that does not have an
  accessor kind, or for a getter or setter with the same accessor kind,  
  their signatures and access controls must match, and only the one 
  defined in this scope is retained. Furthermore, only in such a case
  may the function defined in this scope be marked \verb'override'. Finally,
  the function not defined in this scope must not be marked
  \verb'final'.
\end{enumerate}
\item For every function in the lexical binding of every interface implemented by the
  class, there must be a lexical binding for a function in the
  instance scope of the class, that has a matching signature and is marked \verb'public'.
\end{enumerate}
\end{enumerate}

\N
For any other scope \emph{Scope}, we build the lexical environment of
that \emph{Scope} as described in the next section.


% \begin{definition}[QNames bound in an environment table] The set of
%   QNames bound in a non-dynamic environment table includes the QName of any
%   lexical binding contained in the environment table, and is closed
%   under the following rule for the environment table associated with
%   the instance block of a \nonterminal{ClassDefinition}: if ${\bf
%     Protected}_{C}{\tt ::}\emph{str}$ is bound in the environment
%   table for class name $C$ and string \emph{str}, and $C'$ is the base
%   class of $C$, then ${\bf
%     Protected}_{C'}{\tt ::}\emph{str}$ is also bound in the environment
%   table.
% \end{definition}

% \begin{definition}[Lookup structure for building lexical environments] Evaluation of names for
% building lexical environments is characterized by the following lookup
% structure.
% \begin{enumerate}
% \item {\bf Result}s are namespace values and QNames (of class definitions)
% \item {\bf Binding}s are lexical bindings, with:
% \begin{enumerate}
% \item the function {\sf
%     read}(\emph{LexBinding}) defined as follows:
% \begin{enumerate}
% \item Let $\emph{QName}$ be the key and
%   $\emph{Definition}$ be the \nonterminal{Definition} of \emph{LexBinding}.
% \item If \emph{Definition} is a \nonterminal{NamespaceDefinition}, return
%   the namespace value in its \nonterminal{NamespaceInitializer}.
% \item If \emph{Definition} is a \nonterminal{ClassDefinition}, return
%   \emph{QName}.
% \item Otherwise, report a ``not compile-time constant'' error.
% \end{enumerate}
% \end{enumerate}

% \item {\bf Container}s are environment tables (and {\bf Container}
%   lists are lexical environments)
% \item The function {\sf lookup}(\emph{Name}, \emph{EnvTable}) is defined as follows:
% \begin{enumerate}
% \item If \emph{Name} is not a Multiname, report a ``not compile-time
%   constant'' error.
% \item If \emph{EnvTable} is dynamic, report a ``not compile-time
%   constant'' error.
% \item Otherwise, let \emph{Names} be the set of QNames corresponding
%   to the Multiname.
% \item Let \emph{Fixed} be the set of QNames that are bound in the
%   \emph{EnvTable}.
% \item Let \emph{Candidates} be the intersection of \emph{Names} and
%   \emph{Fixed}.
% \item If \emph{Candidates} has multiple lexical bindings, report an ``ambiguous reference'' error.
% \item if \emph{Candidates} has a single QName, then:
% \begin{enumerate}
% \item If there are multiple lexical bindings corresponding to the QName in the
%   environment table, report a ``not compile-time constant'' error.
% \item Otherwise, return the lexical binding corresponding to the QName in the
%   environment table.
% \end{enumerate}
% \item If \emph{EnvTable} is the instance environment table of a class,
%   let \emph{EnvTable'} be its base. Let \emph{Name'} be \emph{Name}
%   with any {\bf Protected} namespace value renamed by its base. Invoke
%   {\sf lookup}(\emph{Name'}, \emph{EnvTable'}) and return the result,
%   if found.
% \item Otherwise, return a ``not found'' result.
% % \item If \emph{Candidates} is empty and \emph{EnvTable} is an instance
% %   environment table:
% % \begin{enumerate}
% % \item If \emph{EnvTable} is the instance environment table, then let
% %   \emph{EnvTable'} be its base. Return whatever is
% %   returned by {\sf lookup}(\emph{Name'}, \emph{EnvTable'}, \emph{super}) where
% %   \emph{Name'} renames any {\bf Protected} namespace in its namespace
% %   set with its base.
% % \end{enumerate}
% \end{enumerate}
% \item The function {\sf extract}(\emph{Result}, \emph{LexEnv}) is defined as follows:
% \begin{enumerate}
% \item If \emph{Result} is not a QName, report a ``not compile-time
%   constant'' error.
% % \item If \emph{super} is true, let \emph{EnvTable} be the instance environment
% %   table associated with the enclosing class definition. Return the
% %   base of \emph{EnvTable}.
% \item Otherwise, invoke {\sf typeDef}(\emph{Result}, \emph{LexEnv})
%   (see the ``Static Verification'' chapter),
%   yielding the definition \emph{Definition}.
% \item If \emph{Definition} is a \nonterminal{ClassDefinition},
%   return the environment table associated with its static block.
% \item Otherwise, report a ``not compile-time constant'' error.
% \end{enumerate}
% \item the function {\sf eval}(\emph{Expression}, \emph{LexEnv})
%   function extends the default definition for reads, writes, and calls
%   of references as follows:
% \begin{enumerate}
% \item If \emph{Expression} is a namespace value, return that namespace
%   value.
% \item Otherwise, report a ``not compile-time constant''
%   error.
% \end{enumerate}
% \end{enumerate}
% \end{definition}

%\subsection{Resolution of Expanded Names}\label{sec:evaluation-of-names-of-expanded}

% \begin{definition}[\hyperref[def:xname]{expanded name} resolution]
% Resolving an \hyperref[def:xname]{expanded name} $\xname$ in a \hyperref[def:lexenv]{lexical environment} $\lexenv$, denoted
% $\func{resolve}(\xname,\lexenv)$, returns a slot (or reports an error), as follows:
% \begin{enumerate}
% \item If $\xname$ is a namespace value $\nsval$, return ${\bf namespace}(\nsval)$.
% \item If $\xname$ is a \hyperref[def:Multiname]{Multiname} $\mname$:
% \begin{enumerate}
% \item Let $(\qname, \slot) = \func{lookup}(\mname,
%   \lexenv)$. 
% \item Return $\slot$.
% \end{enumerate}
% \item Otherwise $\xname$ is an expanded qualified name $\xname' {\tt::} \id$.
% \begin{enumerate}
% \item Let $\nsval = \func{narrow}(\xname',
%   \lexenv)$.
% \item Let $(\qname,\slot) = \func{lookup}(\{\nsval\} {\tt::}
%   \id, \lexenv)$. 
% \item Return $\slot$.
% \end{enumerate}
% \end{enumerate}
% \end{definition}

% \N
% An \hyperref[def:xname]{expanded name} is resolved by a \hyperref[def:lexenv]{lexical environment} 
% to a \hyperref[def:lexbinding]{lexical binding}. Resolution always ends in the lookup of a
% \hyperref[def:Multiname]{Multiname}.

% \begin{definition}[Expanded name resolution]\label{def:resolution}
% Resolving an \hyperref[def:xname]{expanded name} $\xname$ in a \hyperref[def:lexenv]{lexical environment} 
% $\lexenv$, denoted $\func{resolve}(\xname,\lexenv)$, returns a \hyperref[def:lexbinding]{lexical binding} 
% (or reports an error), as follows:
% \begin{enumerate}
% %\item If $\xname$ is a namespace value $\nsval$, return $\nsval$.
% \item If $\xname$ is a \hyperref[def:Multiname]{Multiname} $\mname$:
% \begin{enumerate}
% \item Compute $\func{lookup}(\mname,
%   \lexenv)$, yielding a result $R$.
% \item If $R$ is a lexical binding, return $R$.
% \item Otherwise, report an error.
% \end{enumerate}
% \item Otherwise $\xname$ is an expanded qualified name $\xname' {\tt::} \id$.
% \begin{enumerate}
% \item Compute $\func{resolve}(\xname',
%   \lexenv)$, yielding a result $R'$.
% \item If $R'$ is a lexical binding and the constant value of the
%   lexical binding is a \hyperref[def:nsval]{namespace value} $\nsval$: 
% \begin{enumerate}
% \item Compute $\func{lookup}(\{\nsval\} {\tt::}
%   \id, \lexenv)$, yielding a result $R$.
% \item If $R$ is a lexical binding, return $R$.
% \item Otherwise, report an error. 
% \end{enumerate}
% \item Otherwise, report an error.
% \end{enumerate}
% \end{enumerate}
% \end{definition}

% \begin{definition}[Multiname lookup]\label{def:lookup}
% The lookup of a \hyperref[def:Multiname]{Multiname} $\mname$ in a \hyperref[def:lexenv]{lexical environment} $\lexenv$, denoted 
% $\func{lookup}(\mname, \lexenv)$, returns a \hyperref[def:lexbinding]{lexical binding} (or reports an error), as follows:
% \begin{enumerate}
% \item If $\lexenv$ is the empty list, return the name-not-found result.
% \item Otherwise, $\lexenv$ contains an \hyperref[def:envtable]{environment table} $\{(\qname_1,\slot_1),
%   \dots, (\qname_l, \slot_l)\}$ followed by a \hyperref[def:lexenv]{lexical environment}
%   $\lexenv'$. Suppose that $\mname$ is $\{\nsval_1,\dots,\nsval_k\}
%   {\tt::} \id$.
% \begin{enumerate}
% \item Let $\mathcal J$ be the set of all $j \in
%   \{1,\dots,l\}$ such that $\qname_j
%   = \nsval_i {\tt::} \id$
% for some $i \in \{1,\dots,k\}$. 
% \item If $\mathcal J$ is the empty set, return $\func{lookup}(\mname, \lexenv')$.
% \item If $\mathcal J$ contains a single $j$, return $(\qname_j,\slot_j)$.
% \item Otherwise, return the ambiguous-name result.
% \end{enumerate}
% \end{enumerate}
% \end{definition}


% {\bf Example.} The following code shows how \hyperref[def:Multiname]{Multiname} \hyperref[def:resolution]{resolution} is sensitive to scopes. \hyperref[def:lexenv]{Lexical 
% environments}, which are set up as described in Section \ref{sec:init-env}, ensure that slots for 
% definitions in inner scopes shadow slots for definitions in outer scopes.

% \begin{lstlisting}
% package p {
%     public var x;            // package variable
%     class A {
%         private var x;       // instance variable
%         function f(x) {      // local variable
%             return x;        // \hyperref[def:resolution]{resolves} to \verb'internal::x' (local variable)
%         }
%     }
% }
% \end{lstlisting}

% \begin{lstlisting}
% package p {
%     public var x;            // package variable
%     class A {
%         private var x;       // instance variable
%         function f() {
%             return x;        // \hyperref[def:resolution]{resolves} to \verb'private::x' (instance variable)
%         }
%     }
% }
% \end{lstlisting}

% \begin{lstlisting}
% package p {
%     public var x;            // package variable
%     class A {
%         function f() {
%             return x;        // \hyperref[def:resolution]{resolves} to \verb'p.x' (package variable)
%         }
%     }
% }
% \end{lstlisting}



\subsection{Local Scopes}\label{sec:lexenv}

\N Building \hyperref[def:lexenv]{lexical environments} for local scopes involves
synthesizing \hyperref[def:lexbinding]{lexical bindings} for local variables 
and local functions in the \nonterminal{Program}. (Lexical bindings for
classes and interfaces, as well as their member variables and member functions, are synthesized as described in the previous section.)

\N \hyperref[def:lexenv]{Lexical environments} for local scopes are built by processing
them in
depth-first (textual) order. 
% In particular, this
% means that we visit opening
%   scopes and \hyperref[def:binding-scope]{binding scopes} in ``last-in-first-out'' order, and we visit
%   \nonterminal{UseDirective}s, 
% \nonterminal{ImportDirective}s, and \nonterminal{Definition}s
%   in the order in which they appear. 


% \N
% Names are transformed in a context-sensitive manner, by desugaring
% reserved namespaces and package names as sets of
% \hyperref[def:nsval]{namespace values}, as defined in Section
% \ref{sec:reserved-ns}, and expanding unqualified names and brackets with sets of \hyperref[def:nsval]{namespace values}, as defined in Section \ref{}.

% The \nonterminal{UseDirective}s and
%   \nonterminal{ImportDirective}s in this scope are processed in the
%   order in which they appear, and \hyperref[def:qualifier-assoc]{qualifier associations} introduced by
%   them are cumulatively
%   expanded, resolved and included in the set of \hyperref[def:qualifier-assoc]{qualifier associations}
%   associated with this scope, as described in Section \ref{sec:imports-uses}.



% \begin{enumerate}
% \item Pre-processing of \hyperref[def:opening-scope]{opening scopes}
% \begin{enumerate}
% \item Interpretation of reserved namespaces and package names
% \item Initialization of \hyperref[def:qualifier-assoc]{qualifier associations}
% \item Processing of imports and uses of namespaces
% \end{enumerate}
% \item Processing of \hyperref[def:binding-scope]{binding scopes}: initialization of \hyperref[def:envtable]{environment tables}
% \item Processing of definitions
% \begin{enumerate}
% \item Expanding and narrowing namespace names and inherited names
% \item Synthesis of \hyperref[def:lexbinding]{lexical bindings}
% \end{enumerate}
% \item Post-processing of \hyperref[def:opening-scope]{opening scopes}
% \begin{enumerate}
% \item Resolution of \hyperref[def:qualifier-assoc]{qualifier associations}
% \end{enumerate}
% \end{enumerate}

% \subsection{Processing of Opening Scopes and Binding Scopes}\label{sec:opening-binding}

% \N
% A \hyperref[def:defining-scope]{defining scope} is itself an \hyperref[def:opening-scope]{opening scope}, and in addition, may
% nest other \hyperref[def:opening-scope]{opening scopes} without crossing another \hyperref[def:defining-scope]{defining
% scope}. 

% \N
% Upon visiting an \hyperref[def:opening-scope]{opening scope}, a set of
% \hyperref[def:qualifier-assoc]{qualifier associations} is introduced
% in a context-sensitive manner,
% and the \hyperref[def:qualifier-assoc]{qualifier associations} associated with
%   the immediately enclosing \hyperref[def:opening-scope]{opening
%     scope} are added to this set, as described in Section \ref{sec:init-qual-assocs}. 
%  This set of \hyperref[def:qualifier-assoc]{qualifier associations} is
%  grown upon visiting \nonterminal{UseDirective}s and
%  \nonterminal{ImportDirective}s in that opening scope, and used to
%  \hyperref[def:expansion]{expand} any names that appear in the \hyperref[def:opening-scope]{opening scope}. 


% \N
% A \hyperref[def:defining-scope]{defining scope} is itself a \hyperref[def:binding-scope]{binding scope}, and in addition, may
% nest other \hyperref[def:binding-scope]{binding scopes} without crossing another \hyperref[def:defining-scope]{defining
% scope}. 

% \N Upon visiting a \hyperref[def:binding-scope]{binding scope}, an \hyperref[def:envtable]{environment table} is introduced
% in a context-sensitive manner to store
% information on \nonterminal{Definition}s that appear in this binding scope, and a \hyperref[def:lexenv]{lexical environment} is set up to retrieve such information, by chaining the
% \hyperref[def:envtable]{environment table} to the \hyperref[def:lexenv]{lexical environment} of the immediately
% enclosing \hyperref[def:binding-scope]{binding scope}, as described in
%   Section \ref{sec:init-env}. This environment table is grown upon
%   visiting \nonterminal{Definition}s in that
% \hyperref[def:binding-scope]{binding scope}. 





% \subsubsection{Initialization of Qualifier Associations}\label{sec:init-qual-assocs}

% \N
% The following are aliases of \hyperref[def:nsval]{namespace values} that are implicitly constructed upon visiting
% the \hyperref[def:opening-scope]{opening scope}.

% \begin{enumerate}

% \item $\fileinternal{prog}$ is an alias for the \hyperref[def:nsval]{namespace value}
%   constructed by ${\bf private}()$ upon visiting the \nonterminal{Program}.

% \item $\packagepublic{\pkg}$ is an alias for the \hyperref[def:nsval]{namespace value}
%   constructed by ${\bf public}($\verb`"`$\pkg$\verb`"`$)$ upon visiting a
%   \nonterminal{PackageDirective} whose \nonterminal{PackageName} is 
%   $\pkg$. 

% \item $\packagepublic{}$ is an alias for the \hyperref[def:nsval]{namespace value}
%   constructed by ${\bf public}($\verb`""`$)$ upon visiting a
%   \nonterminal{PackageDirective} without a \nonterminal{PackageName}.

% \item $\packageinternal{\pkg}$ is an alias for the \hyperref[def:nsval]{namespace value}
%   constructed by ${\bf internal}($\verb`"`$\pkg$\verb`"`$)$ upon visiting a
%   \nonterminal{PackageDirective} whose \nonterminal{PackageName} is $\pkg$.

% \item $\packageinternal{}$ is an alias for the \hyperref[def:nsval]{namespace value}
%   constructed by ${\bf internal}($\verb`""`$)$ upon visiting a
%   \nonterminal{PackageDirective} without a \nonterminal{PackageName}.

% \item $\classprivate{\mathsf{qnameClass}}$ is an alias for the \hyperref[def:nsval]{namespace value}
%   constructed by ${\bf private}()$ upon visiting the static block of a \nonterminal{ClassDefinition} whose \hyperref[def:qname]{QName} is $\mathsf{qnameClass}$.

% \item $\classprotected{\mathsf{qnameClass}}$ is an alias for the \hyperref[def:nsval]{namespace value}
%   constructed by ${\bf protected}(\mathsf{qnameClass})$ upon visiting
%   the instance block of a \nonterminal{ClassDefinition} whose
%   \hyperref[def:qname]{QName} is $\mathsf{qnameClass}$. If the base
%   class of the \nonterminal{ClassDefinition} is {\sf qnameBaseClass},
%   then the \emph{base} of ${\bf protected}(\mathsf{qnameClass})$ is
%   the namespace value ${\bf protected}(\mathsf{qnameBaseClass})$.

% \item $\classprotectedstatic{\mathsf{qnameClass}}$ is an alias for the \hyperref[def:nsval]{namespace value}
%   constructed by ${\bf staticprotected}(\mathsf{qnameClass})$ upon visiting the
%   static block of a \nonterminal{ClassDefinition} whose \hyperref[def:qname]{QName} is $\mathsf{qnameClass}$.

% \end{enumerate}


% \begin{definition}[Implicit qualifier associations]\label{def:implicit-qualifier-assoc}
% For every \hyperref[def:opening-scope]{opening scope}, there is a set of \emph{implicit qualifier associations} as follows: 

% \begin{enumerate}

% \item In a global context not nested by a \nonterminal{PackageDirective}, the set of implicit qualifier associations is 
% $\{({\tt*},\fileinternal{prog}),({\tt*},\packagepublic{})\}$.

% \item In a global context nested by a \nonterminal{PackageDirective}
%   whose \nonterminal{PackageName} is $\pkg$, the set of implicit qualifier 
% associations is $\{({\tt*},\packagepublic{\pkg}),
% ({\tt*},\packageinternal{\pkg})\}$. 

% \item In a global context nested by a \nonterminal{PackageDirective}
%   without a \nonterminal{PackageName}, the set of implicit qualifier 
% associations is $\{({\tt*},\packagepublic{}), ({\tt*},\packageinternal{})\}$. 

% \item In a class context nested by the static block of a \nonterminal{ClassDefinition} whose
%   \hyperref[def:qname]{QName} is $\qname$, the set of implicit qualifier associations is 
% $\{({\tt*},\classprivate{\mathsf{qnameClass}})\} \cup \func{StaticQuals}(\mathsf{qnameClass})$, where
% $\func{StaticQuals}(\mathsf{qnameClass})$ is defined (recursively) as follows:
% \begin{enumerate}
% \item If $\mathsf{qnameClass}$ denotes the root
%   class, then $\func{StaticQuals}(\mathsf{qnameClass}) = \{({\tt*}, \classprotectedstatic{\mathsf{qnameClass}})\}$.

% \item Otherwise, let $\mathsf{qnameBaseClass}$ denote the 
%   class that this \nonterminal{ClassDefinition} extends (which is the
%   root class if elided in the \nonterminal{ClassDefinition}). Then $\func{StaticQuals}(\mathsf{qnameClass}) = \{({\tt*}, \classprotectedstatic{\mathsf{qnameClass}})\} \cup
% \func{StaticQuals}(\mathsf{qnameBaseClass})$. 
% \end{enumerate}

% \item In a class context nested by the instance block of a \nonterminal{ClassDefinition} whose
%   \hyperref[def:qname]{QName} is $\qname$, the set of implicit qualifier associations is 
% $\{({\tt*},
% \classprotected{\mathsf{qnameClass}})\}$.

% \item In any other \hyperref[def:opening-scope]{opening scope}, the set of implicit qualifier associations is $\varnothing$. 

% \end{enumerate}

% \end{definition}


% \N
% The set of \hyperref[def:qualifier-assoc]{qualifier associations} $\xquals$ associated with an \hyperref[def:opening-scope]{opening scope}
% is initialized to be the union of the set of \hyperref[def:implicit-qualifier-assoc]{implicit qualifier
%   associations} for the \hyperref[def:opening-scope]{opening scope} and:
% \begin{enumerate}
% \item $\varnothing$ if the \hyperref[def:opening-scope]{opening scope} is the
%   \nonterminal{Program};
% \item otherwise, the set of \hyperref[def:qualifier-assoc]{qualifier associations} associated with the 
% immediately enclosing \hyperref[def:opening-scope]{opening scope}.
% \end{enumerate}


% \subsubsection{Initialization of Environment Tables and Setup of
%   Lexical Environment}\label{sec:init-env}




% \N Upon visiting the static block of a
%   \nonterminal{ClassDefinition}, a new \hyperref[def:lexenv]{lexical
%     environment} is associated with the scope that initially
% contains the lexical bindings in the lexical environment associated
% with the static block of the base class, and lexical bindings of the enclosing scope. 

% \N Upon visiting the instance block of a
%   \nonterminal{ClassDefinition}, a new \hyperref[def:lexenv]{lexical
%     environment} is associated with the scope that initially
% contains the lexical bindings in the lexical environment associated
% with the instance block of the base class, and lexical bindings of the
% enclosing scope. 

% \N Upon visiting an
%   \nonterminal{InterfaceBody}, a new \hyperref[def:lexenv]{lexical
%     environment} is associated with the scope that initially
% contains the lexical bindings in the lexical environments associated
% with the bodies of the base interfaces, and any
% lexical bindings of the enclosing scope. If the former lexical
% bindings conflict (i.e., they have the same identifier), then the
% corresponding function declarations must be the same; otherwise an
% error is reported.

\N Upon visiting a \nonterminal{FunctionBody}, a \hyperref[def:lexenv]{lexical
    environment} is associated with the scope that initially
contains lexical bindings for the parameters (see below), and any
non-conflicting lexical
bindings (i.e., with distinct identifiers) of the enclosing scope. Each
parameter introduces a typed binding, and thereby corresponds to a \nonterminal{VariableDefinition} (treated as
if it had \nonterminal{VariableDefinitionKind} \verb'let'). Thus, the lexical
binding for it is of the form $(\id,\emph{def})$, where $\id$ is the 
identifier of the typed binding, and \emph{def} is the \nonterminal{VariableDefinition} itself. The identifiers added must be
distinct; otherwise an error is reported.

\N Upon visiting a \nonterminal{CatchClause}, a \hyperref[def:lexenv]{lexical
    environment} is associated with the scope that initially
contains a lexical binding for the \nonterminal{TypedBinding} of the \nonterminal{CatchClause} (see below), and any
non-conflicting lexical bindings (i.e., with distinct identifiers) of the enclosing scope. The
\nonterminal{TypedBinding} corresponds to a \nonterminal{VariableDefinition} (treated as
if it had \nonterminal{VariableDefinitionKind} \verb'let'). Thus, the lexical
binding for it is of the form $(\id,\emph{def})$, where
$\id$ is the identifier of the \nonterminal{TypedBinding}, and
\emph{def} is the \nonterminal{VariableDefinition} itself.

\N Upon visiting a \nonterminal{Block}, a \hyperref[def:lexenv]{lexical
    environment} is associated with the scope that initially
contains the lexical bindings of the enclosing scope. 


% \subsection{Transformation of Names}\label{sec:name-transformation}

% \begin{definition}[Transformation of \nonterminal{PropertyName} in opening scope]
% In an opening scope, a
% \nonterminal{PropertyName} is transformed to a name as follows:
% \begin{enumerate}

% \item Reserved namespaces and package names are desugared
%   to namespace values in the
%   opening scope, as described
%   in Section \ref{sec:reserved-ns}.

% \item Occurrences of {\tt *} are desugared as follows:
% \begin{enumerate}
% \item If {\tt *} appears a \nonterminal{NamespaceExpression}, it is replaced by
%   the namespace value {\bf public}({\tt "*"}).
% \item Otherwise, {\tt *} is replaced by the \nonterminal{Brackets} {\tt ["*"]}
% \end{enumerate}

% \item \nonterminal{UnqualifiedName}s are expanded to Multinames and
%   \nonterminal{Brackets} are expanded to LMultinames in the opening scope, as described in Section
%   \ref{sec:expansion}.

% \item Occurrences of {\tt @} are desugared as follows:
% \begin{enumerate}
% \item The \nonterminal{XMLAttributeName} {\tt @}$\emph{qualifier} {\tt
%     ::} \emph{str}$, where $\emph{qualifier}$ is a namespace
%   expression or a set of namespace values, is replaced by
%   $\emph{qualifier}${\tt ::@}$\emph{str}$.
% \item The \nonterminal{XMLAttributeName} {\tt @.}$\emph{qualifier} {\tt ::}
%   [\emph{strexpr}]$, , where $\emph{qualifier}$ is a namespace
%   expression or a set of namespace values, is replaced by
%   {\tt .}$\emph{qualifier} {\tt ::} [${\tt "@"+}$\emph{strexpr}]$.
% \end{enumerate}

% \end{enumerate}
% \end{definition}

% \subsubsection{Desugaring of Reserved Namespaces and Package Names}\label{sec:reserved-ns}


% \N \nonterminal{ReservedNamespace}s, which appear either as 
% \nonterminal{NamespaceAttribute}s or in \nonterminal{QualifiedName}s, are desugared
% based on the \hyperref[def:opening-scope]{opening scope} in which they appear, as follows: 
% \begin{enumerate}
% \item In a global context that is not nested by a \nonterminal{PackageDirective}:

% \begin{enumerate}

% \item \verb'internal' is expanded to
%   $\fileinternal{prog}$. 

% \item A \nonterminal{NamespaceExpression} that is \verb'public' is expanded to 
%   the namespace value $\packagepublic{}$.

% \end{enumerate}

% \item In a global context nested by a \nonterminal{PackageDirective} whose \nonterminal{PackageName} is $\pkg$:
% \begin{enumerate}

% \item A \nonterminal{NamespaceAttribute} that is \verb'public' is
%   expanded to $\packagepublic{\pkg}$.

% \item A \nonterminal{NamespaceExpression} that is \verb'public' is
%   expanded to the set of namespace values $\{\packagepublic{}, \packagepublic{\pkg}\}$.

% \item \verb'internal' is expanded to $\packageinternal{\pkg}$.

% \end{enumerate}

% \item In a global context nested by a \nonterminal{PackageDirective} without a \nonterminal{PackageName}:
% \begin{enumerate}

% \item \verb'public' is expanded to $\packagepublic{}$.

% \item \verb'internal' is expanded to $\packageinternal{}$.

% \end{enumerate}

% \item In a class context nested by the static block of a \nonterminal{ClassDefinition} whose
%   \hyperref[def:qname]{QName} is $\mathsf{qnameClass}$: %, which extends a \nonterminal{ClassDefinition} whose \hyperref[def:qname]{QName} is $\qname'$:

% \begin{enumerate}

% \item \verb'public' is expanded to $\packagepublic{}$.

% \item \verb'internal' is expanded to whatever it would be expanded to in the
%   global context outside the \nonterminal{ClassDefinition}.

% \item \verb'private' is expanded to $\classprivate{\mathsf{qnameClass}}$.

% \item \verb'protected' is
%   expanded to $\classprotectedstatic{\mathsf{qnameClass}}$.

% \end{enumerate}


% \item In a class context nested by the instance block of a \nonterminal{ClassDefinition} whose
%   \hyperref[def:qname]{QName} is $\mathsf{qnameClass}$: %, which extends a \nonterminal{ClassDefinition} whose \hyperref[def:qname]{QName} is $\qname'$:

% \begin{enumerate}

% \item \verb'public' is expanded to $\packagepublic{}$.

% \item \verb'internal' is expanded to whatever it would be expanded to in the
%   global context outside the \nonterminal{ClassDefinition}.

% \item \verb'private' is expanded to $\classprivate{\mathsf{qnameClass}}$.

% \item A \nonterminal{NamespaceAttribute} that is \verb'protected' is
%   expanded to 
%   $\classprotected{\mathsf{qnameClass}}$.

% \item A \nonterminal{NamespaceExpression} that is \verb'protected' is expanded to 
%   the set of namespace values $\{\classprotectedstatic{\mathsf{qnameClass}}, \allowbreak \classprotected{\mathsf{qnameClass}}\}$.

% \end{enumerate}

% \item In any other \hyperref[def:opening-scope]{opening scope}, a \nonterminal{NamespaceAttribute} or a \nonterminal{NamespaceExpression} 
% that is a \nonterminal{ReservedNamespace} is expanded to whatever it would be expanded to in 
% the immediately enclosing \hyperref[def:opening-scope]{opening scope}. 
% \end{enumerate}

% \begin{definition}[Package names known to an opening scope]
% The set of package names known to a \nonterminal{Program} include the
% package names known to the library that the \nonterminal{Program} is
% compiled against, and any \nonterminal{PackageName}s that appear in 
%  the \nonterminal{Program} without crossing another opening scope.
% The set of package names known to any other opening scope include 
%   any \nonterminal{PackageName}s that appear in 
%  that opening scope without crossing another opening scope, and
%  the package names known to the immediately enclosing opening scope.
% \end{definition}

% \N
% Any reference of the form $\pkg{\tt.}\id$ in an opening scope, where $\id$ is an \lexicalnonterminal{Identifier} and 
% $\pkg$ is a \nonterminal{PackageName} that is known to that opening
% scope, is replaced by the reference $\packagepublic{\pkg}{\tt::}\id$. 


% \N
% {\bf Example.} The following code shows the translation of reserved namespaces to their corresponding
% \hyperref[def:nsval]{namespace values} in various syntactic contexts.

% \begin{lstlisting}
% package P {
%     public class A {
%         private var a;              // ${\bf Private}_A\verb'::a'$, where $A$ is ${\bf Public}_{\verb`P`}\verb'::A'$
%         protected var b;            // ${\bf Protected}_A\verb'::b'$, where $A$ is ${\bf Public}_{\verb`P`}\verb'::A'$
%         protected static var b;     // ${\bf StaticProtected}_A\verb'::b'$, where $A$ is ${\bf Public}_{\verb`P`}\verb'::A'$
%         var x;                      // ${\bf Internal}_{\verb`P`}\verb'::x'$
%         public var y;               // ${\bf Public}\verb'::y'$
%         function f(z) {             // ${\bf Internal}_{\verb`P`}\verb'::z'$
%             private::a              // ${\bf Private}_A\verb'::a'$, where $A$ is ${\bf Public}_{\verb`P`}\verb'::A'$
%             protected::b            // $\{{\bf StaticProtected}_A,{\bf Protected}_A\}\verb'::b'$, where $A$ is ${\bf Public}_{\verb`P`}\verb'::A'$
%             internal::x;            // ${\bf Internal}_{\verb`P`}\verb'::x'$
%             public::y;              // ${\bf Public}\verb'::y'$
%             P.z;                    // ${\bf Public}_{\verb'P'}\verb'::z'$
%         }
%     }

%     var x;                          // ${\bf Internal}_{\verb`P`}\verb'::x'$
%     public var z;                   // ${\bf Public}_{\verb'P'}\verb'::z'$
%     function f(z) {                 // ${\bf Internal}_{\verb`P`}\verb'::z'$
%         internal::x;                // ${\bf Internal}_{\verb`P`}\verb'::x'$
%         internal::z;                // ${\bf Internal}_{\verb'P'}\verb'::z'$
%         public::z;                  // ${\bf Public}_{\verb'P'}\verb'::z'$
%     }
% }

% var c;                              // ${\bf Program}\verb'::c'$
% internal::c;                        // ${\bf Program}\verb'::c'$
% \end{lstlisting}

% \subsubsection{Expansion of Unqualified Names and Brackets}\label{sec:expansion}

% \N
% \nonterminal{UnqualifiedNames} and \nonterminal{Brackets} are expanded
% to Multinames and LMultinames, based on the opening scope in which
% they appear, as follows. Let  $\xquals$ be the set of
% \hyperref[def:qualifier-assoc]{qualifier associations} associated with
% the opening scope.
% \begin{enumerate}
% \item An \nonterminal{UnqualifiedName} $\id$ is replaced by
%   $\emph{NSVals} {\tt::} \id$, where $\emph{NSVals}$ is the set of all \hyperref[def:nsval]{namespace values} $\nsval$
%   such that $(\id, \nsval) \in \xquals$ or
%   $({\tt*}, \nsval) \in \xquals$.
% \item A \nonterminal{Brackets}
%   ${\tt[}\mathsf{expr}{\tt]}$ is
%   replaced by 
%   ${\tt.}\emph{NSVals}{\tt::[}\mathsf{expr}{\tt]}$,
%   where 
%   $\emph{NSVals}$ is the set of namespace values $\nsval$ such that $({\tt*},\nsval) \in \xquals$.
% % \item A
% %   \nonterminal{XMLAttributeName} of the form
% %   ${\tt@[}\mathsf{expr}{\tt]}$, where
% %   ${\tt[}\mathsf{expr}{\tt]}$ is a \nonterminal{Brackets},  is
% %   replaced by the syntax tree ${\tt@}\emph{NSVals}{\tt::[}\mathsf{expr}{\tt]}$,
% %   where $\emph{NSVals}{\tt::[}\mathsf{expr}{\tt]}$
% %   is a LMultiname.
% \end{enumerate}


% \N In this section, we specify
% how the set of \hyperref[def:qualifier-assoc]{qualifier associations} associated with an \hyperref[def:opening-scope]{opening scope}
% is built by considering the \nonterminal{UseDirective}s and
% \nonterminal{ImportDirective}s in the \hyperref[def:opening-scope]{opening scope} in the order in
% which they appear. As the set of \hyperref[def:qualifier-assoc]{qualifier associations} is built, it can be used to
% \hyperref[def:expansion]{expand} \nonterminal{UnqualifiedName}s that appear in that \hyperref[def:opening-scope]{opening
% scope}, as required. Furthermore, we specify how the \hyperref[def:lexenv]{lexical environment} associated
% with a \hyperref[def:binding-scope]{binding scope} is built by considering the
% \nonterminal{Definition}s in the \hyperref[def:binding-scope]{binding scope} in the order in which
% they appear. As the \hyperref[def:lexenv]{lexical environment} is built, it can be used to
% \hyperref[def:resolution]{resolve} Multinames that appear in that
% \hyperref[def:binding-scope]{binding scope}, as required. By the end of this section, for every \hyperref[def:opening-scope]{opening scope} in the
% \nonterminal{Program}, we can finalize the set of \hyperref[def:qualifier-assoc]{qualifier
% associations} initialized in Section \ref{sec:init-qual-assocs}, which can then be used to
% expand any remaining \nonterminal{UnqualifiedName}s in that \hyperref[def:opening-scope]{opening
% scope}. Furthermore, for every \hyperref[def:binding-scope]{binding scope} in the
% \nonterminal{Program}, we can finalize the \hyperref[def:lexenv]{lexical environment}
% initialized in Section \ref{sec:init-env}, which can then be used to
% \hyperref[def:lookup]{look up} any remaining \hyperref[def:Multiname]{Multinames} in that
% \hyperref[def:binding-scope]{binding scope}. 

% \N For any \nonterminal{ImportDirective} or
% \nonterminal{UseDirective}, let the immediately enclosing \hyperref[def:opening-scope]{opening scope} be associated with the set
% of \hyperref[def:qualifier-assoc]{qualifier associations} $\xquals$. The
% \nonterminal{ImportDirective} or \nonterminal{UseDirective} is processed in the following two steps, as elaborated below:
% \begin{enumerate}
% \item The namespace name that appears in the
% directive is evaluated.
% \item Based on the evaluation of the namespace name, a \hyperref[def:qualifier-assoc]{qualifier association} is
%   synthesized and added to $\xquals$. 
% \end{enumerate}

% \N For any \nonterminal{Definition}, let the immediately enclosing \hyperref[def:binding-scope]{binding scope} be associated with the \hyperref[def:lexenv]{lexical environment} $\lexenv$,
% and the immediately enclosing \hyperref[def:opening-scope]{opening scope} be associated with the set
% of \hyperref[def:qualifier-assoc]{qualifier associations} $\xquals$. The
% \nonterminal{Definition} is processed in the following two steps, as elaborated below:
% \begin{enumerate}
% \item Namespace names (namespace attributes
% or namespace
% initializers) or inherited type names (type names for inherited classes and interfaces) that appear in the
% definition are evaluated.
% \item Based on the evaluations of the namespace names and inherited
%   type names, a \hyperref[def:lexbinding]{lexical binding} for the \lexicalnonterminal{Identifier} in the
%   definition is synthesized and added to an \hyperref[def:envtable]{environment table} in
%   $\lexenv$. 
% % , unless doing so makes the definition 
% %   \emph{duplicate} or \emph{ambiguous}. Roughly, a definition is considered duplicate if there is another
% %   definition in the current \hyperref[def:binding-scope]{binding scope} with the same
% %   \lexicalnonterminal{Identifier} and the same \hyperref[def:nsval]{namespace value}. A definition is
% %   considered ambiguous if there is another definition in the current
% %   \hyperref[def:binding-scope]{binding scope} with the same \lexicalnonterminal{Identifier}, and
% %   the \hyperref[def:nsval]{namespace values} of both definitions are open in the current
% %   \hyperref[def:opening-scope]{opening scope}. 
% \end{enumerate}

% %\avik{With Section \ref{sec:expansion}, the following two sections replace its namesake in the syntax chapter (beta-1).}




% For the package without a name, we assume that the namespaces
% $\packagepublic{}$ and $\packageinternal{}$ are pre-defined. Finally,
% for any file ${\it foo}$, we assume that the namespace
% $\fileinternal{foo}$ is pre-defined. (Below, we assume that the
% program is in file ${\it foo}$.)

% The pre-defined namespaces above are treated as if they were
% \nonterminal{NamespaceName}s, even though they may not be expressible in
% the syntax of the language. 
% In particular, some of them may
% be initialized with ``unforgeable'' strings that do not appear as
% \nonterminal{NamespaceInitializer}s in the program.

% \N
% Any definition in a \hyperref[def:global-context]{global context}, \hyperref[def:class-context]{class context}, or \hyperref[def:interface-context]{interface context} that does
% not have a \nonterminal{NamespaceAttribute} is treated as if it were \hyperref[def:mark]{marked} \verb'internal'.

% \subsection{Translating {\tt public} and {\tt internal}}

% \N
% Any appearance of \terminal{public} or
% \terminal{internal} that is in a \hyperref[def:global-context]{global context} and is nested by a \nonterminal{PackageDirective} whose \nonterminal{PackageName} is
% $A$ is replaced by $\packagepublic{A}$ or $\packageinternal{A}$,
% respectively. Furthermore, any other appearance of 
% \terminal{public} or \terminal{internal} that is nested by that
% \nonterminal{PackageDirective} is replaced by 
% $\packagepublic{}$ or $\packageinternal{A}$, respectively. 
% % (This includes uses as namespace names 
% % as well as namespace expressions.)

% \N
% Any appearance of \terminal{public} or \terminal{internal} that is in a
% \hyperref[def:global-context]{global context} and is nested by a \nonterminal{PackageDirective} without a
% \nonterminal{PackageName} is replaced by 
% $\packagepublic{}$ or $\packageinternal{}$, respectively. 

% \N
% Any appearance of \terminal{internal} that is not nested by a
% \nonterminal{PackageDirective} is replaced by 
% $\fileinternal{foo}$. 

% \begin{definition}[Namespace in use] A \nonterminal{NamespaceName} $A$ is \emph{in use} for an
%   \lexicalnonterminal{Identifier} $x$ if $x$ is in the scope of
%   a \nonterminal{UseDirective} of the form
%   \verb'use namespace '$A$ or \verb'use namespace '$A$\verb`[`$x$\verb`]`.
% \end{definition}







% \begin{definition}[Implicit qualifier association] Let $R$ be a set of namespace
%   associations and $\rname$ be a expanded name. Then $R :: \rname$ is a
%   compile-time name that denotes the \emph{implicit qualifier association} of
%   $\rname$ with $R$, and is defined recursively as follows. 
% \begin{enumerate}
% \item $R :: v = v$ 
% \item $R :: i = \{\rname {\tt::} i~|~(i, \rname) \in R \mbox{ or }({\tt*}, \rname) \in R\}$ 
% \item $R :: (\rname {\tt::} i) = (R :: \rname) {\tt::} i$
% %\item $R :: (\rname :: i) = \{\rname' :: i ~|~ \rname' \in R :: \rname\}$
% \end{enumerate}
% \end{definition}

% \begin{definition}[Qualifier Association] Let $R$ be a set of namespace
%   associations and $(x,A)$ be a qualifier association. If $A$ is not a
%   predefined namespace, then $R :: (x, A) = \{(x, \rname {\tt::} A)~|~(A,
%   \rname) \in R \mbox{ or }({\tt*}, \rname) \in R\}$. If $A$ is a predefined
%   namespace, then $R :: (x, A) = \{(x, A)\}$.
% \end{definition}

% \begin{definition}[Flattening] Flattening turns a compile-time name into
%   a set of expanded names, as follows.
% \begin{enumerate}
% \item $\| v \| = \{ v \}$
% \item $\| \mathcal M \| = \mathcal M$
% \item $\| \xname {\tt::} i \| = \{ \rname {\tt::} i~|~ \rname \in \|\xname\| \}$
% \end{enumerate}
% \end{definition}



% \begin{definition}[Growing expanded qualifier associations] Suppose that we have a set of expanded qualifier 
% associations $\xquals$ followed by an ordered list of qualifier associations $\cquals$. Then 
% $\func{Grow}(\xquals,\cquals)$ denotes a set of expanded qualifier associations obtained by \emph{growing} 
% $\xquals$ with $\cquals$, defined recursively as follows:

% \begin{enumerate}

% \item If $\cquals$ is the empty list, return $\xquals$.

% \item Otherwise, $\cquals$ contains a qualifier association $(\key, \rname)$
%   followed by a list $\cquals'$.
% \begin{enumerate}
% \item Let $\xname = \func{expand}(\xquals, \rname)$.
% \item Let $\xquals'$ be the set obtained by adding the expanded
%   qualifier association $(\key, \xname)$ to $\xquals$.
% \item Return $\func{Grow}(\xquals', \cquals')$.
% \end{enumerate}

% %\item $\xquals \lhd [(\key, \xname {\tt::} i); S] = (\xquals \cup \{(\key,\xname' {\tt::} i)~|~\xname' \in \xquals :: \xname\}) \lhd S$

% %\item $\xquals \lhd [(\key, \nsval); S] = (\xquals \cup \{(\key, \nsval)\}) \lhd S$

% \end{enumerate}

% \end{definition}





% \avik{There is nothing more to say on static-protected namespaces
%   (they work just like other namespaces). For instance-protected
%   namespaces, definitions in a base class are copied into the subclass
% via renaming of the instance-protected namespace of the base class to the
% instance-protected namespace of the derived class. Note that a class
% introduces an ``instance \hyperref[def:envtable]{environment table},'' a list of ``static
% \hyperref[def:envtable]{environment tables},'' and finally the global \hyperref[def:envtable]{environment table};
% instance definitions need to go to the instance environment
% table.}






% The
%   set of \hyperref[def:lexbinding]{lexical bindings} associated to a declaring scope collect the (resolved) names of definitions in
%   that declaring scope, possibly along with other information that may be
%   required for such resolution. In particular, the \hyperref[def:lexbinding]{lexical binding} for a namespace
%   definition carries, along with the name of the namespace, the value
%   of that namespace; and the \hyperref[def:lexbinding]{lexical binding} for a class definition
%   carries, along with the name of the class, the name of the inherited
%   class. \avik{We need to be more rigorous: define what a
%     declaring scope
%     is (not to be confused with an \hyperref[def:opening-scope]{opening scope}), what a \hyperref[def:lexbinding]{lexical binding}
%     is, and so on, following which we can have a formal definition instead
%     of a descriptive paragraph for \emph{environment
%       table}. 


% \begin{definition}[Predefined namespace] A \emph{predefined namespace}
%  is of either of the following forms:

% \begin{enumerate}

% \item $\fileinternal{prog}$, with a namespace value
%   $\mathsf{unforgeable}($``$\emph{program}({\it prog})$''$)$, where
%   ${\it prog}$ is the name of a program.

% \item $\packagepublic{\pkg}$, with a namespace value $\verb`"`\pkg\verb`"`$,
%   where $\pkg$ is the name of a package.

% \item $\packageinternal{\pkg}$, with a namespace value 
%   $\mathsf{unforgeable}($``$\emph{internal}(\pkg)$''$)$, where $\pkg$ is the
%   name of a package. 

% \item $\packagepublic{}$, with a namespace value $\verb`""`$.

% \item $\packageinternal{}$, with a namespace value 
%   $\mathsf{unforgeable}($``$\emph{internal}()$''$)$. 

% \item $\classprivate{K::A}$, with a namespace value
%   $\mathsf{unforgeable}($``$\emph{private}(K::A)$''$)$, where
%   $K$ is a predefined namespace of one of the other forms and $A$ is the name of a class.

% \end{enumerate}

% \end{definition}





% \subsubsection{Class Definitions and Interface Definitions}

% Upon visiting a \nonterminal{ClassDefinition} or
% \nonterminal{InterfaceDefinition} $\emph{def}$,
% names in $\emph{def}$ are resolved and a lexical binding
% of the form $(P.\id,\emph{def})$ is added to the lexical environment
% belonging to the program, where $\id$ is the identifier of
% \emph{def} and $P$ is the name of the enclosing
% \nonterminal{PackageDirective}. There should be no conflicting lexical
% binding (i.e., with the same name) in the lexical environment.

\N
Upon visiting a \nonterminal{VariableDefinition} $\emph{def}$,
a lexical binding
of the form $(\id,\emph{def})$ is added to the lexical environment
associated with the enclosing scope, where $\id$ is the identifier of
\emph{def}, unless $\id$ has already been resolved in the enclosing
scope, whereupon an error is reported. The fact that $\id$ has been
resolved in the enclosing scope is now recorded, and if there is an existing lexical binding with the same identifier in
the lexical environment, then it is removed.


\N
Upon visiting a \nonterminal{FunctionDefinition} $\emph{def}$, a lexical binding
of the form $(\id,\emph{def})$ is added to the lexical environment
associated with the enclosing scope, where $\id$ is the identifier of \emph{def}, unless $\id$ has already been resolved in the enclosing
scope, whereupon an error is reported. 
The fact that $\id$ has been
resolved in the enclosing scope is now recorded, and if there is an existing lexical binding with the same identifier in
the lexical environment, then it is removed.


% \N
% A \nonterminal{FunctionDefinition} with
%   \lexicalnonterminal{Identifier} $\id$ that is in a class
%   context but not marked \verb'static' is processed as follows.

% \begin{enumerate}
 
% \item The namespace attribute is evaluated to a \hyperref[def:nsval]{namespace value} $\mathsf{nsvalAttr}$ as
% follows:
% \begin{enumerate}
% \item If the namespace attribute is already a \hyperref[def:nsval]{namespace value}, let
%   $\mathsf{nsvalAttr}$ be that \hyperref[def:nsval]{namespace value}.
% \item Otherwise, the namespace attribute is a \hyperref[def:rname]{restricted name}
%   $\mathsf{rnameAttr}$.
% \begin{enumerate}
% \item If $\func{resolve}(\func{expand}(\mathsf{rnameAttr},\xquals), \lexenv)$
%   returns a lexical binding whose initializer value is a \hyperref[def:nsval]{namespace value}, let  $\mathsf{nsvalAttr}$ be that \hyperref[def:nsval]{namespace
%   value}.
% \item Otherwise, 
% report an error.
% \end{enumerate}
% \end{enumerate}
  
% \item Finally, a \hyperref[def:lexbinding]{lexical binding} is synthesized as follows: 
% let $\mathsf{accessor}$ be true if the \nonterminal{FunctionDefinition}
%   has an \nonterminal{AccessorKind}, false otherwise, let
%   $\mathsf{final}$ be true if the \nonterminal{FunctionDefinition}
%   is marked \verb'final', false otherwise, let $\mathsf{override}$ be true if the \nonterminal{FunctionDefinition}
%   is marked \verb'override', false otherwise,  and let $\mathsf{native}$ be true if the \nonterminal{FunctionDefinition}
%   is marked \verb'native', false otherwise. Let the ordered list of
%   argument types of the
%   \nonterminal{FunctionDefinition} be $\mathsf{argtypes}$, and
%   the return type of the \nonterminal{FunctionDefinition} be $\mathsf{returntype}$ (evaluated
%   later, as shown in
%   Section \ref{res-typ-annots}.) The \hyperref[def:lexbinding]{lexical binding} $(\mathsf{nsvalAttr}
%   {\tt::} \id, {\bf function}(\mathsf{accessor},\mathsf{final},\mathsf{override},\mathsf{native},\allowbreak \mathsf{argtypes},
%   \mathsf{returntype}))$ is added to  the instance \hyperref[def:envtable]{environment
%   table} introduced by the enclosing
%   \nonterminal{ClassBody}. 
%
%\end{enumerate}



% \N
% A \nonterminal{VariableDefinition} with
%   \lexicalnonterminal{Identifier} $\id$ that is in a class
%   context but not marked \verb'static' is processed as follows.

% \begin{enumerate}
 
% \item The namespace attribute is evaluated to a \hyperref[def:nsval]{namespace value} $\mathsf{nsvalAttr}$ as
% follows:
% \begin{enumerate}
% \item If the namespace attribute is already a \hyperref[def:nsval]{namespace value}, let
%   $\mathsf{nsvalAttr}$ be that \hyperref[def:nsval]{namespace value}.
% \item Otherwise, the namespace attribute is a \hyperref[def:rname]{restricted name}
%   $\mathsf{rnameAttr}$.
% \begin{enumerate}
% \item If $\func{resolve}(\func{expand}(\mathsf{rnameAttr},\xquals), \lexenv)$
%   returns a lexical binding whose initializer value is a \hyperref[def:nsval]{namespace value}, let $\mathsf{nsvalAttr}$ be that \hyperref[def:nsval]{namespace
%   value}.
% \item Otherwise, report an error.
% \end{enumerate}
% \end{enumerate}
  
% \item Finally, a \hyperref[def:lexbinding]{lexical binding} is synthesized as follows:
% let
%   $\mathsf{const}$ be true if the \nonterminal{VariableDefinition}
%   is of kind \verb'const', false otherwise. Let the type of the
%   \nonterminal{VariableDefinition} be $\mathsf{type}$ (evaluated
%   later, as shown in
%   Section \ref{res-typ-annots}.) The \hyperref[def:lexbinding]{lexical binding} $(\mathsf{nsvalAttr}
%   {\tt::} \id, {\bf var}(\mathsf{const}, \mathsf{type}))$ is added to the instance \hyperref[def:envtable]{environment
%   table} introduced by the enclosing \nonterminal{ClassBody}. 

% \end{enumerate}









%\section{Transformation of Remaining Names}\label{sec:tx-unqual-mname}

% \N
% Any \nonterminal{UnqualifiedName} $\id$ that is in an \hyperref[def:opening-scope]{opening scope} whose set
% of expanded \hyperref[def:qualifier-assoc]{qualifier associations} is $\xquals \lhd \cquals$ is replaced by the
% expanded name
% $(\xquals \lhd \cquals) :: \id$. In particular, this (recursively) transforms any \hyperref[def:rname]{restricted name}
% to an expanded name.

%\N
%Finally, let $\overline{\xquals \lhd \cquals} = \{(\key, \nsval)~|~(\key,\xname) \in (\xquals \lhd \cquals)$ and
%  $\xname$ evaluates to $\nsval$ in this \hyperref[def:lexenv]{lexical environment}$\}$. 
%All remaining unqualified names $\id$ in this
%scope are expanded into \hyperref[def:Multiname]{Multinames} $\overline{\xquals \lhd \cquals} :: \id$. 
% , and any resulting qualified
% name of the form $M :: i$, where $M$ is a \hyperref[def:Multiname]{Multiname}, is expanded into
% a \hyperref[def:Multiname]{Multiname} $\{\rname :: i~|~\rname \in M\}$. \avik{The latter step would go
%   away if we used an alternative definition of \hyperref[def:Multiname]{Multinames}; see above.}

% \N Any expanded name of the form $\{\xname_1 {\tt::} \id,
% \dots, \xname_k {\tt::} \id\}$ in a \hyperref[def:defining-scope]{defining scope} with lexical
% environment $\lexenv$ is replaced by the \hyperref[def:Multiname]{Multiname}
% $\{\func{NSVal}(\func{resolve}(\xname_1, \lexenv)) {\tt::} \id, \dots, \func{NSVal}(\func{resolve}(\xname_k, \lexenv)) {\tt::} \id\}$.

% \begin{definition}[LMultiname] A \emph{LMultiname} (``late'' Multiname)
%   is of the form
%   $\{\nsval_1,\dots,\nsval_k\}{\tt::[}\mathsf{expr}{\tt]}$, where $\{\nsval_1,\dots,\nsval_k\}$ is a set
%   of namespaces values and $\mathsf{expr}$ is an
%   \nonterminal{Expression}.
% \end{definition}

% \N
% In any opening scope for which the set of qualifier associations is
% $\xquals$, let 
%   $\emph{NSVals}$ be the set of namespace values $\{\nsval~|~({\tt*},\nsval) \in \xquals\}$.
% \begin{enumerate}
% \item A \nonterminal{ReferenceOperator} of the form
%   ${\tt[}\mathsf{expr}{\tt]}$, where
%   ${\tt[}\mathsf{expr}{\tt]}$ is a \nonterminal{Brackets}, is
%   replaced by the syntax tree
%   ${\tt.}\emph{NSVals}{\tt::[}\mathsf{expr}{\tt]}$,
%   where $\emph{NSVals}{\tt::[}\mathsf{expr}{\tt]}$
%   is a LMultiname.
% \item A
%   \nonterminal{XMLAttributeName} of the form
%   ${\tt@[}\mathsf{expr}{\tt]}$, where
%   ${\tt[}\mathsf{expr}{\tt]}$ is a \nonterminal{Brackets},  is
%   replaced by the syntax tree ${\tt@}\emph{NSVals}{\tt::[}\mathsf{expr}{\tt]}$,
%   where $\emph{NSVals}{\tt::[}\mathsf{expr}{\tt]}$
%   is a LMultiname.
% \end{enumerate}

% \N In the following chapters, we rely on the following refactoring of names.

% \begin{definition}[Name expression] A
% name expression is a Multiname or a LMultiname or \verb'*', or of the form 
% $\mathsf{nsexpr} {\tt::} \id$ or
% $\mathsf{nsexpr} {\tt::*}$ or
% $\mathsf{nsexpr} {\tt::[}\mathsf{expr}{\tt]}$, where
% $\mathsf{nsexpr}$ and $\mathsf{expr}$ are \nonterminal{Expression}s and $\id$ is
% an identifier.
% \end{definition}

% \begin{definition}[Property name expression] A \emph{property name expression} is of the form 
% $\mathsf{name}$ or ${\tt@}\mathsf{name}$, where $\mathsf{name}$ is a name expression.
% \end{definition}



% \section{Inheritance Checks}\label{sec:inheritance-checks}

% \N
% Inheritance checks are always enforced by the compiler; they ensure
% that classes and
% interfaces that extend or implement other classes and interfaces
% respect the inheritance semantics of the language.

% \begin{definition}[Direct instance property]
% A direct instance variable or direct instance function of class $A$ is a
% \nonterminal{VariableDefinition} or \nonterminal{FunctionDefinition}
% whose identifier is not the identifier of $A$, and which appears in
% a class context nested by the instance block of
% the \nonterminal{ClassDefinition} of $A$. A direct instance property
% of class $A$ is a direct instance variable or direct instance function
% of class $A$.
% \end{definition}

% % \begin{definition}[QName matching of direct instance properties] The
% %   QName $p_A$ of a direct instance property of class $A$ matches the
% %   QName $p_B$
% %   of a direct instance property of class $B$ if $p_A$ is the same as
% %   $p_B$ upon renaming ${\bf Protected}_A$ by ${\bf Protected}_B$ in
% %   $p_A$ (or, equivalently, upon renaming ${\bf Protected}_B$ by ${\bf Protected}_A$ in
% %   $p_B$).
% % \end{definition}

% \begin{definition}
% A direct instance property of class $A$ is \emph{overridden} in a class $B$ if
% there is a direct instance property of class $B$ with a matching name, and $A$ is
% (recursively) a base class of $B$. 
% \end{definition}

% \begin{definition}[Declaration]
% A declaration of interface $I$ is any \nonterminal{FunctionDefinition} whose
% identifier is not the identifier of $I$, and which is nested by the
% \nonterminal{InterfaceBody} of $I$. 
% \end{definition}



% \N
% If a direct instance function of a class $A$ whose name is $f$ is marked \verb'override',
% then there must also be a direct instance function of some base class 
% of $A$ whose name matches $f$.

% \N
% If there is a direct instance function of a class $A$ whose name
% is $f$ and a
% direct instance function of some base class of $A$ whose name matches
% $f$, the direct instance function of the base class must not be marked
%   \verb'final'.

% \N
% If there is a declaration of some base interface of a class $A$ whose
% name is $f$, then:
% \begin{enumerate}
% \item There must be a direct instance function of $A$ or some
%   base class of $A$, whose identifier is the
%   same as that of $f$, and which is marked \verb'public'. 
% \item The \nonterminal{FunctionSignature} of that direct instance function must
%   be the same as the \nonterminal{FunctionSignature} of the declaration of the base interface. 
% \end{enumerate}


% \N If there is a declaration of some interface $I$ whose name is $f$, then there cannot also
% be a declaration of any base interface of $I$ whose name is $f$.




% \section{Type-Consistency Checks for Conflicting Lexical Bindings}\label{sec:consistency-checks}

% \begin{definition}[Accessor pair] A lexical binding
%   forms an \emph{accessor pair} with another lexical binding if they
%   share the same name, one of them is a setter function lexical
%   binding whose parameter
%   type is $T$, the other is a getter function lexical binding whose
%   argument type is $T$ or missing.
% \end{definition}

% \begin{definition}[Overriding pair] A lexical binding
%   forms an \emph{overriding pair} with another lexical binding if they
%   are function lexical bindings that share the same name, and one of them overrides the other.
% \end{definition}

% \N A lexical binding in
%   an environment table must not conflict with another lexical binding
%   in that environment table, i.e., they must not share the same
%   name, unless they do not form an accessor pair or an overriding pair.

 

%\chapter{Constant Evaluation}

%\input{const-eval/const.tex}

\chapter{Inference of Types and Constants}\label{chap:inference}

\makeatletter{}
This chapter describes static verification of a program given
compile-time information encoded by lexical environments. Along the
way, missing types are inferred, compile-time constants are 
propagated, and implicit coercions are made explicit. The resulting
program can be viewed as an
executable that is ready to be executed.

\section{Interpretation of Missing Types}

\N
Missing \nonterminal{Type}s for \nonterminal{VariableDefinition}s that appear in
local contexts or are marked \verb'let', and missing
\nonterminal{ResultType}s, are replaced by fresh type variables. These
type variables are eventually replaced by \nonterminal{Type}s computed
by type inference.
Any other missing \nonterminal{Type}s are considered to be \verb'*',
and missing \nonterminal{ResultType}s of functions that do not have
\nonterminal{ReturnStatement} with \nonterminal{Expression}s are
assumed to be \verb'void'.

% \subsection{Background on Objects, Classes, and Metaclasses}

% \avik{The purpose of this subsection is to (informally) summarize some relevant parts
%   of the ``Types and Values'' chapter, which may be convenient to
%   build a mental model while reading this chapter.}

% \N
% An object is an instance of an \emph{instantiable type}.

% \N
% An object contains properties.

% \N
% An instantiable type encodes information to allocate and construct the properties contained in any object that is an instance of that type.

% \N
% A class is an instantiable type. 

% \N
% An object that is an instance of a class contains a pointer to that class.

% \N
% A class has a metaclass.

% \N
% A metaclass is an instantiable type. 

% \N
% A metaclass has a unique instance (a ``class object''), that contains
% a pointer to the class. 

% \N
% A class contains a pointer to the unique instance of its metaclass
% (the ``class object'').

\section{Types}

% \N
% A class has a metaclass, which is also a type. The metaclass has a
% unique instance, which is the \emph{class object} for the class. The
% class object stores properties that correspond to definitions in the
% static environment tabel of the class. 

\N
The various kinds of types $T$ are as follows:
\begin{enumerate}
\item \verb'*' (for dynamic values)
\item value types \verb'int', \verb'uint', \verb'long', \verb'ulong',
  \verb'double', \verb'float', \verb'byte', \verb'bool'
\item $C$ (for instances of the class $C$)
\item $I$ (for instances of classes that implement the interface $I$)
\item $(T_1,\dots,T_i, T_{i+1}?, \dots, T_{i+j}?) \Rightarrow T$ (for functions with the sequence
  of non-optional parameter types $T_1,\dots,T_i$, the sequence of optional parameter types
  $T_{i+1},\dots,T_{i+j}$, and the result type $T$)
\item $\{{\tt null}\}$ (for \verb'null')
\item $\{N\}$ (for numeric literals $N$)
\item {\tt void} (for \emph{no value})
\end{enumerate}

\N
In addition, at compile-time types include:
\begin{enumerate}
\item \emph{type variables} $X$ 
\item \emph{type
  operations} that involve type variables:
\begin{enumerate}
\item $T.x$ denoting the type of member $x$ for types $T$ of objects with member $x$
\item $\mathsf{elem}(T)$ denoting the element type
for types $T$ of arrays and array lists
\item $\mathsf{param}_k(T)$ denoting the type of the $k^{\it th}$
  parameter for types
$T$ of functions
with the $k^{\it th}$ parameter
\item $\mathsf{return}(T)$ denoting the return type for types $T$ of functions
\item $\mathsf{LUB}(T_1,T_2)$ denoting the least upper bound for types $T_1$ and $T_2$
\item $\mathsf{add}(T_1,T_2)$ denoting the type of addition of values of types $T_1$ and $T_2$.
\end{enumerate}
\end{enumerate}
% \begin{definition}[Integer-like type]
% A type is integer-like if it is.
% \end{definition}

\begin{definition}[Type of definition] The \emph{type} of a
  definition {\sf def} is computed as follows:
\begin{enumerate}
\item If {\sf def} is unknown to the compiler, then
  return \verb'*'.
\item If {\sf def} is a \nonterminal{VariableDefinition}, then
  return its \nonterminal{Type}.
% \item If {\sf def} is a getter whose \nonterminal{ResultType} is
%   $T$ or a setter whose \nonterminal{Parameter} has \nonterminal{Type}
%   $T$, return $T$
\item If {\sf def} is a \nonterminal{FunctionDefinition}:
\begin{enumerate}
\item If it is a getter/setter, return its \nonterminal{Type} (which
  is the \nonterminal{ResultType} of a getter and the
  \nonterminal{Type} of the \nonterminal{Parameter} of a setter).
\item Otherwise, 
  return $(T_1,\dots,T_i, T_{i+1}?,\dots,T_{i+j}?)
    \Rightarrow T$, where 
    $T_{i+1},\dots,T_{i+j}$ are the types of the 
    \nonterminal{OptionalParameter}s, and $T_1,\dots,T_i$ are the types of the
    other \nonterminal{Parameter}s,
\end{enumerate}
\item If {\sf def} is a \nonterminal{ClassDefinition},
  return \verb'Class'.
\end{enumerate}
\end{definition}





\section{Typing Relations}

\N
The following notions of subtyping, implicit coercibility, and type compatibility control, at compile time,
which types of values are
considered safe to store in which types of locations at run time.

\begin{definition}[Subtyping]

Subtyping is a binary relation on types, defined by the transitive
closure of the following rules:
\begin{enumerate}
\item Any type is a subtype of itself.
\item The type $\{{\tt null}\}$ is a subtype of any non-value (reference)
  type.
\item If a class $C$  extends another class $C'$, then $C$ is
  a subtype of $C'$.
\item If an interface $I$ extends another interface $I'$, then $I$ is
  a subtype of $I'$.
\item If a class $C$ implements an interface $I$, then $C$ is
  a subtype of $I$.
\item Any type of the form $(T_1,\dots,T_i,T_{i+1}?,\dots,T_{i+j}?)
  \Rightarrow T$ is a subtype of
  $(T'_1,\dots,T'_{i+j}) \Rightarrow T'$
  where $T'_m$ is a subtype of $T_m$ for all $m \in
  1..i+j$, and $T$ is a subtype of $T'$.
\end{enumerate}

\end{definition}

\begin{definition}[Promotion, implicit coercibility, and type compatibility]

A numeric literal fits the first of {\tt int}, {\tt uint}, {\tt
  long}, {\tt ulong}, and {\tt double} that it is in the range of.

Promotion is a binary relation on numeric types, specified by the following
  table (where a type heading a row is promotable to a type heading a
  column if the entry common to the row and column is marked $\surd$):
\begin{center}
\begin{tabular}{| l | l | l | l | l | l | l | l |}
\hline
      & byte & int & uint & long & ulong & float & double \\ 
\hline
  byte    & $\surd$ & $\surd$ & $\surd$ & $\surd$ & $\surd$ & $\surd$ & $\surd$  \\
\hline
  int     & & $\surd$ & & $\surd$ & & & $\surd$  \\
\hline
  uint     & & & $\surd$ & $\surd$ & $\surd$ & & $\surd$  \\
\hline 
  long      & & & & $\surd$ & & & \\
\hline 
  ulong      & & & & & $\surd$ & &  \\
\hline 
  float      & & & & & & $\surd$ & $\surd$  \\
\hline 
  double      & & & & & & & $\surd$  \\
% \hline 
%   \code{*}      & \code{String} &  & \code{.toString()}\\
\hline
\end{tabular}
\end{center} 

In addition, the type $\{N\}$, where $N$ is a numeric literal, is promotable to the numeric type $T$ if
the numeric literal $N$ fits the numeric type $T'$, and $N: T'$ is implicitly
coercible to $T$ (see below).
 
Type compatibility is subtyping, promotion, or implicit coercibility, where implicit coercibility is a binary relations on types, defined by the
following rules:
\begin{enumerate}
\item Any type (other than \verb'void') is implicitly coercible to the type \verb'*'.
\item The type \verb'*' is implicitly coercible to any type (other than
  \verb'void').
\item Implicit coercibility between numeric types is specified by the
  following table  (where a type heading a row is implicitly coercible to a type heading a
  column if the entry common to the row and column is marked $\surd$
  or specifies a constraint to be satisfied by the value being coerced):
% \begin{center}
% \begin{tabular}{| l | l | l |}
% \hline
%   From     & To & Static Precondition \\ 
% \hline 
%   int      & byte & $\geq 0, < 2^8$ \\
% \hline 
%   int      & uint, ulong & $\geq 0$ \\
% \hline 
%   int      & float & $\geq-2^{24}, < 2^{24}$   \\
% \hline 
%   uint      & byte & $< 2^8$ \\
% \hline
%   uint     & int  &  $<2^{31}$\\
% \hline 
%   uint      & float & $<2^{24}$   \\
% \hline 
%   long      & byte & $\geq 0, < 2^8$ \\
% \hline 
%   long      & int & $\geq -2^{31}, < 2^{31}$   \\
% \hline 
%   long      & uint & $\geq 0, < 2^{32}$   \\
% \hline 
%   long      & ulong & $\geq 0$   \\
% \hline 
%   long      & float & $\geq-2^{24}, < 2^{24}$   \\
% \hline 
%   long      & double & $\geq-2^{53}, < 2^{53}$   \\
% \hline 
%   ulong      & byte & $< 2^8$ \\
% \hline 
%   ulong      & int & $< 2^{31}$   \\
% \hline 
%   ulong      & uint & $< 2^{32}$   \\
% \hline 
%   ulong      & float & $< 2^{24}$   \\
% \hline
%   ulong    & long & $< 2^{63}$ \\
% \hline 
%   ulong      & double & $<2^{53}$   \\
% \hline 
%   double      & float & \\
% % \hline 
% %   \code{*}      & \code{String} &  & \code{.toString()}\\
% \hline
% \end{tabular}
% \end{center}
\begin{center}
\begin{tabular}{| l | l | l | l | l | l | l | l |}
\hline
      & byte & int & uint & long & ulong & float & double \\ 
\hline
  byte    & $\surd$ & & & & & & \\
\hline
  int     & $\geq 0, < 2^8$ & $\surd$ & $\geq 0$ & & $\geq 0$ & $\geq-2^{24}, < 2^{24}$ &  \\
\hline
  uint     & $< 2^8$ & $<2^{31}$ & $\surd$ & & & $<2^{24}$ &  \\
\hline 
  long      & $\geq 0, < 2^8$ & $\geq -2^{31}, < 2^{31}$ & $\geq 0, <
  2^{32}$ & $\surd$ & $\geq 0$ & $\geq-2^{24}, < 2^{24}$ &  $\geq-2^{53}, <
  2^{53}$ \\
\hline 
  ulong      & $< 2^8$ & $< 2^{31}$ & $< 2^{32}$ & $< 2^{63}$ & $\surd$ & $< 2^{24}$ &  $<2^{53}$\\
\hline 
  float      & & & & & & $\surd$ &  \\
\hline 
  double      & & & & & & $\surd$ & $\surd$  \\
% \hline 
%   \code{*}      & \code{String} &  & \code{.toString()}\\
\hline
\end{tabular}
\end{center}
\end{enumerate}

\end{definition}

\begin{definition}[Member type] The type operation $T.m$ is defined as
  follows:
\begin{enumerate}
\item If $T$ is an interface whose member $m$ is of type $T'$, return $T'$.
\item If $T$ is a class whose instance member $m$ is of type $T'$, return $T'$.
\item If $T$ is \verb'*', return \verb'*'.
\end{enumerate}
\end{definition}

\begin{definition}[Element type] The type operation $\mathsf{elem}(T)$ is defined as
  follows:
\begin{enumerate}
\item If $T$ is ${\tt []} T'$ or ${\tt ArrayList<}T{\tt>}$, return $T'$.
\item If $T$ is \verb'*', return \verb'*'.
\end{enumerate}
\end{definition}

\begin{definition}[Parameter type] The type operation $\mathsf{param}_k(T)$ is defined as
  follows:
\begin{enumerate}
\item If $T$ is a function type whose $k^{\it th}$ parameter type is $T'$, return $T'$.
\item If $T$ is \verb'*', return \verb'*'.
\end{enumerate}
\end{definition}

\begin{definition}[Return type] The type operation $\mathsf{return}(T)$ is defined as
  follows:
\begin{enumerate}
\item If $T$ is a function type whose return type is $T'$, return $T'$.
\item If $T$ is \verb'*', return \verb'*'.
\end{enumerate}
\end{definition}

\begin{definition}[LUB of types]
The (symmetric) type operation $\mathsf{LUB}(T_1,T_2)$ is defined
as follows:

\begin{enumerate}
\item The union of $T_1$ and $T_2$, if defined, is returned.
\item Otherwise, the LUB of two numeric types $T_1$ and $T_2$ is $T_3$ such that, we have $T_1$ and $T_2$
  are promotable to $T_3$, and for any $T'_3$ such that $T_1$ and $T_2$
  are promotable to $T'_3$, we have that $T_3$ is
  promotable to $T'_3$.
\item The LUB of any other pair of types is \verb'*'.
\end{enumerate}
\end{definition}

\begin{definition}[Add of types] The (symmetric) type operation $\mathsf{add}(T_1,T_2)$ is defined as
  follows:
\begin{enumerate}
\item Return \verb'String'
  if any of $T_1$ and $T_2$ is \verb'String'.
\item Otherwise return $\mathsf{LUB}(T_1,T_2)$.
\end{enumerate}
\end{definition}

\begin{definition}[Union of types]
The union of a pair of types (symmetric) is defined as follows:

\begin{enumerate}
\item The union of two singleton numeric types $\{N_1\}$ and $\{N_2\}$
  is the first among {\tt int}, {\tt uint}, {\tt long}, {\tt ulong}, and {\tt double} that
    both $N_1$ and $N_2$ can be promoted to.

\item The union of $T$ and $T$ is $T$ for all types $T$.

\item The union of two reference types is their least common ancestor
  in the inheritance hierarchy.

\item The union of two function types $(S_1,\dots,S_i,S_{i+1}?,\dots,S_{i+j}?) \Rightarrow T$ and
  $(S'_1,\dots,S'_{i'},S'_{i'+1}?,\dots,S'_{i+j}?) \Rightarrow T'$  is the function type
  $(S''_1,\dots,S''_{i+j})
  \Rightarrow T''$, where each $S''_m$ is the
  intersection of $S_m$ and $S'_m$ for $m \in \{1,\dots,i+j\}$, and $T''$ is the
  union of $T$ and $T'$.

\item The union of any other pair of types is undefined.
\end{enumerate}
\end{definition}

\begin{definition}[Intersection of types]
The intersection of a pair of types (symmetric) is defined as follows:

\begin{enumerate}
\item The intersection of $T$ and $T$ is $T$ for all types $T$.

\item The intersection of two reference types is one of the types, so
  that the other is an ancestor in the inheritance hierarchy.

\item The intersection of two function types $(S_1,\dots,S_i,S_{i+1}?,\dots,S_{i+j}?) \Rightarrow T$ and
  $(S'_1,\dots,S'_{i'},S'_{i'+1}?,\dots,S'_{i+j}?) \Rightarrow T'$  is the function type
  $(S''_1,\dots,S''_{i+j})
  \Rightarrow T''$, where each $S''_m$ is the
  union of $S_m$ and $S'_m$ for $m \in \{1,\dots,i+j\}$, and $T''$ is the
  intersection of $T$ and $T'$.

\item The intersection of any other pair of types is undefined.
\end{enumerate}
\end{definition}




% \N
% The following function defines a mapping from lexical bindings to types.

% \begin{definition}[Type of lexical binding]
% The function $\func{type}(\emph{LexBinding})$ translates a lexical binding
% to a type, as follows:
% \begin{enumerate}
% \item Let {\sf qname} be the key and {\sf slot} be the slot of \emph{LexBinding}.
% \item If $\slot$ is of the form $\mathbf{any}$, then
%   return \verb'*'.
% \item If $\slot$ is of the form $\mathbf{namespace}(\dots)$, then
%   return \verb'*'.
% \item If $\slot$ is of the form $\mathbf{var}(\emph{varInfo})$, then
%   return the type in the {\sf type} field of \emph{varInfo}.
% \item If $\slot$ is of the form $\mathbf{function}(\emph{functionInfo})$
%   whose $\mathsf{accessor}$ field is $\mathsf{true}$, and whose {\sf
%     argtypes} and {\sf returntype} fields are either $[~]$
%   and $T$ or $[T]$ and {\tt void} or {\tt *}, return $T$ \avik{As outlined in
%     the ``Names'' chapter, the field
%     $\mathsf{accessor}$ is {\bf true} if and only if the function is a getter or
%     a setter.}
% \item If $\slot$ is of the form
%   $\mathbf{function}(\emph{functionInfo})$ whose $\mathsf{accessor}$
%   field is $\mathsf{false}$, and whose {\sf argtypes} and {\sf
%     returntype} fields are \emph{argTypes} and \emph{returnType}, return $\emph{argTypes} \Rightarrow \emph{returnType}$
% \item If $\qname$ is the name $C$ of a class definition and $\slot$ is of the form
%   $\mathbf{class}(\dots)$, return $\mathbf{meta}(C)$
% \item If $\qname$ is the name $I$ of an interface definition and $\slot$ is of the form
%   $\mathbf{interface}(\dots)$, return $\verb'Class'$
% \end{enumerate}
% \end{definition}



% \N
% The following function defines a mapping from types to environment tables.

% \begin{definition}[Environment table of type]
% The function $\func{envTable}(\mathsf{type},\emph{LexEnv})$ translates a
% type $\mathsf{type}$ to an environment table, as follows.
% \begin{enumerate}
% \item If $\mathsf{type}$ is of the form $C$, where $C$ is the name of a
%   class definition, then invoke {\sf typeInfo}($C$, \emph{LexEnv})
%   yielding a slot of the form {\bf class}(\emph{classInfo}); let the
%   environment table in the {\sf instanceTraits} field of
%   \emph{classInfo} be $\mathsf{class}$.
% \begin{enumerate}
% \item If the {\sf dynamic} field of \emph{classInfo} is {\bf true}, return $\mathsf{class}^\star$.
% \item Otherwise, return $\mathsf{class}$.
% \end{enumerate}
% \item If $\mathsf{type}$ is of the form $\mathbf{meta}(C)$, then invoke {\sf typeInfo}($C$, \emph{LexEnv})
%   yielding a slot of the form {\bf class}(\emph{classInfo}); return the
%   environment table in the {\sf staticTraits} field of
%   \emph{classInfo}.
% \item If $\mathsf{type}$ is of the form $I$, where $I$ is the name of
%   an interface definition, then invoke {\sf typeInfo}($I$, \emph{LexEnv})
%   yielding a slot of the form {\bf interface}(\emph{interfaceInfo}); return the
%   environment table in the {\sf traits} field of
%   \emph{interfaceInfo}.
% \item If $\mathsf{type}$ is \verb'*', return $\star$.
% \item If $\mathsf{type}$ is $(T_1,\dots,T_i,T^?_{i+1},\dots,T^?_{i+j})
%   \Rightarrow T$, return $\func{envTable}(\verb'Function',\emph{LexEnv})$.
% \item If $\mathsf{type}$ is $T_1~|~T_2$, return $\star$.
% \item If $\mathsf{type}$ is \verb'Null', return $\{\}$.
% \item If $\mathsf{type}$ is \verb'void', return $\{\}$.
% \end{enumerate}
% \end{definition}


\section{Coercions and Constraints}

\N
A coercion from type $T_1$ to type $T_2$ is generated by the compiler when an expression whose type
is computed to be $T_1$ flows to a context that expects type
$T_2$. Such coercions may involve type variables, but by type
inference eventually involve only \nonterminal{Type}s.

\N
A coercion from \nonterminal{Type} $T_1$ to \nonterminal{Type} $T_2$
is valid if $T_1$ is compatible with
$T_2$.

\N
A coercion from \nonterminal{Type} $T_1$ to \nonterminal{Type} $T_2$ is redundant if $T_1$ is a subtype of
$T_2$; a redundant coercion can be erased.

\N
A constraint on type $T$, specified as a set of types, is generated by the compiler when an expression whose type
is computed to be $T$ flows to a context that expects $T$ to be in
that set of types. Such constraints may involve type variables, but by type
inference eventually involve only \nonterminal{Type}s.

\N
A constraint on \nonterminal{Type} $T$ is satisfied if it is in the
specified set of types, or is \verb'*'.


\section{Constant Evaluation of Expressions}

\N
Constant evaluation is the process of evaluating expressions at
compile time. The effect of constant evaluation is that some expressions are replaced
by their constant values, and therefore have those values at run time.

\N
Constant expressions are required in some contexts. In particular:

\begin{enumerate}
\item An expression that occurs in \nonterminal{Dimensions} to denote
  the size of an array must be a constant expression.
\item An expression that occurs in an \nonterminal{OptionalParameter} to denote the default value of 
      that parameter must be a constant expression.
\item A constant expression that occurs in the 
      \nonterminal{VariableInitialization} of a
      {\tt let} \nonterminal{VariableDefinition} causes the \nonterminal{VariableInitialization} to have the value of that constant expression, thus making it a 
      \emph{constant binding}. 
\end{enumerate}
% \item In a \emph{class context}, a constant expression that occurs in the syntactic nonterminal 
%       \nonterminal{VariableInitialization} with the \terminal{var} keyword causes the corresponding 
%       \nonterminal{VariableInitialization} to have the initial value of that constant expression.
% \item A constant expression with the static type {\bf Number} that occurs where a float value is 
%       expected (as in an assignment to a float typed location), or where a float value would change 
%       the meaning of an operation (as in a binary expression involving a float value), is inferred 
%       to be a float value if it is an integer in the contiguous range of integers that can be exactly 
%       represented in IEEE 754 binary floating point encoding ($-2^{24}$ to $2^{24}$, inclusive.)
%       (See the spec "A 'float' Data Type of AS3" for full details.)


\N
The observables of the language are primitive values, as defined below.

\begin{definition}[Primitive type] A primitive type is \verb'int',
  \verb'uint', \verb'long', \verb'ulong', \verb'double', \verb'float',
  \verb'byte', \verb'bool', and \verb'String'.
\end{definition}

\begin{definition}[Primitive value] A primitive value is 
  a value of 
  primitive type.
\end{definition}



\begin{definition}[Constant \nonterminal{VariableDefinition}, constant
  value] A \nonterminal{VariableDefinition}  is constant if it is
  marked 
  {\tt let} and
  its \nonterminal{VariableInitializer} has a primitive value. The
  constant value of a lexical binding for this
  \nonterminal{VariableDefinition} is that primitive value coerced to
  the type of the \nonterminal{VariableDefinition}.
\end{definition}

%\section{Enforcement of {\tt void}}

% \section{Overview}

% \N
% Static verification follows constant evaluation.

% \N
% The purpose of static verification is to enforce compile-time
% checks that eliminate a subset of programs before they are
% executed. Some compile-time checks are always enforced; some 
% further compile-time checks are enforced only in ``strict mode.''

% \N
% The compile-time checks that are always enforced by static verification include inheritance checks (Section \ref{sec:inheritance-checks}) followed by some checks that ensure the type-consistency of
% conflicting lexical bindings (Section \ref{sec:consistency-checks}). 

% \N
% In ``strict mode,'' the
% checks that are enforced to ensure the type-consistency of conflicting
% lexical bindings
% are stricter (Section \ref{sec:consistency-checks}). Furthermore, the
% compiler performs type checking
% (Sections \ref{sec:types-lexenvs}, \ref{sec:expressions-types}, and
% \ref{sec:commands-typechecking}). 
% %\Subsection{Environment tables}

% \begin{definition}[Consolidation] 
% The instance environment table \emph{EnvTable} of a class $C$ whose base class is $C'$
% is consolidated as follows:
% \begin{enumerate}
% \item Let \emph{ConsolidatedBaseEnvTable} be the consolidated
%   environment table of $C'$.
% \item For each lexical binding in \emph{ConsolidatedBaseEnvTable}, add
%   it to \emph{EnvTable} if, upon renaming $\mathbf{Protected}_{C'}$
%   by $\mathbf{Protected}_C$ in its QName, it does not already exist in \emph{EnvTable}.
% \end{enumerate}
% \end{definition}




% \subsection{Class definitions}

% \N
% A {\bf class} lexical binding must not conflict with any
% other lexical binding in the global environment table.


% \subsection{Namespace definitions}

% \N
% A {\bf namespace} lexical binding must not conflict with any
% other lexical binding in any environment table. 


% \subsection{Function definitions}

% \N
% A lexical binding in a class instance table whose identifier is the identifier of the class must be a constructor {\bf function}
% lexical binding.

% \N
% A {\bf function} lexical binding must not conflict with any
%  lexical binding in the global environment table, unless the namespace
%  value of their name is {\bf Program} and it is consistent with the other lexical binding.

% \N
% A {\bf function} lexical binding must not conflict with any
%  lexical binding in a class instance environment table or a class
%  static environment table.

% \N
% A {\bf function} lexical binding must not conflict with any
%  lexical binding in a local environment table, unless it is consistent
%  with the other lexical binding.


% \subsection{Variable definitions}

% \subsubsection{const}

% \N
% A \verb'const' {\bf var} lexical binding must not conflict with any
%  lexical binding in any environment table. 

% \subsubsection{not const}

% \N
% A lexical binding with a {\bf var} slot must not conflict with any
%  lexical binding in the global environment table, unless the namespace
%  value of their name is {\bf Program} and the other lexical binding
%  is a {\bf function} lexical binding or a {\bf var} lexical
%  binding. \avik{type of variable must match type of variable} 

% \N
% A {\bf var} lexical binding must not conflict with any
%  lexical binding in a class instance environment table or a class
%  static environment table.

% \N
% A {\bf var} lexical binding must not conflict with any
%  lexical binding in a local environment table, unless the other lexical binding
%  is a {\bf function} lexical binding or a {\bf var} lexical binding. 


% \N
% If an \hyperref[def:envtable]{environment table} has more than one \hyperref[def:lexbinding]{lexical binding}
% corresponding to \nonterminal{VariableDefinition}s for the
% same \hyperref[def:qname]{name} $\mathsf{qnameVar}$, say $(\mathsf{qnameVar},
% \slot)$ and $(\mathsf{qnameVar},\slot_1), \dots, (\mathsf{qnameVar},\slot_k)$ where $\slot$
% and $\slot_1,\dots,\slot_k$ are each of the form ${\bf var}(\dots)$, then:
% \begin{enumerate}
% \item Unless $\slot = \slot_1 = \dots = \slot_k$, report an error.
% \item Remove the \hyperref[def:lexbinding]{lexical bindings} $(\mathsf{qnameVar},\slot_1), \dots,
%   (\mathsf{qnameVar},\slot_k)$ from the \hyperref[def:envtable]{environment table}.
% \end{enumerate}
% \avik{By restrictions enforced during building of \hyperref[def:lexenv]{lexical
%   environments}, such slots must be derived by
%   \nonterminal{VariableDefinition}s that appear in contexts other than
%   package contexts, class contexts, and interface
%   contexts. Furthermore, enforcing that those slots be the same implies 
%  that such \nonterminal{VariableDefinition}s must, in particular, have
%  the
%   same kind and the same type.}

% \N
% If an \hyperref[def:envtable]{environment table} has more than one \hyperref[def:lexbinding]{lexical binding}
%  corresponding to \nonterminal{FunctionDefinition}s for the
% same \hyperref[def:qname]{name} $\mathsf{qnameFunction}$, then report an error unless there are
% exactly two such \hyperref[def:lexbinding]{lexical bindings}, one of the form $(\mathsf{qnameFunction},
% {\bf function}({\rm true},\dots,[],\mathsf{type}))$ and the other of
% the form
% $(\mathsf{qnameFunction},
% {\bf
%   function}({\rm
%   true},\dots,[\mathsf{type}],\dots))$.
% \avik{By restrictions enforced during building of \hyperref[def:lexenv]{lexical
%   environments}, such slots must be derived from
%   \nonterminal{FunctionDefinitions} that form complementary
%   getter/setter pairs.}




\section{Computing Types and Constant Values}\label{sec:expressions-types}

% \begin{definition}
% The well-formedness of a property expression $prop$ under a lexical
% environment $\lexenv$ is checked as follows:
% \begin{enumerate}

% \item If $prop$ is a multiname, return.

% \item If $prop$ is a LMultiname of the form $\{\nsval_1,\dots,\nsval_k\}{\tt::[}
%   \mathsf{strexp}{\tt]}$, then:
% \begin{enumerate}
% \item Compute the type of $\mathsf{strexp}$ under $\lexenv$. 
% \item Return.
% \end{enumerate}

% \item If $prop$ is \verb'*', return.

% \item If $prop$ is of the form $\mathsf{nsexp} {\tt::} \id$, then:
% \begin{enumerate}
% \item Compute the type of $\mathsf{nsexp}$ under $\lexenv$. 
% \item Return.
% \end{enumerate}

% \item If $prop$ is of the form $\mathsf{nsexp} {\tt::*}$, then:
% \begin{enumerate}
% \item Compute the type of $\mathsf{nsexp}$ under $\lexenv$. 
% \item Return.
% \end{enumerate}

% \item If $\mathsf{prop}$ is of the form $\mathsf{nsexp}
%   {\tt::[}\mathsf{strexp}{\tt]}$:
% \begin{enumerate}
% \item Compute the type of $\mathsf{nsexp}$ under $\lexenv$.
% \item Compute the type of $\mathsf{strexp}$ under $\lexenv$.
% \item Return.
% \end{enumerate}

% \item If $\mathsf{prop}$ is of the form ${\tt@}\mathsf{name}$:
% \begin{enumerate}
% \item Verify the well-formedness of $\mathsf{name}$ under $\lexenv$.
% \item Return.
% \end{enumerate}
% \end{enumerate}
% \end{definition}

\N
A class \emph{depends} on another class if it is a subclass of
that class, or if its static constructor refers to that class.

\N
No class should recursively depend on itself, otherwise an error is reported.

\N
At compile time, types and constant values are computed by visiting classes in
topologically-sorted order following the \emph{depends} relation, and
in those classes, visiting local scopes in the same order as
prescribed for building lexical environments.


\subsection{References}

\N
The type, and the optional constant value, of a reference is computed as follows:
\begin{enumerate}
\item If the reference is an identifier, look up the identifier in the lexical
  environment, yielding a definition; return the type, and the
  constant value if it exists, of the definition.
\item If the reference is of the form {\bf static}\verb'.m', look up \verb'm' in
  the
  lexical environment of the static scope of the enclosing class
  definition, yielding a definition; return the type, and the constant value if it exists, of the definition.
\item If the reference is of the form \verb'(P.C).x', look up \verb'x'
  in the lexical environment of the static scope of the class
  definition mapped to \verb'P.C' in the global lexical environment,
  yielding a definition; assert
  that the definition appears in the class body of \verb'P.C', return the type, and the constant value if it exists, of the definition.
\item If the reference is of the form \verb'super.m', look up \verb'm' in
  the
  lexical environment of the instance scope of the base class of the enclosing class
  definition, yielding a function definition; return the type of the definition.
\item If the reference is of the form \verb'this.m', look up \verb'm' in
  the
  lexical environment of the instance scope of the enclosing class
  definition, yielding a definition; return the type, and the constant value if it exists,  of the definition.
\item If the reference is of the form \verb'o.x',  compute the type $T$
  of $o$, and return $T.{\tt x}$.
\item If the reference is of the form \verb'c[e]', compute the type $I$ of
  $e$ and coerce $e$ to \verb'int'. Also compute the type $T$
  of $c$. Return $\mathsf{elem}(T)$.
\end{enumerate}

% \begin{definition}[Lookup structure for static verification] Evaluation of names for
% static verification is characterized by the following lookup
% structure.
% \begin{enumerate}
% \item {\bf Result}s are types
% \item {\bf Binding}s are lexical bindings, with: 
% \begin{enumerate}
% \item the function {\sf
%     read}(\emph{LexBinding}) defined as follows:
% \begin{enumerate}
% \item If the definition of \emph{LexBinding} is a setter,  report an
%   ``illegal read'' error
% \item If the definition of \emph{LexBinding} is a getter,  invoke {\sf
%     call}(\emph{LexBinding}, $[~]$) and return the result.
% \item Otherwise, return the type of the definition of \emph{LexBinding}.
% \end{enumerate}
% \item the function {\sf
%     write}(\emph{LexBinding}, \emph{Result}) defined as follows:
% \begin{enumerate}
% \item If the definition of \emph{LexBinding} is a
%   \nonterminal{NamespaceDefinition}, a \nonterminal{ClassDefinition},
%   an \nonterminal{InterfaceDefinition}, a getter, a
%   \nonterminal{FunctionDefinition} that is constant, or a
%   \nonterminal{VariableDefinition} that is constant, then report an ``illegal write'' error. 
% \item If the definition of \emph{LexBinding} is a setter,  invoke {\sf
%     call}(\emph{LexBinding}, $[\emph{Result}]$) and return.
% \item Otherwise, let $T$ be the type of the definition of \emph{LexBinding}.
% \item If \emph{Result} is not compatible with $T$, report a ``type
%   incompatibility'' error.
% \item Return.
% \end{enumerate}

% \item the function {\sf
%     call}(\emph{LexBinding}, \emph{Results}) defined as follows:
% \begin{enumerate}
% \item Invoke {\sf read}(\emph{LexBinding}), yielding a type $T$.
% \item Let \emph{Results} be $T_1,\dots,T_k$.
% \item If $T =$ \verb'*' then return \verb'*'.
% \item If $T = \#C$ then return $C$.
% \item If $T = (T'_1,\dots,T'_i,T'_{i+1}?,\dots,T'_{i+j}?)
%   \Rightarrow T'$, and $i \leq k \leq i+j$ and $T_1$,
%   \dots, $T_k$ are respectively \emph{compatible} with
%   $T'_1,\dots,T'_k$, then return $T'$.
% \item If $T =$ \verb'Function' then return \verb'*'.
% \item Otherwise report an error.
% \end{enumerate}

% \item the function {\sf
%     delete}(\emph{LexBinding}) defined as follows:
% \begin{enumerate}
% \item If the definition is {\bf any}, return \verb'Boolean'.
% \item Otherwise report an error.
% \end{enumerate}


% \end{enumerate}
% \item {\bf Container}s are environment tables (and {\bf Container}
%   lists are lexical environments)
% \item The function {\sf lookup}(\emph{Name}, \emph{EnvTable}, {\bf
%     super}, \emph{write}) is
%   defined as follows:
% \begin{enumerate}
% \item If \emph{Name} is not a Multiname:
% \begin{enumerate} 
% \item If \emph{EnvTable} is the
%   instance environment table of class {\tt Vector.<}$T${\tt>}, then
%   return a dummy lexical binding whose \emph{type} is $T$.
% \item Otherwise, return a dummy lexical binding whose \emph{type} is $\ast$.
% \end{enumerate}
% \item Otherwise, let \emph{Names} be the set of names corresponding
%   to the Multiname, and let \emph{FixedEnvTable} be such that
%   $\emph{EnvTable} = \emph{FixedEnvTable}^\star$ if \emph{EnvTable} is
%   dynamic, $\emph{EnvTable} = \emph{FixedEnvTable}$ otherwise.
% \item Let \emph{Fixed} be the set of names that are bound in the
%   \emph{FixedEnvTable}.
% \item Let \emph{Candidates} be the intersection of \emph{Names} and
%   \emph{Fixed}.
% \item If \emph{Candidates} has multiple names, report an ``ambiguous reference'' error.
% \item if \emph{Candidates} has a single name, then:
% \begin{enumerate}
% \item If there are multiple lexical bindings corresponding to the name in the
%   environment table, then for all lexical bindings that are
%   pairwise overriding, ignore all but one lexical binding.
% \item If there are still multiple lexical bindings, either they are part of an accessor pair,
%   in which case return the getter or the setter based on whether
%   \emph{write} is false or true; or
%   they are pairwise type-consistent, i.e., if $T_1,\dots,T_n$ be the \emph{type}s of the
%   lexical bindings, then any of them that is not {\tt *} must be a
%   unique type $T$, in which case return a lexical binding whose
%   \emph{type} is $T$ if such exists, otherwise return a lexical
%   binding whose type is {\tt *}. 
% \item Otherwise, return the lexical binding corresponding to the name in the
%   environment table.
% \end{enumerate}
% \item If \emph{FixedEnvTable} is the instance environment table of a class,
%   let \emph{EnvTable'} be the base of \emph{FixedEnvTable}. Let
%   \emph{Name'} be \emph{Name} with any {\bf Protected} namespace value
%   renamed by its base. Invoke {\sf lookup}(\emph{Name'}, \emph{EnvTable'}, {\bf
%     super}, \emph{write}) and return the type, if found.
% \item If \emph{EnvTable} is dynamic, return {\tt *}.
% \item Otherwise, report a ``not found'' error.
% \end{enumerate}
% \item The function {\sf extract}(\emph{Result}, \emph{LexEnv}, {\bf super}) is defined as follows:
% \begin{enumerate}
% \item Let \emph{Result} be the type $\mathsf{type}$.
% \item If {\bf super} = {\bf true}, then \emph{LexEnv} must be associated with some defining scope nested by a
%   \nonterminal{ClassDefinition} whose base class is $C$.
% If $\mathsf{type}$
%   is not compatible with $C$, report a ``type incompatibility''
%   error. Otherwise, return the base of the instance environment table
%   of the \nonterminal{ClassDefinition}.
% \item If $\mathsf{type}$ is a name, invoke {\sf typeInfo}($\mathsf{type}$, \emph{LexEnv})
%   yielding a definition. If the definition is an
%   \nonterminal{InterfaceDefinition}, return its environment
%   table. Otherwise, if the definition is a \nonterminal{ClassDefinition}, let the
%   environment table of its instance block be $\mathsf{class}$.
% \begin{enumerate}
% \item If the \nonterminal{ClassDefinition} is {\tt dynamic}, return $\mathsf{class}^\star$.
% \item Otherwise, return $\mathsf{class}$.
% \end{enumerate}
% \item If $\mathsf{type}$ is of the form $\#C$, then invoke {\sf typeInfo}($C$, \emph{LexEnv})
%   yielding a \nonterminal{ClassDefinition}; return the
%   environment table of its static block.
% \item If $\mathsf{type}$ is \verb'*', return $\star$.
% \item If $\mathsf{type}$ is of the form $(T_1,\dots,T_i, T_{i+i}?,
%   \dots, T_{i+j}?)
%   \Rightarrow T$, return $\func{envTable}(\verb'Function',\emph{LexEnv})$.
% \item If $\mathsf{type}$ is $T_1~|~T_2$, return $\star$.
% \item If $\mathsf{type}$ is \verb'Null', return an empty environment table.
% \item If $\mathsf{type}$ is \verb'void', return an empty environment table.
% \end{enumerate}

% \item The function {\sf constructor}(\emph{Result}, \emph{LexEnv}) is
%   defined as follows:

% \begin{enumerate}
% \item Let \emph{Result} be the type $T$.
% \item If $T$ is $\mathbf{meta}(C)$, 
%   then return the type of the lexical binding of the constructor of $C$, via
%   \emph{typeInfo}($C$, \emph{LexEnv}).
% \item If $T$ is compatible with \verb'Function',
%   then return $T$. 
% \item Otherwise, report an error.
% \end{enumerate}


% \item the {\sf eval} function is defined below; for every
%   \nonterminal{Expression} in the \nonterminal{Program}, we invoke
%   {\sf eval} on the \nonterminal{Expression} and   the lexical environment of the binding scope enclosing the \nonterminal{Expression}.
% \end{enumerate}
% \end{definition}

% {\bf Example.} 
% An error is reported if a property is not found in the base class.

% \begin{lstlisting}
% class A { }
% class B extends A {
%    function f(obj:B) {
%       super.f()         // error
%    }
% }
% \end{lstlisting}

% {\bf Example.} 
% The target object can be specified with an optional \nonterminal{ParenExpression}. Here the type of 
% {\tt obj} is irrelevant to type checking of the reference to {\tt f}. All that matters is that the 
% base class of the current class contains a binding for {\tt f}. On the other hand, if specified, as 
% it is in this example, the type of {\tt obj} must be compatible with the base class of the current 
% class.

% \begin{lstlisting}
% class A { }
% class B extends A {
%    function f(obj:B) {
%       super(obj).f()    // error
%    }
% }
% \end{lstlisting}

% \jeff{ASC does not enforce either of these constraints. File a language change bug.}

\subsection{Primary Expressions}

% \begin{definition}[Array initializer] An \emph{array initializer} is of the form 
% $[\expr_1, \dots, \expr_k]$, where $\expr_1,\dots,\expr_k$ are
% expressions in sequence that correspond to elements of an array.
% \end{definition}

% \N
% An \nonterminal{ArrayInitializer} is represented as an \emph{array
%   initializer}, where each \nonterminal{ArrayElement}\tag{opt} in sequence is
% represented as \verb'undefined' if empty, and as an \emph{expression} otherwise.

% \begin{definition}[Vector initializer] A \emph{vector initializer} is of the form 
% $\verb'<'T\verb'>' [\expr_1, \dots, \expr_k]$, where $T$ is a type and 
% $\expr_1, \dots, \expr_k$ are expressions in sequence that correspond to elements of a vector.
% \end{definition}

% \N
% A \nonterminal{VectorInitializer} is represented as a \emph{vector initializer}
% where the \nonterminal{Type} is represented by a \emph{type}, and each
% \nonterminal{VectorElement} in sequence is represented as an \emph{expression}.

% \begin{definition}[Object initializer] An \emph{object initializer} is of the form 
% $\{\id_1 : \expr_1, \dots, \id_k : \expr_k\}$, where
% $\id_1,\dots,\id_k$ are identifiers that correspond to property names of
% an object, and $\expr_1,\dots,\expr_k$ are 
% \emph{expressions} in sequence that correspond to property values
% associated with those property names.
% \end{definition}

% \N
% An \nonterminal{ObjectInitializer} is represented as an \emph{object initializer}
% where each \nonterminal{Field} is represented by an identifier and an
% expression, as follows. 
% \begin{enumerate}
% \item The \nonterminal{FieldName} of 
% a \nonterminal{Field} is represented by an identifier, that:
% \begin{enumerate}
% \item if the \nonterminal{FieldName} is an \nonterminal{Identifier},
%   is that \nonterminal{Identifier}.
% \item if the \nonterminal{FieldName} is a \nonterminal{StringLiteral},
%   is the value of the
% \nonterminal{StringLiteral} converted to an identifier as if by \subr{Id}.
% \item if the \nonterminal{FieldName} is a
%   \nonterminal{NumericLiteral}, is the (\subr{Number}) value of 
% the \nonterminal{NumericLiteral} converted to a string as if by
% \subr{ToString}, and then converted to an identifier as if by \subr{Id}. 
% \end{enumerate}
% \item The 
% \nonterminal{AssignmentExpression} of a \nonterminal{Field} is
% represented as an \emph{expression}.
% \end{enumerate}

% \begin{definition}[XML initializer, XML list initializer] An \emph{XML
%     initializer}, resp. \emph{XML list initializer} is of the form 
% $|\exp_1, \dots, \exp_k|$, where $\exp_1, \dots, \exp_k$ are
% expressions that correspond to strings and embedded values in
% sequence, which upon concatenation form an XML literal, resp. XML list literal.
% \end{definition}

% \N
% A \nonterminal{XMLInitializer},
% resp. \nonterminal{XMLListInitializer}, is represented by an \emph{XML
%   initializer}, resp. \emph{XML list initializer}, where
% any punctuation, whitespace, and text in sequence is represented by a
% string (literal), and each embedded \nonterminal{Expression} in sequence is
% represented by an \emph{expression}.

% \avik{Refer below for the representation of a \nonterminal{Statement}
%   or \nonterminal{Definition} as a \emph{command}.}

% \begin{definition}[Function expression] A \emph{function expression} is of the form
% $\key$ $\verb'('$ $\sig$ $\verb')'$ $\body$ where $\key$ is an
% identifier or \verb'*' that corresponds to the optional name of the function, $\sig$ is a
% \emph{function signature}, and $\body$ is a command.
% \end{definition}

% \avik{A missing type is always taken to be {\tt*}.}

% \begin{definition}[Function signature] A \emph{function signature} is of the form
% $(\id_1:T_1, \dots, \id_i:T_i, \id_{i+1}:T_{i+1}=\expr_{i+1}, \dots,
% \id_{i+j}:T_{i+j}=\expr_{i+j}, \key:\verb'Array') : T$ where
% $\id_1:T_1, \dots, \id_i:T_i$ is a sequence of zero or more pairs of
% identifiers and \emph{types} that correspond to the 
% parameters of the function and their types,
% $\id_j:T_j=\expr_j, \dots, \id_k:T_k=\expr_k$ is a sequence of zero or
% more triples of identifers, \emph{types}, and \emph{expressions}  that correspond to the optional parameters
% of the function and their types and default values,
% $\key$ is an identifier or \verb'*' that corresponds to the optional
% rest parameter of the function, and $T$ is a \emph{type} that
% corresponds to the return type of the function.
% \end{definition}

% \N
% A \nonterminal{FunctionSignature} is represented by a \emph{function signature}
% where each \nonterminal{Parameter} is represented by the corresponding element of a sequence $\id_1:T_1, \dots, \id_i:T_i$,
% each \nonterminal{OptionalParameter} is represented by the corresponding element of a sequence
% $\id_{i+1}:T_{i+1}=\val_{i+1}, \dots, \id_{i+j}:T_{i+j}=\val_{i+j}$, 
% any \nonterminal{RestParameter} is represented by $\key : \verb'Array'$,
% and the \nonterminal{ResultType}\tag{opt} is represented by $T$.

% \N
% A \nonterminal{FunctionExpression} is represented by a \emph{function expression} 
% where \nonterminal{Identifier}\tag{opt} is represented by \verb'*' if
% missing, and an identifier otherwise, \nonterminal{FunctionSignature}
% is represented by a function signature, and \nonterminal{FunctionBody}
% is represented by a command.

\subsubsection{Null Literal}

\N
The type and constant value of \verb'null' is computed as follows:
\begin{enumerate}
\item Return $\{{\tt null}\}$ and the {\tt null} literal.
\end{enumerate}

\subsubsection{Boolean Literal}

\N
The type and constant value of \verb'true' or \verb'false', is computed as follows:
\begin{enumerate}
\item Return \verb'bool' and the boolean literal.
\end{enumerate}


\subsubsection{Numeric Literal}

The type and constant value of a numeric literal $N$ is
computed as follows:
\begin{enumerate}
\item Return $\{N\}$ and $N$.
\end{enumerate}

% \begin{enumerate}
% \item If the numeric literal is an integer between $-2^{31}$ and $2^{31}-1$, then return
%   \verb'int'. 
% \item Otherwise, return \verb'Number'. 
% \end{enumerate}

\subsubsection{String Literal}

The type and constant value of a string literal is computed as follows:
\begin{enumerate}
\item Return \verb'String' and the string literal.
\end{enumerate}

\subsubsection{Regular Expression Literal}

The type of a regular expression literal is computed as follows:
\begin{enumerate}
\item Return \verb'RegExp'.
\end{enumerate}

% \subsubsection{Property Map Initializer}

% \N
% The type of an \nonterminal{PropertyMapInitializer} is computed as follows:
% \begin{enumerate}
%  \item Let the 
%  \nonterminal{Expression}s of its \nonterminal{Fields} be $\mathsf{exp}_1, \dots, \mathsf{exp}_k$.
% \item  For each $\ell
%   \in \{1,\dots,k\}$, compute the type of $\mathsf{exp}_\ell$ and
%   coerce them to \verb'*'.
% \item Return
%   \verb'PropertyMap'. 
% \end{enumerate}

\subsubsection{Array Initializer}

\N
The type of an \nonterminal{ArrayInitializer} of the form \verb'new [e]T' is computed as follows:
\begin{enumerate}
\item Let the type and constant value of $e$ be $N$ and $n$.
\item Coerce $n:N$ to \verb'uint' and then to \verb'int'.
 \item Return
  \verb'[]T'. 
\end{enumerate}

\N
The type of an \nonterminal{ArrayInitializer} of the form \verb'new []T{...}' is computed as follows:
\begin{enumerate}
 \item Let the 
 \nonterminal{Expression}s of its
 \nonterminal{ArrayElement}s be $\mathsf{exp}_1, \dots,
\mathsf{exp}_k$. 
\item For each $\ell
  \in \{1,\dots,k\}$, compute the type and optional constant value
  $T_\ell$ and $v_\ell$ of
  $\mathsf{exp}_\ell$, and coerce them to $T$.
\item Return
  \verb'[]T'. 
\end{enumerate}

\subsubsection{Function Initializer}

\N
The type of a \nonterminal{FunctionInitializer} is computed as follows:
\begin{enumerate}
\item Let the types of the 
non-optional \nonterminal{Parameter}s in its \nonterminal{FunctionSignature} be
$T_1, \dots, T_i$, the types and \nonterminal{Expression}s of the \nonterminal{OptionalParameter}s in its
    \nonterminal{FunctionSignature} be
    $T_{i+1},\dots,T_{i+j}$ and $e_{i+1},\dots,e_{i+j}$, and its
    \nonterminal{ResultType} be $T$. 
\item The expressions $e_{i+1},\dots,e_{i+j}$ must have constant
  values $v_{i+1},\dots,v_{i+j}$, and let their types be $T'_{i+1},\dots,T'_{i+j}$.
\item Coerce $v_{i+1}:T'_{i+1},\dots,v_{i+j}:T'_{i+j}$ to
  $T_{i+1},\dots,T_{i+j}$ and return $(T_1, \dots, T_i, T_{i+1}?,\dots,T_{i+j}?) \Rightarrow T$.
% \item For each $\ell \in \{1,\dots,j\}$, compute the type of
%   $\mathsf{exp}_{i+\ell}$, 
%   yielding $T'_{i+\ell}$.
% \item
% \begin{enumerate}
% \item If $T'_{i+1}, \dots, T'_{i+j}$ are respectively compatible with
%   $T_{i+1},\dots,T_{i+j}$, return
%   $([T_1, \dots, T_i], [T_{i+1}, \dots, T_{i+j}],\emph{rest}) \Rightarrow T$.
% \item Otherwise, report an error.
% \end{enumerate}
\end{enumerate}

\subsubsection{This Expression}

\N
The type of \verb'this' is computed as follows:
\begin{enumerate}
\item Let the enclosing \nonterminal{ClassDefinition} be $C$.
\item Return
  $C$.
\end{enumerate}

\subsubsection{Type Expression}

\N
The type of \verb':'$T$ is computed as follows:
\begin{enumerate}
\item If $T$ is a class, return \verb'Class'.
\item Otherwise $T$ must be an interface, return \verb'Interface'.
\end{enumerate}

% \subsubsection{Lexical Reference}

% \N
% The type of a lexical reference $\mathsf{prop}$ is computed as follows:
% \begin{enumerate}
% \item Check the well-formedness of $\mathsf{prop}$ under $\lexenv$.
% \item 
% \begin{enumerate}
% \item If $\mathsf{prop}$ is a multiname $\mname$:
% \begin{enumerate}
% \item Compute $\func{lookup}(\mname,
%   \lexenv)$, yielding the lexical binding $(\qname,\slot)$.
% \item Return $\func{type}(\qname,\slot)$. 
% \end{enumerate}
% \item If $\mathsf{prop}$ is of the form \verb'*' or 
%   ${\tt@}\mathsf{name}$:
% \begin{enumerate}
% \item If $\lexenv$ is dynamic, return \verb'*'. 
% \item Otherwise, report an error.
% \end{enumerate}
% \item Otherwise $\mathsf{prop}$ is a LMultiname or a run-time
%   qualified name; return
%   \verb'*'. \avik{Arguably, ASC should report an error for $\mathsf{nsexp}\mathtt{::}~\id$ unless
%     some $\nsval\mathtt{::}~\id$ is found in $\lexenv$ (or $\lexenv$ is
%     dynamic). Likewise, ASC should report an error for
%     $\mathsf{nsexp}\mathtt{::*}$, unless $\lexenv$ is dynamic. This would
%     mirror the behaviors for multiname and $\mathtt{*}$ more closely.}  
% \end{enumerate}
% \end{enumerate}




% \subsubsection{Object Reference}

% \N
% The type of an object reference of the form 
%   $\mathsf{objexp}{\tt.}\mathsf{prop}$ is computed as follows:
% \begin{enumerate}
% \item Compute the type of $\mathsf{objexp}$ under $\lexenv$, yielding $T$.
% \item Check the well-formedness of $\mathsf{prop}$ under $\lexenv$.
% \item 
% \begin{enumerate}
% \item If $\mathsf{prop}$ is a multiname $\mathsf{mname}$, then return
%   the type computed for $\mathsf{mname}$ under $[\func{envTable}(T)]$. 

% \item If $\mathsf{prop}$ is of the form \verb'*' or 
%   ${\tt@}\mathsf{name}$:
% \begin{enumerate}
% \item If $\func{envTable}(T)$ is dynamic, return \verb'*'.
% \item Otherwise, report an error.
% \end{enumerate}

% \item If $\mathsf{prop}$ is a LMultiname:
% \begin{enumerate}
% \item If $T = $\verb'Vector.<'$T'$\verb'>' for some type $T'$, then return
%   $T'$. \avik{Arguably, ASC should report an error if the type of $\mathsf{prop}$ is not numeric.}
% \item Otherwise, return \verb'*'. 
% \end{enumerate}  

% \item Otherwise $\mathsf{prop}$ is a run-time qualified name; return \verb'*'.

% % \item If $\mathsf{propexp}$ is a qualified name $\mathsf{qualname}$, then
% %  \begin{enumerate}
% % \item Compute $\func{Type}(\mathsf{qualname},\lexenv)$.
% % \item Return \verb'*'.
% % \end{enumerate} 

% % \item If $\mathsf{propexp}$ is a XML star name   $\mathsf{xmlstarname}$, then:
% % \begin{enumerate}
% % \item If $\emph{table}(T)$ is dynamic, then:
% % \begin{enumerate}
% % \item Compute $\func{Type}(\mathsf{xmlstarname},\lexenv)$.
% % \item Return \verb'*'.
% % \end{enumerate}
% % \item Otherwise, report an error.
% % \end{enumerate}

% % \item If $\mathsf{propexp}$ is of the form \verb'@'$\mathsf{mname}$ where $\mathsf{mname}$ is a
% %   multiname, then:
% % \begin{enumerate}
% % \item If $\emph{table}(T)$ is dynamic, then return \verb'*'.
% % \item Otherwise, report an error.
% % \end{enumerate}

% % \item If $\mathsf{propexp}$ is of the form \verb'@'$\mathsf{qualname}$ where $\mathsf{qualname}$ is a
% %   qualified name, then:
% % \begin{enumerate}
% % \item If $\emph{table}(T)$ is dynamic, then:
% % \begin{enumerate}
% % \item Compute $\func{Type}(\mathsf{qualname},\lexenv)$.
% % \item Return \verb'*'.
% % \end{enumerate}
% % \item Otherwise, report an error.
% % \end{enumerate}

% % \item If $\mathsf{propexp}$ is of the form 
% %   $\verb'@'\mathsf{xmlstarname}$ where
% %   $\mathsf{xmlstarname}$ is a XML star name, then:
% % \begin{enumerate}
% % \item If $\emph{table}(T)$ is dynamic, then:
% % \begin{enumerate}
% % \item Compute $\func{Type}(\mathsf{xmlstarname},\lexenv)$.
% % \item Return \verb'*'.
% % \end{enumerate}
% % \item Otherwise, report an error.
% % \end{enumerate}

% % \item If $\mathsf{propexp}$ is of the form \verb'@['$\mathsf{argexp}$\verb']', then:
% % \begin{enumerate}
% % \item If $\emph{table}(T)$ is dynamic, then:
% % \begin{enumerate}
% % \item Compute $\func{Type}(\mathsf{argexp},\lexenv)$.
% % \item Return \verb'*'.
% % \end{enumerate}
% % \item Otherwise, report an error.
% % \end{enumerate}

% \end{enumerate}
% \end{enumerate}

% \subsubsection{Super Expressions}

% \N
% The type of a super expression of the form 
% \verb'super('$\mathsf{objexp}$\verb').'$\mathsf{prop}$ is computed as follows:
% \begin{enumerate}
% \item Compute the type of $\mathsf{objexp}$ under $\lexenv$, yielding $T$.
% \item Check the well-formedness of $\mathsf{prop}$ under $\lexenv$.
% \item 
% \begin{enumerate}
% \item If $\lexenv$ is associated with the instance scope of class $C$
%   or an instance method of class $C$,  and the \emph{base class} of
%   $C$ is $C'$, and $T$ is compatible with $C'$, then:
% \begin{enumerate}

% \item If $\mathsf{prop}$ is a multiname $\mathsf{mname}$, return the
%   type computed for $\mathsf{mname}$ under $[\emph{table}(C')]$. 

% \item If $\mathsf{prop}$ is a LMultiname or a run-time qualified name, return \verb'*'.

% \item Otherwise, report an error. \avik{Any other kind of reference operator in a super
%     expression should be a syntax error. ASC may be unreasonably lenient, though.}

% % \item If $\mathsf{propexp}$ is of the form 
% % $\verb'['\mathsf{argexp}\verb']'$ where
% % $\mathsf{argexp}$ is a qualified name, then:
% % \begin{enumerate}
% % \item Compute $\func{Type}(\mathsf{argexp},\lexenv)$. 
% % \item Return \verb'*'.
% % \end{enumerate}

% \end{enumerate}
% \item Otherwise report an error.
% \end{enumerate}
% \end{enumerate}




\subsection{Call Expressions}

% \begin{definition}[Function call expression] A \emph{function call expression} is of the form $\mathsf{funexp} \verb'(' \expr_1, \dots, \expr_k \verb')'$, 
% where $\mathsf{funexp}$ and $\expr_1, \dots, \expr_k$ are expressions.
% \end{definition}


\N
The type of a \nonterminal{BaseExpression} with a trailing
\nonterminal{Arguments} is computed as follows:
\begin{enumerate}
\item Let the \nonterminal{BaseExpression} preceding the \nonterminal{Arguments}
be 
$\mathsf{funexp}$, and the \nonterminal{Expression}s in the
\nonterminal{Arguments} be $\mathsf{argexp}_1, \dots,
  \mathsf{argexp}_k$.
\item Compute the type of $\mathsf{funexp}$, yielding $T_{\it fun}$.
\item For each $\ell \in \{1,\dots,k\}$, compute the type and optional
  constant value of $\mathsf{argexp}_\ell$,
  yielding $T_\ell$ and $\mathsf{argexp}_\ell$. Coerce $\mathsf{argexp}_\ell: T_\ell$ to
  $\mathsf{param}_\ell(T_{\it fun})$ for each $\ell \in \{1,\dots,k\}$, and return $\mathsf{return}(T_{\it fun})$.
\end{enumerate}

% \subsubsection{Operator expression}

% \N
% If $\mathsf{exp}$ is $\verb'op'(\mathsf{argexp}_1, \dots,
%   \mathsf{argexp}_k)$ then return
%   $\func{sig}_{\verb'op'}(\func{Type}(\mathsf{argexp}_1, \lexenv),
%   \dots, \func{Type}(\mathsf{argexp}_k, \lexenv))$

% \begin{definition}[New expression] A \emph{new expression} is of the form $\new$ $\mathsf{ctorexp}$ $\verb'(' \expr_1, \dots, \expr_k \verb')'$, 
% where $\mathsf{ctorexp}$ and $\expr_1, \dots, \expr_k$ are expressions.
% \end{definition}

\subsection{New Expressions}

\N
The type of a \nonterminal{NewExpression} is computed as follows:
\begin{enumerate}
\item Let the \nonterminal{NominalType} be $C$,
and the \nonterminal{Expression}s in the \nonterminal{Arguments} be
$\mathsf{argexp}_1,\dots,\mathsf{argexp}_k$.
\item For each $\ell \in \{1,\dots,k\}$, compute the type and optional
  constant value of $\mathsf{argexp}_\ell$,
  yielding $T_\ell$ and $\mathsf{argexp}_\ell$. 
\item In the lexical environment of the instance scope of
  the class definition
  associated with $C$ in the global lexical environment, let $(T'_1,\dots,T'_i,T'_{i+1}?,\dots,T'_{i+j}?)
  \Rightarrow \verb'void'$ be the type of the constructor.
\item If $i \leq k \leq i+j$, then coerce $\mathsf{argexp}_1 : T_1$,
  \dots, $\mathsf{argexp}_k: T_k$ to
  $T'_1,\dots,T'_k$.
\item Return $C$.
\end{enumerate}





% \subsection{Postfix and Prefix Expressions}

% \N
% The type of a postfix or prefix expression of the form $\mathsf{refexp}\mathtt{++}$ or
% $\mathsf{refexp}\mathtt{--}$ or $\mathtt{++}\mathsf{refexp}$  or $\mathtt{--}\mathsf{refexp}$  is computed as follows:
% \begin{enumerate}
% \item Compute the type of $\mathsf{refexp}$ under $\lexenv$, yielding
%   $T$. 
% \item Constrain $T$ to be numeric but not \verb'byte'.
% \item Return
%  $T$.
% \end{enumerate}

 
% \subsection{Prefix Expressions}

% \N
% The type of a prefix expression of the form
% $\mathtt{++}\mathsf{refexp}$ or $\mathtt{--}\mathsf{refexp}$ is
% computed as follows:
% \begin{enumerate}
% \item Compute the type of $\mathsf{refexp}$ under $\lexenv$, yielding
%   $T$. 
% \begin{enumerate}
% \item If $T$ is \emph{compatible} with
%   \verb'Number' then return
% $T$.
% \item Otherwise report an error.
% \end{enumerate}
% \end{enumerate}
 

\subsection{Unary Expressions}


% \subsubsection{Plus Expression and Minus Expression}

% \N
% The type of a plus or minus expression of the form
% $\mathtt{+}\mathsf{argexp}$ or $\mathtt{-}\mathsf{argexp}$ is computed
% as follows:
% \begin{enumerate}
% \item Compute the type of $\mathsf{argexp}$ under $\lexenv$, yielding $T$.
% \item Constrain $T$ to be numeric but not \verb'byte'.
% \item Return
%  $T$, and if the expression at type $T$ has a constant value then also return the
%  result of applying \verb'+' or \verb'-' on it.
% % \begin{enumerate}
% % \item If $T$ is \verb'int', return
% %  $\verb'int'$.
% % \item Otherwise, return
% %  $\verb'Number'$.
% % \end{enumerate}
% \end{enumerate}


 
 
\subsubsection{Bitwise Not Expression}

\N
The type of a bitwise not expression of the form
\verb'~'$\mathsf{argexp}$ is computed as follows:
\begin{enumerate}
\item Compute the type of $\mathsf{argexp}$ under $\lexenv$, yielding $T$.
\item Constrain $T$ to be integral but not \verb'byte'.
\item If $\mathsf{argexp}$ at type $T_1$ has a constant value
  then let $N$ be the 
 result of applying \verb'~' on it.
\begin{enumerate}
\item If $T_1$ is a singleton numeric literal, return $N$
  and $\{N\}$.
\item Otherwise, return $N$ and $T_1$.
\end{enumerate}
\item Otherwise, return $T_1$.
\end{enumerate}

 
\subsubsection{Logical Not Expression}

\N
The type of a logical not expression of the form
\verb'!'$\mathsf{argexp}$ is computed as follows:
\begin{enumerate}
\item Compute the type $T$ of $\mathsf{argexp}$ under $\lexenv$.
\item Coerce $\mathsf{argexp}:T$ to \verb'bool'.
\item Return
  \verb'bool', and if the expression at type \verb'bool' has a constant value then also return the
 result of applying \verb'!' on it.
\end{enumerate}
 

\subsection{Binary expressions}

% \begin{definition}[Binary expression] A \emph{binary expression} is of
%   the form $\expr_1$ ${\op}$ $\expr_2$, 
% where $\expr_1$ and $\expr_2$ are expressions and ${\op}$ is \verb'*', \verb'/', \verb'%',
% \verb'+', \verb'-', \verb'<<', \verb'>>', \verb'>>>', \verb'<', \verb'>', \verb'<=', \verb'>=', \verb'in', \verb'as', 
% \verb'instanceof', \verb'is', \verb'==', \verb'!=', \verb'===', \verb'!==', \verb'&', \verb'~', \verb'|',
% \verb'&&', or \verb'||'.
% \end{definition}

% \N
% A \nonterminal{MutliplicativeExpression}, \nonterminal{AdditiveExpression}, 
% \nonterminal{ShiftExpression}, \nonterminal{RelationalExpression},
% \nonterminal{EqualityExpression}, \nonterminal{BitwiseANDExpression},
% \nonterminal{BitwiseXORExpression}, \nonterminal{BitwiseORExpression},
% \nonterminal{LogicalANDExpression}, or
% \nonterminal{LogicalORExpression} is represented by a binary
% expression where the embedded \nonterminal{UnaryExpression}s, \nonterminal{MutliplicativeExpression}s, \nonterminal{AdditiveExpression}s, 
% \nonterminal{ShiftExpression}s, \nonterminal{RelationalExpression}s,
% \nonterminal{EqualityExpression}s, \nonterminal{BitwiseANDExpression}s,
% \nonterminal{BitwiseXORExpression}s, \nonterminal{BitwiseORExpression}s,
% \nonterminal{LogicalANDExpression}s, or
% \nonterminal{LogicalORExpression}s are represented by expressions.

\subsubsection{Multiplicative Expression, Subtract Expression, Relational Expression}

\N
The type of a multiplicative, subtract, or relational expression of the form
$\mathsf{exp}_1$ \verb'*' $\mathsf{exp}_2$, $\mathsf{exp}_1$ \verb'/'
$\mathsf{exp}_2$, $\mathsf{exp}_1$ \verb'%' $\mathsf{exp}_2$, 
$\mathsf{exp}_1$ \verb'-' $\mathsf{exp}_2$, $\mathsf{exp}_1$ \verb'<'
$\mathsf{exp}_2$, $\mathsf{exp}_1$ \verb'<=' $\mathsf{exp}_2$,
$\mathsf{exp}_1$ \verb'>' $\mathsf{exp}_2$, or $\mathsf{exp}_1$ \verb'>=' $\mathsf{exp}_2$ is computed as follows:
\begin{enumerate}
\item Compute the type of $\mathsf{exp}_1$ under $\lexenv$, yielding
  $T_1$.
\item Compute the type of $\mathsf{exp}_2$ under $\lexenv$, yielding
  $T_2$.
\item Constrain $T_1$ and
  $T_2$ to be numeric but not both \verb'byte'.
\item Coerce 
$\mathsf{exp}_1 : T_1$ and $\mathsf{exp}_2 : T_2$ to LUB$(T_1,T_2)$.
\item If the expressions at type LUB$(T_1,T_2)$ have constant values
  then let $N$ be the 
 result of applying \verb'*', \verb'/', \verb'%', \verb'-', \verb'<', \verb'<=', \verb'>', or \verb'>=' on them.
\begin{enumerate}
\item If $T_1$ and $T_2$ are singleton numeric literals, return $N$
  and $\{N\}$.
\item Otherwise, return $N$ and LUB$(T_1,T_2)$.
\end{enumerate}
\item Otherwise, return LUB$(T_1,T_2)$.
% \begin{enumerate}
% \item If $T_1$ and $T_2$ are integer-like then
%   return \verb'int'.
% \item Otherwise, return \verb'Number'.
% \end{enumerate}
\end{enumerate}

\subsubsection{Add Expression}

\N
The type of an add expression of the form
$\mathsf{exp}_1$ \verb'+' $\mathsf{exp}_2$ is computed as follows:
\begin{enumerate}
\item Compute the type of $\mathsf{exp}_1$ under $\lexenv$, yielding
  $T_1$.
\item Compute the type of $\mathsf{exp}_2$ under $\lexenv$, yielding
  $T_2$.
\item Constrain $T_1$ or $T_2$ to be
  \verb'String', or $T_1$ and $T_2$ to be numeric but not both \verb'byte'.
\item Coerce 
$\mathsf{exp}_1 : T_1$ and $\mathsf{exp}_2 : T_2$ to add$(T_1,T_2)$.
\item If the expressions at type add$(T_1,T_2)$ have constant values
  then let $N$ be the 
 result of applying \verb'+' on them.
\begin{enumerate}
\item If $T_1$ and $T_2$ are singleton numeric literals, return $N$
  and $\{N\}$.
\item Otherwise, return $N$ and add$(T_1,T_2)$.
\end{enumerate}
\item Otherwise, return add$(T_1,T_2)$.
\end{enumerate}

\subsubsection{Equality Expression}

\N
The type of a comparison expression of the form
$\mathsf{exp}_1~\emph{op}~\mathsf{exp}_2$ where
$\emph{op}$ is \verb'==',
\verb'!=', \verb'===', or \verb'!==' is computed as follows:
\begin{enumerate}
\item Compute the type of $\mathsf{exp}_1$ under $\lexenv$, yielding
  $T_1$.
\item Compute the type of $\mathsf{exp}_2$ under $\lexenv$, yielding
  $T_2$.
\item Constrain $T_1$ and $T_2$ to be either both numeric types, or
  both \verb'bool', or both reference types.
% \begin{enumerate}
% \item If $T_1$ and $T_2$ are numeric,  then return \verb'Boolean'.
% \item If $T_1$ or $T_2$ is \verb'*' or \verb'Boolean' then return \verb'Boolean'.
% \item If $T_1$ or $T_2$ is \verb'Null' and
%   the other is not numeric or \verb'Boolean' then return \verb'Boolean'.
% \item If $T_1$ or
%   $T_2$ is a \emph{subtype} of the other then return \verb'Boolean'.
% \item Otherwise report and error.
% \end{enumerate}
\item Coerce $\mathsf{exp}_1 :T_1$ and $\mathsf{exp}_2 :T_2$ to
  LUB$(T_1,T_2)$.
\item Return {\tt bool}, and if the expressions at type LUB$(T_1,T_2)$ have constant values
  then also return the
 result of applying \verb'==', \verb'!=', \verb'===', or \verb'!==' on
 them.
\end{enumerate}

% \avik{Maybe it is enough to say that this or that type has to be compatible
%   with the other. Everything seems to be compatible with {\tt *} or
%   {\tt Boolean}, and {\tt *} seems to be compatible with everything,
%   and {\tt null} seems to be compatible with everything other than
%   numeric or {\tt Boolean}.}

\subsubsection{Shift Expression}

\N
The type of a shift or bit arithmetic expression of the form
$\mathsf{exp}_1$ \verb'<<' $\mathsf{exp}_2$ or
$\mathsf{exp}_1$ \verb'>>' $\mathsf{exp}_2$ is computed as follows:
\begin{enumerate}
\item Compute the type of $\mathsf{exp}_1$ under $\lexenv$, yielding
  $T_1$.
\item Compute the type of $\mathsf{exp}_2$ under $\lexenv$, yielding
  $T_2$.
\item Constrain $T_1$ to be integral but not \verb'byte', and coerce
  $\mathsf{exp}_2 : T_2$ to
  \verb'int'.
\item If the expressions at types $T_1$ and \verb'int' have constant values
  then let $N$ be the 
 result of applying \verb'<<' or \verb'>>'
on them.
\begin{enumerate}
\item If $T_1$ is a singleton numeric literal, return $N$
  and $\{N\}$.
\item Otherwise, return $N$ and $T_1$.
\end{enumerate}
\item Otherwise, return $T_1$.
\end{enumerate}

\subsubsection{Bit Arithmetic Expression}

\N
The type of a shift or bit arithmetic expression of the form
$\mathsf{exp}_1$ $\mathsf{exp}_1$ \verb'&' $\mathsf{exp}_2$ or
$\mathsf{exp}_1$ \verb'|' $\mathsf{exp}_2$ or $\mathsf{exp}_1$
\verb'^' $\mathsf{exp}_2$ is computed as follows:
\begin{enumerate}
\item Compute the type of $\mathsf{exp}_1$ under $\lexenv$, yielding
  $T_1$.
\item Compute the type of $\mathsf{exp}_2$ under $\lexenv$, yielding
  $T_2$.
\item Constrain $T_1$ and $T_2$ to be integral but not both
  \verb'byte'.
\item Coerce 
$\mathsf{exp}_1 : T_1$ and $\mathsf{exp}_2 : T_2$ to LUB$(T_1,T_2)$.
\item If the expressions at type LUB$(T_1,T_2)$ have constant values
  then let $N$ be the 
 result of applying \verb'&', \verb'|', or \verb'^' on them.
\begin{enumerate}
\item If $T_1$ and $T_2$ are singleton numeric literals, return $N$
  and $\{N\}$.
\item Otherwise, return $N$ and LUB$(T_1,T_2)$.
\end{enumerate}
\item Otherwise, return LUB$(T_1,T_2)$.
\end{enumerate}

\subsubsection{Logical Expression}

\N
The type of a logical expression of the form
$\mathsf{exp}_1$ \verb'&&' $\mathsf{exp}_2$ or
$\mathsf{exp}_1$ \verb'||' $\mathsf{exp}_2$ is computed as follows:
\begin{enumerate}
\item Compute the type of $\mathsf{exp}_1$ under $\lexenv$, yielding $T_1$.
\item Compute the type of $\mathsf{exp}_2$ under $\lexenv$, yielding $T_2$.
\item Coerce $\mathsf{exp}_1:T_1$ and $\mathsf{exp}_2 : T_2$ to \verb'bool'.
\item Return \verb'bool', and if the expressions at type \verb'bool' have constant values then also return the
 result of applying \verb'&&' or \verb'||' on them.
\end{enumerate}

\subsubsection{Is Expression}

\N
The type of an {\tt is} expression of the form
$\mathsf{exp}$ \verb'is' $T$ is computed as follows:
\begin{enumerate}
\item Compute the type of $\mathsf{exp}$ under $\lexenv$.
\item Return \verb'bool', and if the expression has a constant value
  then also return the result of applying \verb'is' on it.
\end{enumerate}

\subsubsection{As Expression}

\N
The type of an {\tt as} expression of the form
$\mathsf{exp}$ \verb'as' $T$ is computed as follows:
\begin{enumerate}
\item Compute the type of $\mathsf{exp}$ under $\lexenv$.
\item Return $T$, and if the expression has a constant value then also
  return the result of applying \verb'as' on it.
\end{enumerate}

\subsection{Conditional Expressions}

% \begin{definition}[Conditional expression] A \emph{conditional expression} is of the form 
% $\mathsf{boolexp}$ $\verb'?'$ $\expr_1$ \verb':' $\expr_2$, where $\mathsf{boolexp}$, $\expr_1$ and $\expr_2$ are expressions.
% \end{definition}

% \N
% A \nonterminal{ConditionalExpression}, or a
% \nonterminal{NonAssignmentExpression} that is not a
% \nonterminal{LogicalORExpression}, is represented by
% a \emph{conditional expression} where the embedded
% \nonterminal{LogicalORExpression}s,
% \nonterminal{AssignmentExpression}s, or
% \nonterminal{NonAssignmentExpression}s are represented by expressions.

\N
The type of a conditional expression of the form
$\mathsf{condexp}$ \verb'? '$\mathsf{exp}_1$\verb' : '$\mathsf{exp}_2$ is computed as follows:
\begin{enumerate}
\item Compute the type $T$ of $\mathsf{condexp}$ under $\lexenv$.
\item Coerce $\mathsf{condexp}$ to \verb'bool'.
\item Compute the type of $\mathsf{exp}_1$ under $\lexenv$, yielding $T_1$.
\item Compute the type of $\mathsf{exp}_2$ under $\lexenv$, yielding $T_2$.
\item Coerce 
$\mathsf{exp}_1: T_1$ and $\mathsf{exp}_2: T_2$ to LUB$(T_1,T_2)$.
\item If the expressions at type \verb'bool' and LUB$(T_1,T_2)$ have constant values
  then let $N$ be the 
 result of applying \verb'?'\dots\verb':' on them.
\begin{enumerate}
\item If $T_1$ and $T_2$ are singleton numeric literals, return $N$
  and $\{N\}$.
\item Otherwise, return $N$ and LUB$(T_1,T_2)$.
\end{enumerate}
\item Otherwise, return LUB$(T_1,T_2)$.
\end{enumerate}


% \subsection{Assignment Expressions}

% \begin{definition}[Compound assignment operator] A compound assignment operator is of the form
%   $\op$\verb'=', where $\op$ is \verb'*', \verb'/', \verb'%',
%                                 \verb'+', \verb'-', \verb'<<',
%                                 \verb'>>', \verb'>>>', \verb'&',
%                                 \verb'^', \verb'|', \verb'&&', or \verb'||'.
% \end{definition}

% \begin{definition}[Assignment expression] An \emph{assignment
%     expression} is of the form $\mathsf{refexp}$ \verb'=' $\expr$ or $\mathsf{refexp}$ $\op$\verb'=' $\expr$,
% where $\mathsf{refexp}$ is a reference expression, $\op$\verb'=' is a \emph{compound assignment operator}, and $\expr$ is an expression.
% \end{definition}

% \N
% An \nonterminal{AssignmentExpression} that is not a
% \nonterminal{ConditionalExpression} is treated as if it were an 
% \emph{assignment expression}.

% \N
% The type of an assignment expression of the form $\mathsf{refexp} =
% \mathsf{argexp}$ is computed as follows:
% \begin{enumerate}
% \item Compute the type of $\mathsf{refexp}$ under $\lexenv$, yielding
%   $T$.
% \item Compute the type of $\mathsf{argexp}$ under $\lexenv$, yielding $T'$.
% \begin{enumerate}
% \item If $T'$ is \emph{compatible} with
%   $T$ then return
%   $T$. 
% \item Otherwise report an error.
% \end{enumerate}
% \end{enumerate}

% \N
% The type of an assignment expression of the form $\mathsf{refexp}~\op$\verb'= '$\mathsf{argexp}$
% where $\op$\verb'=' is a compound assignment operator, is computed as follows:
% \begin{enumerate}
% \item Compute the type of $\mathsf{refexp}$ under $\lexenv$, yielding
%   $T$.
% \item Compute the type of the binary expression $\mathsf{refexp}~\op~\mathsf{argexp}$ under $\lexenv$, yielding $T'$.
% \begin{enumerate}
% \item If $T'$ is \emph{compatible} with
%   $T$ then return
%   $T$. 
% \item Otherwise report an error.
% \end{enumerate}
% \end{enumerate}

% \N
% \avik{Assignment expressions do not type-check when the reference expressions 
%   resolve to class definitions, to namespace definitions, to variable
%   definitions that are marked {\tt const}, or to function definitions
%   in a non-local context. Thus, types for reference expressions should carry
%   ``constantness'' information. This is easily done by modifying the
%   function \emph{type}.}
% \avik{ Technically, we can introduce a type
%   of the form $\mathsf{Const}(T)$ for reference expressions that may
%   evaluate to constant references. We can
%   then have
%   that $\mathsf{Const}(T)$ is compatible with a type $T'$ whenever $T$
% is compatible with $T'$, but not conversely.}



% \subsubsection{Expression Statement}

% \N
% The well-typedness of an \nonterminal{ExpressionStatement} of the form
% $\mathsf{exp}$ is verified as follows:
% \begin{enumerate}
% \item Compute the type of $\mathsf{exp}$ under $\lexenv$.
% \item Return.
% \end{enumerate}

\subsection{Assignment Statement}

\N
An \nonterminal{AssignmentStatement} of the form
\verb'r = e' is processed as follows:
\begin{enumerate}
\item Let $T_1$ be the type of \verb'r'.
\item Let $T_2$ and $e$ be the type and optional constant value of \verb'e'.
\item Coerce \verb'e'$:T_2$ to $T_1$, and return.
\end{enumerate}



\subsection{Return Statement}

\N
A \nonterminal{ReturnStatement} is processed as follows:
\begin{enumerate}
\item Let $T_1$ be the return type of the enclosing function definition
  or function expression.
\item If \nonterminal{ReturnStatement} has an
  \nonterminal{Expression} $e$:
\begin{enumerate}
\item Compute the type and optional constant value of $e$ under $\lexenv$,
  yielding $T_2$ and $e$.
\item Coerce $e:T_2$ to $T_1$.
\end{enumerate}
\item Otherwise, constrain $T_1$ to be \verb'void'.
\item Return.
\end{enumerate}

\subsection{Throw Statement}

\N
A \nonterminal{ThrowStatement} is processed as follows:
\begin{enumerate}
\item Let $e$ be the \nonterminal{Expression} of the \nonterminal{ThrowStatement}.
\item Compute the type and optional constant value of $e$ under $\lexenv$,
  yielding $T$ and $e$.
\item Return.
\end{enumerate}

\subsection{Switch Statement}

\N
A \nonterminal{SwitchStatement} is processed as follows:
\begin{enumerate}
\item Compute the type and the optional constant value of the
  \nonterminal{ParenExpression} and each \nonterminal{Expression} in
  the \nonterminal{CaseClauses} of the \nonterminal{SwitchStatement}.
\item The \nonterminal{Expression}s are treated as if the
  \nonterminal{ParenExpression} were compared by {\tt ==} with each \nonterminal{Expression} in
  the \nonterminal{CaseClauses}.
\item Return.
\end{enumerate}


\subsection{Super Statement}

\N
A  \nonterminal{SuperStatement} is processed as
follows:
\begin{enumerate}
\item Let the
\nonterminal{Expression}s in its \nonterminal{Arguments} be $\mathsf{argexp}_1,\dots,\mathsf{argexp}_k$.
\item For each $\ell \in \{1,\dots,k\}$, compute the type and optional
  constant value of $\mathsf{argexp}_\ell$ under $\lexenv$,
  yielding $T_\ell$ and $\mathsf{argexp}_\ell$. 
\item If the type of the constructor of the base class is $(T'_1,\dots,T'_i,T'_{i+1}?,\dots,T'_{i+j}?)
  \Rightarrow T'$, $i \leq k \leq i+j$, then coerce
  $\mathsf{argexp}_1 : T_1$,
  \dots, $\mathsf{argexp}_k : T_k$ to
  $T'_1,\dots,T'_k$ and return.
\end{enumerate}

% \subsubsection{With Statement}

% \N
% The well-typedness of a with statement of the form \verb'with ('$\mathsf{argexp}$\verb')'$~\mathsf{withcmd}$ is verified as
% follows:
% \begin{enumerate}
% \item Compute the type of $\mathsf{argexp}$ under $\lexenv$.
% \item Let $\lexenv'$ be the lexical environment of $\mathsf{withcmd}$.
% \item Verify the well-typedness of $\mathsf{withcmd}$ under $\lexenv'$.
% \item Return.
% \end{enumerate}

% \subsection{For-In Statement}
 
% % \N A missing \nonterminal{ForInitializer} or \nonterminal{Expression}
% % in a \nonterminal{ForStatement} is treated as if it were \verb'true'.

% % \N
% % The well-typedness of a for statement of the form  \verb'for ('$\mathsf{init}$\verb';'$\mathsf{condexp}$\verb';'$\mathsf{loopexp}$\verb') '$\mathsf{loopcmd}$ is verified as
% % follows:
% % \begin{enumerate}
% % \item Compute the type of
% %   $\mathsf{initexp}$ under $\lexenv$.
% % \item Compute the type of $\mathsf{condexp}$ under $\lexenv$.
% % \item Compute the type of $\mathsf{loopexp}$ under $\lexenv)$.
% % \item Verify the well-typedness of $\mathsf{loopcmd}$ under $\lexenv$.
% % \item Return.
% % \end{enumerate}

% \N
% A \nonterminal{ForStatement} of the form \verb'for ('$\mathsf{id}:T_1$\verb' in '$\mathsf{collectexp}$\verb') '$\mathsf{loopcmd}$ is processed as
% follows:
% \begin{enumerate}
% %\item 
% %\begin{enumerate}
% % \item If \verb'String' is compatible with $T$ then:
% % \begin{enumerate}
% \item Compute the type $T_2$ of $\mathsf{collectexp}$ under $\lexenv$.
% \item Constrain $T_2$ to \verb'[]T' or \verb'Vector<T>' for some \verb'T', and $T_1$ to \verb'int'.
% %\item Verify the well-typedness of $\mathsf{loopcmd}$ under $\lexenv$.
% \item Return.
% \end{enumerate}
% % \item Otherwise, report an error.
% % \end{enumerate}
% %\end{enumerate}

\subsection{Function Definition}

\N
A function definition is processed as follows.
\begin{enumerate}
\item Let the types of the 
non-optional \nonterminal{Parameter}s in its \nonterminal{FunctionSignature} be
$T_1, \dots, T_i$, the types and \nonterminal{Expression}s of the \nonterminal{OptionalParameter}s in its
    \nonterminal{FunctionSignature} be
    $T_{i+1},\dots,T_{i+j}$ and $e_{i+1},\dots,e_{i+j}$, and its
    \nonterminal{ResultType} be $T$. 
\item The expressions $e_{i+1},\dots,e_{i+j}$ must have constant
  values $v_{i+1},\dots,v_{i+j}$, and let their types be $T'_{i+1},\dots,T'_{i+j}$.
\item Coerce $v_{i+1}:T'_{i+1},\dots,v_{i+j}:T'_{i+j}$ to
  $T_{i+1},\dots,T_{i+j}$ and return.
% \item For each $\ell \in \{1,\dots,j\}$, compute the type of
%   $\mathsf{exp}_{i+\ell}$, 
%   yielding $T'_{i+\ell}$.
% \item
% \begin{enumerate}
% \item If $T'_{i+1}, \dots, T'_{i+j}$ are respectively compatible with
%   $T_{i+1},\dots,T_{i+j}$, return
%   $([T_1, \dots, T_i], [T_{i+1}, \dots, T_{i+j}],\emph{rest}) \Rightarrow T$.
% \item Otherwise, report an error.
% \end{enumerate}
\end{enumerate}




% \N
% The well-typedness of a \nonterminal{ForStatement} of the form \verb'for each ('$\mathsf{ref}$\verb' in '$\mathsf{collectexp}$\verb') '$\mathsf{loopcmd}$ is verified as
% follows:
% \begin{enumerate}
% \item Compute the type of
%   $\mathsf{ref}$ under $\lexenv$, yielding $T_1$.
% \item Compute the type $T_2$ of $\mathsf{collectexp}$ under $\lexenv$. 
% \item Constrain  $T_2$ to \verb'[]T', \verb'Vector<T>', or
%   \verb'PropertyMap'.
% \item Constrain \verb'*' to  $T_1$.
% %\item Verify the well-typedness of $\mathsf{loopcmd}$ under $\lexenv$.
% \item Return.
% \end{enumerate}

% \subsubsection{If Statement}

% \N
% An \nonterminal{IfStatement} that does not have \verb'else' followed
% by a \nonterminal{Substatement} is treated
% as if it had \verb'else' followed by \verb'true' as its \nonterminal{Substatement}.

% \N
% The well-typedness of an if statement of the form \verb'if ('$\mathsf{condexp}$~$\verb') '\mathsf{truecmd}$\verb' else '$\mathsf{falsecmd}$ is verified as
% follows:
% \begin{enumerate}
% \item Compute the type of
%   $\mathsf{condexp}$ under $\lexenv$.
% \item Verify the well-typedness of $\mathsf{truecmd}$ under $\lexenv$.
% \item Verify the well-typedness of $\mathsf{falsecmd}$ under $\lexenv$.
% \item Return.
% \end{enumerate}

% \subsubsection{Switch Statement}

% \N
% The well-typedness of a \nonterminal{SwitchStatement} is verified as
% follows: 
% \begin{enumerate}
% \item Let the
% \nonterminal{Expression} in its \nonterminal{ParenExpression} be
% $\mathsf{exp}$, and the \nonterminal{CaseClause}s of its
% \nonterminal{Cases} be \verb'case '$\mathsf{exp}_1$\verb':'$\mathsf{cmd}_1, \allowbreak\dots,~$\verb'case '$\mathsf{exp}_k$\verb':'$\mathsf{cmd}_k$. \avik{What about default clause?}
% \item Compute the type of $\mathsf{exp}$ under $\lexenv$.
% \item For each $\ell
%   \in \{1,\dots,k\}$, compute the type of $\mathsf{exp}_\ell$ under $\lexenv$ and verify
%   the well-typedness of $\mathsf{cmd}_\ell$ under $\lexenv$.
% \item Return.
% \end{enumerate}

% \subsubsection{While Statement}

% \N
% The well-typedness of a while statement of the form \verb'while ('$\mathsf{condexp}$\verb')'$~\mathsf{loopcmd}$ is verified as
% follows:
% \begin{enumerate}
% \item Compute the type of $\mathsf{condexp}$ under $\lexenv$.
% \item Verify the well-typedness of $\mathsf{loopcmd}$ under $\lexenv$
% \item Return.
% \end{enumerate}

% \subsubsection{Do Statement}

% \N
% The well-typedness of a do statement of the form \verb'do '$\mathsf{loopcmd}$\verb' while ('$\mathsf{condexp}$\verb')' is verified as
% follows:
% \begin{enumerate}
% \item Verify the well-typedness of $\mathsf{loopcmd}$ under $\lexenv$
% \item Compute the type of $\mathsf{condexp}$ under $\lexenv$.
% \item Return.
% \end{enumerate}

% \subsubsection{Throw Statement}

% \N
% The well-typedness of a throw statement of the form \verb'throw '$\mathsf{exp}$ is verified as
% follows:
% \begin{enumerate}
% \item Compute the type of $\mathsf{exp}$ under $\lexenv$.
% \item Return.
% \end{enumerate}

% \subsubsection{Try Statement}

% \N
% A \nonterminal{TryStatement} without \verb'finally' followed by a
% \nonterminal{Block} is treated as if it had \verb'finally' followed by
% \verb'{ true }' as a \nonterminal{Block}.

% \N
% The well-typedness of a \nonterminal{TryStatement}, the
% \nonterminal{Block} following \verb'try' is $\mathsf{trycmd}$, the
% \nonterminal{CatchClause}s of its \nonterminal{CatchClauses} are
% \verb'catch ('$\id_1$\verb':'$T_1$\verb')'$~\mathsf{catchcmd}_1,\dots,$\verb'catch ('$\id_k$\verb':'$T_k$\verb')'$~\mathsf{catchcmd}_k$, and the
% \nonterminal{Block} following \verb'finally' is $\mathsf{finallycmd}$ is verified as
% follows:
% \begin{enumerate}
% \item Verify the well-typedness of $\mathsf{trycmd}$ under $\lexenv$.
% \item For each $\ell \in \{1,\dots,k\}$:
% \begin{enumerate}
% \item Let 
%   $\lexenv_\ell$ be the lexical environment of $\mathsf{catchcmd}_\ell$. 
% \item Verify the well-typedness of $\mathsf{catchcmd}_\ell$ under $\lexenv_\ell$.
% \end{enumerate}
% \item Verify the well-typedness of $\mathsf{finallycmd}$ under $\lexenv$
% \item Return.
% \end{enumerate}


% \subsubsection{Labeled Statement}

% \N
% The well-typedness of a \nonterminal{LabeledStatement} and its
% \nonterminal{Substatement} is $\mathsf{labelcmd}$ is verified as
% follows:
% \begin{enumerate}
% \item Verify the well-typedness of $\mathsf{labeledcmd}$ under $\lexenv$
% \item Return.
% \end{enumerate}

% \subsubsection{Break Statement}

% \N
% The well-typedness of a \nonterminal{BreakStatement} is verified as
% follows: 
% \begin{enumerate}
% \item Return.
% \end{enumerate}

% \subsubsection{Continue Statement}

% \N
% The well-typedness of a \nonterminal{ContinueStatement} is verified as
% follows:
% \begin{enumerate}
% \item Return.
% \end{enumerate}


% \subsubsection{Default XML Namespace Statement}

% \N
% The well-typedness of a \nonterminal{DefaultXMLNamespaceStatement} and
% its \nonterminal{Expression} is $\mathsf{exp}$ is verified as
% follows:
% \begin{enumerate}
% \item Compute the type of $\mathsf{exp}$ under $\lexenv$.
% \item Return.
% \end{enumerate}

% \subsubsection{Empty Statement}

% \N
% The well-typedness of an empty statement is verified as
% follows: 
% \begin{enumerate}
% \item Return.
% \end{enumerate}


% \subsubsection{Metadata Statement}

% \N
% The well-typedness of a metadata statement is verified as
% follows: 
% \begin{enumerate}
% \item Return.
% \end{enumerate}


% \subsubsection{Other Statements}

% \N
% The well-typedness of \nonterminal{Directives}\tag{opt} and its
% \nonterminal{Directive}s are $\mathsf{cmd}_1, \dots, \mathsf{cmd}_k$ is verified as
% follows:
% \begin{enumerate}
% \item For each $\ell \in\{1,\dots,k\}$, verify the well-typedness of $\mathsf{cmd}_\ell$ under $\lexenv$.
% \item Return.
% \end{enumerate}

% \N
% The well-typedness of \verb'{ '$\mathsf{blockcmd}$\verb' }' is verified as
% follows:
% \begin{enumerate}
% \item Verify the well-typedness of $\mathsf{blockcmd}$ under $\lexenv$
% \item Return.
% \end{enumerate}

%\subsection{Definitions}


% \subsubsection{Variable Definition}

% \N
% The well-typedness of a return statement of the form \nonterminal{VariableDefinition} that has a
% \nonterminal{VariableInitialization} of the form $\verb'='~\mathsf{exp}$, and the
% \nonterminal{Type} of the \nonterminal{VariableDefinition} is $T$, then:
% \begin{enumerate}
% \item If $\func{Type}(\mathsf{exp},\lexenv)$ is compatible with $T$, then
%   return.
% \item Otherwise, report an error. 
% \end{enumerate}

% \subsubsection{Function Definition}


% \N
% The well-typedness of a \nonterminal{FunctionDefinition} is verified as
% follows:
% \begin{enumerate}
% \item Let the
% \nonterminal{Parameter}s of its \nonterminal{FunctionSignature} be
% $\id_1~{\tt:}~T_1, \dots, \id_i~{\tt:}~T_i$, the \nonterminal{OptionalParameter}s of its
%     \nonterminal{FunctionSignature} be
%     $\id_{i+1}~{\tt:}~T_{i+1}~{\tt=}~\mathsf{exp}_{i+1}, \dots,
%     \id_{i+j}~{\tt:}~T_{i+j}~{\tt=}~\mathsf{exp}_{i+j}$, the
%     \nonterminal{ResultType} be $T$, and the
%     \nonterminal{FunctionBody} be the command $\mathsf{funcmd}$.
% \item Let $\lexenv'$ be the lexical environment of
%   the function body $\mathsf{funcmd}$.
% \item Verify the well-typedness of $\mathsf{funcmd}$ under $\lexenv'$.
% \item Return.
% \end{enumerate}

% \avik{Work on rest parameter.}

% \subsubsection{Class Definition}

% \N
% The well-typedness of a class definition of the form \verb'class '$\mathsf{id}$\verb' extends '$C$\verb' implements '$I_1,\dots,I_n$~$\mathsf{classcmd}$ is verified as
% follows:

% \begin{enumerate}
% \item Let $\lexenv'$ be the lexical environment of
%  the class body $\mathsf{classcmd}$.

% \item Verify the well-typedness of $\mathsf{classcmd}$ under $\lexenv'$

% \item Return.
% \end{enumerate}





% \subsubsection{Interface Definition}

% \N
% The well-typedness of an interface definition of the form \verb'interface '$\mathsf{id}$\verb' extends '$I_1,\dots,I_n$~$\mathsf{interfacecmd}$ is verified as
% follows: 
% \begin{enumerate}
% \item Return.
% \end{enumerate}

\section{Type Inference and Constraint Checking}

\N Type inference requires that the programmer specify:
\begin{enumerate}
\item parameter types of functions;
\item types of instance vars, static vars
\end{enumerate}

In turn, type inference can recover:
\begin{enumerate}
\item return types of functions
\item types of instance lets, static lets
\item types of local variables
\end{enumerate}

\N
The compiler generates coercions between types and constraints on
types, as described above. Additionally, some of the coercions are treated as
constraints, and do not participate in type inference: a coercion to any type other
than a type variable or a $\mathsf{LUB}$ or $\mathsf{add}$
  type operation is treated as a constraint, which is satisfied if and
  only if the coercion is valid. When type
inference completes, type variables are replaced by their
solutions. Thereupon, all constraints must be satisfied, any redundant
coercions may be removed, and other coercions are
implemented by the \emph{coercion operator} (defined in the next chapter). 

\N
Type inference is performed by iterative relabeling of the nodes of a directed
graph to a fixpoint. The directed graph has types as nodes, where nodes that involve type variables are initially labeled $\bot$,
and all other nodes are labeled by their types. The directed graph has the
following two kinds of edges:
\begin{enumerate}
\item A \emph{flow edge} between a type and a type variable.
\item An \emph{operation edge} from type operands to type operations
  over them.
\end{enumerate}
A relaxation of the directed graph consists of the following:
\begin{enumerate}
\item For each type variable, an iterated LUB of all labels on 
  incoming types through flow edges is computed, with unit $\bot$, and
  the type variable is relabeled with that iterated LUB.
\item Type operations whose operands have been relabeled are
  themselves relabed by recomputing those type operations on those
  labels.
\end{enumerate}
At fixpoint, the labels of the type variables (which must not be $\bot$)
are their solutions.

\section{Enforcement of {\tt public}, {\tt internal}, {\tt protected},
  and {\tt private}}

\N
A reference of the form $P.\id$ must resolve to a type defined in
package $P$ marked \verb'public'.

\N A reference of the form $o.x$, where the type of $o$ is not
\verb'*', must resolve to a definition \emph{def} whose immediately enclosing scope is the instance scope of a
  \nonterminal{ClassDefinition} named \emph{name}, such that \emph{name} is
  the name of the enclosing \nonterminal{ClassDefinition}, or \emph{def}
  is marked {\tt public}, or \emph{def} is marked
  {\tt protected} and \emph{name} is the name of a base class of the
  enclosing \nonterminal{ClassDefinition}, or \emph{def} is marked
  {\tt internal} and \emph{name} is the name of a
  \nonterminal{ClassDefinition} in a package with the same 
  name as the package of the enclosing unit.

\N A reference of the form $C.x$ or ${\bf static.}x$ must resolve to a definition \emph{def}  whose immediately enclosing scope is the static scope of a
  \nonterminal{ClassDefinition} named \emph{name}, and \emph{name} is
  the name of the enclosing \nonterminal{ClassDefinition}, or \emph{def}
  is marked {\tt public}, or \emph{def} is marked {\tt protected} and
  \emph{name} is the name of a base class of the enclosing \nonterminal{ClassDefinition}, or \emph{def} is marked
  {\tt internal} and \emph{name} is the name of a
  \nonterminal{ClassDefinition} in a
  package with the same package name as that
  the package of the enclosing unit.

\N A reference of the form ${\tt super.}x$ must resolve to a
definition \emph{def} whose immediately enclosing scope is the instance scope of the base class of the enclosing class
  definition, and it is marked \verb'public' or
  \verb'protected', or it is marked \verb'internal' and the reference
  is enclosed in the same package as the base class.

\N
For an expression of the form \verb'new '$C(e_1,\dots,e_n)$, $C$ must
resolve to a class definition whose constructor is \emph{def}, and
either $C$ is the name  of the enclosing \nonterminal{ClassDefinition}, or \emph{def}
  is marked {\tt public}, or \emph{def} is marked {\tt protected} and
  $C$ is the name of a base class of the enclosing \nonterminal{ClassDefinition}, or \emph{def} is marked
  {\tt internal} and $C$ is the name of a
  \nonterminal{ClassDefinition} in a
  package with the same package name as that
  the package of the enclosing unit.

\N
For an expression of the form \verb'super '$(e_1,\dots,e_n)$, let the base
class of the enclosing class definition be named $C$ whose constructor
is \emph{def}, then \emph{def}
  is marked {\tt public} or {\tt protected}, or \emph{def} is marked
  {\tt internal} and $C$ is the name of a
  \nonterminal{ClassDefinition} in a
  package with the same package name as that
  the package of the enclosing unit.

\section{Enforcement of {\tt let}}
 
\N
The compiler must prove that a {\tt let} is not read before it is
written, and that it is written exactly once. At runtime, it is sufficient to disallow writes to a
{\tt let} through
 dynamic code, and have no restriction on its reads 
 through dynamic code.

\subsection{Local {\tt let}s}

\N
The compiler ensures that there is one and only one write to a local {\tt
  let}, by ensuring that in the control-flow graph of the scope, there
is no
  path from the declaration of the {\tt let} to the end of the scope
  on which there are zero or multiple \nonterminal{Assignment}s to the {\tt let}.
  (In particular, functions defined along the path from the declaration of the {\tt
    let} to the end of the scope must not
  write to the {\tt let}, because those writes may occur zero or
  multiple times.)

\N
The compiler ensures that there is no read to a local {\tt
  let} on any path in the control-flow graph of the scope between the
declaration of a {\tt let} and the one and only one write to the
{\tt let}. (In particular, functions defined along such a path must not
  read the {\tt let}, because they may be called.)


\subsection{Instance {\tt let}s}

\N
The compiler ensures that there is one and only one write to an instance {\tt
  let} as follows: 
\begin{enumerate}
\item A function other than the
  constructor must not
  write to the {\tt let}. Furthermore, a
  \nonterminal{DeferStatement} in a constructor must not write to the
  {\tt let}. Finally, the {\tt let} must not
  be written through an instance member reference outside the scope,
  i.e., there must not be an assignment to $o.x$ if $o$ is of type $T$
  and the definition corresponding to \verb'x' in $T$ is marked \verb'let'.  (Note that writes may still be
possible in dynamically typed code: e.g.,
\verb#{dyn:* = this; dyn.x = ...}#.)
\item In the control-flow graph of the constructor, there must not be any
  path between the super statement and the defer statement
  on which there are zero or multiple \nonterminal{Assignment}s to the {\tt let}.
\end{enumerate}

\N
The compiler ensures that there is no read to an instance {\tt
  let} on any path in the control-flow graph of the constructor between the
super statement and the one and only one write to the
{\tt let}, and that there is no read of {\tt this} other than to write to an 
  instance field, or to read an instance field marked \verb'var', or
  read a previously initialized instance field marked \verb'let', on the path. (Every instance function is assumed to read the {\tt
    let}.)

\subsection{Static {\tt let}s}

\N
The compiler ensures that there is one and only one write to a static {\tt
  let} as follows:
\begin{enumerate}
\item A function other than the
  static constructor must not
  write to the {\tt let}. Furthermore, the {\tt let} must not
  written through a static member reference outside the scope.
\item In the control-flow graph of the static constructor, there must not be any
  path from the beginning to the end of the scope
  on which there is zero or multiple \nonterminal{Assignment}s to the {\tt let}.
\end{enumerate}

\N
The compiler ensures that there is no read to a static {\tt
  let} on any path in the control-flow graph of the static constructor
between the beginning and the one and only one write to the
{\tt let}, and there is no {\bf static} reference, or a reference to a
static member of a class name, or a reference to a class name in a
type expression, other than to write to a 
  static field of the enclosing class, or to read a static field marked \verb'var', or
  read a previously initialized static field marked \verb'let' on the
  path. (Every instance function or static function is assumed to read the {\tt
    let}.)




% \N
% Let $T$ not be a type variable. If $T \leq Y$ and $Y \leq X$, then $T
% \leq X$.

% \N
% Let $T$ not be a type variable such that $T$ flows to $X$, and $X.x$
% exists. Then $T.x = X.x$.

% \N
% Let $T$ not be a type variable such that $T$ flows to $X$, and ${\sf return}(X)$
% exists. Then ${\sf return}(T) \leq {\sf return}(X)$.

% \N
% A constraint of the form $(S_1,\dots,S_i,S_{i+1}?,\dots,S_{i+j}?)
% \Rightarrow T \leq (S'_1,\dots,S'_{i'},S'_{i'+1}?,\dots,S'_{i'+j'}?)
% \Rightarrow T'$, where $i \leq i'$ and $i'+j' \leq i + j$ is
% deconstructed into the constraints $S'_k \leq S_k$ for each $k \in \{1,\dots,i'+j'\}$, and $T \leq T'$.

% \N
% The above rules are applied until fixpoint, whereby the LUB (least
% upper bound) of all
% types $T$, where $T$ is not a type variable, such that $T \leq X$ is
% considered to be the solution for $X$.

% \N
% A type variable $X$ is replaced by its solution throughout. In
% particular, it is replaced in the coercions and constraints generated
% by the compiler, as well as in all further constraints generated
% during type inference. 

% \N
% Following replacement of type variables with solutions, all the coercions and
% constraints must be valid. Furthermore, all redundant coercions and
% constraints may be removed.


 





% \subsection{References}

% \N
% Let \emph{ref} be an identifier $\id$ that is nested by a scope $\emph{Scope}$ without
% crossing another scope. Then $\id$ evaluates to $\emph{value}$,
% returned by the following computation.

% \begin{enumerate}
% \item Let $\emph{LexEnv}$ be the lexical environment
% associated with $\emph{Scope}$.
% \item If there is a lexical binding of the form $(\id,\emph{def})$ in
%   \emph{LexEnv} and \emph{def} is a constant
%   \nonterminal{VariableDefinition}, then return its
%   constant value.
% \end{enumerate}

% \N
% Let \emph{ref} be a member reference $(P.C).\id$. Then $(P.C).\id$ evaluates to $\emph{value}$,
% returned by the following computation.

% \begin{enumerate}
% \item Let $\emph{LexEnv}$ be the lexical environment
% associated with the static block of the \nonterminal{ClassDefinition}
% mapped to $P.C$ in the lexical
% environment of the \nonterminal{Program}.
% \item If there is a lexical binding of the form $(\id,\emph{def})$ in
%   \emph{LexEnv} and \emph{def} is a constant
%   \nonterminal{VariableDefinition}, and if $P.C$ is
%   the name of the enclosing \nonterminal{ClassDefinition} is such exists, or if \emph{def}
%   is marked {\tt public}, or if  \emph{def} is marked
%   {\tt protected} and $P.C$ is the name of a base class of the
%   enclosing \nonterminal{ClassDefinition} if such exists, or if  \emph{def} is marked
%   {\tt internal} and $P$ is the package name of the enclosing \nonterminal{PackageDirective}, then return its
%   constant value.
% \end{enumerate}

% \N
% Let \emph{ref} be a member reference $\verb'this'.\id$. Then $\verb'this'.\id$ evaluates to $\emph{value}$,
% returned by the following computation.

% \begin{enumerate}
% \item Let $\emph{LexEnv}$ be the lexical environment
% associated with the instance block of the enclosing \nonterminal{ClassDefinition}.
% \item If there is a lexical binding of the form $(\id,\emph{def})$ in
%   \emph{LexEnv} and \emph{def} is a constant
%   \nonterminal{VariableDefinition}, then return its
%   constant value.
% \end{enumerate}


% \subsection{Literal Expressions}

% \N
% Constant evaluation of a \lexicalnonterminal{StringLiteral}, a \lexicalnonterminal{NumericLiteral},
% {\tt null}, {\tt true}, or {\tt false} returns whatever primitive value would be 
% yielded by the run-time evaluation of the expression.

% \subsection{Operator Expressions}

% \N
% Constant evaluation of an expression that involves sub-expressions
% that evaluate to primitive values, and the operator 
% \verb`!`, \verb+||+, \verb`&&`, \verb`!=`, \verb`==`, \verb`!==`, \verb`===`, \verb'~', \verb`+`, \verb`-`, 
% \verb`*`, \verb`/`, \verb`%`, \verb`<`, \verb`<=`, \verb`>`, \verb`>=`, \verb`<<`, \verb`>>`, 
% \verb`&`, \verb`|`, \verb`^`, \verb`?`\dots\verb`:`\dots, or 
% \verb'('\dots\verb')', returns
% whatever primitive value would be yielded by the run-time evaluation
% of the expression, with coercion insertion (or reports an error).

% \N
% Constant evaluation of an expression of the form 
% $E~\verb'is'~T$, where $E$ evaluates to a primitive value and $T$ is a type, returns whether the type
%   of $E$ is $T$.

% \N
% Constant evaluation of an expression of the form 
% $E~\verb'as'~T$, where $E$ evaluates to a primitive value and $T$ is a
% type, returns whatever primitive value is yielded by coercing $E$ to
% $T$ (or reports an error).

\section{Call Expansion}

\N
An \nonterminal{Assignment} of the form $r = e$ (such that $r$ is a
\nonterminal{ReferenceExpression}) where $r$ resolves to a 
setter, is rewritten to the expression $r(e)$.

\N
Any \nonterminal{ReferenceExpression} not involved in an
\nonterminal{Assignment}, of the form $r$, where $r$ resolves to a 
getter, is rewritten to the expression $r()$.

\N
The default values in the signature of a function definition in a
class that overrides another function definition in another class must be
the same as in the signature of the overridden function definition.

\N
The default values in the signature of a function definition in a
class that implements another function definition in an interface must be
the same as in the signature of the implemented function definition.

\N
Any expression of the form $r(e_1,\dots,e_{i+k})$, where $r$
is a \nonterminal{ReferenceExpression} that resolves to a \nonterminal{FunctionDefinition} whose
type is $(T_1,\dots,T_i,T_{i+1}?,\dots,T_{i+j}?) \Rightarrow T$, where
$k \leq j$, is rewritten to the expression
$r(e_1,\dots,e_{i+k},v_{i+k+1},\dots,v_{i+j})$, where
$v_{i+1},\dots,v_{i+j}$ are the default values in the signature of
the \nonterminal{FunctionDefinition}.

\N
Any expression of the form \verb'new '$C(e_1,\dots,e_{i+k})$, where $C$
resolves to a class definition whose constructor's
type is $(T_1,\dots,T_i,T_{i+1}?,\dots,T_{i+j}?) \Rightarrow $\verb'void', where
$k \leq j$, is rewritten to the expression
\verb'new '$C(e_1,\dots,e_{i+k}, \allowbreak v_{i+k+1},\dots,v_{i+j})$, where
$v_{i+1},\dots,v_{i+j}$ are the default values in the signature of
the constructor.

\N
Any expression of the form \verb'super '$(e_1,\dots,e_{i+k})$, where
the type of the constructor of the base class of the enclosing definition is $(T_1,\dots,T_i,T_{i+1}?,\dots,T_{i+j}?) \Rightarrow $\verb'void', where
$k \leq j$, is rewritten to the expression
\verb'super '$(e_1,\dots,e_{i+k},v_{i+k+1},\dots,v_{i+j})$, where
$v_{i+1},\dots,v_{i+j}$ are the default values in the signature of
the constructor. 


\part{Execution}




\chapter{Run-Time Structures and Operations}\label{chap:runtime}

\makeatletter{}% Copyright (C) 2011 Adobe Systems Incorporated.  All Rights Reserved.

This chapter describes how execution proceeds against \emph{run-time environments} that contains run-time
representations of global scopes (consisting of types) and local scopes. In particular, it describes how run-time
environments are \emph{allocated}, and specifies data
structures and the semantics of various
intrinsic operations that manipulate those data structures at run
time, while interacting with run-time environments.

\section{Run-Time Environments}

\N Run-time environments are used to store and look up representations
that correspond to
the information contained in lexical environments.

\begin{definition}[Location] A location is a
  block
  of
  memory of known type, that is
  \emph{uninitialized} when allocated, and otherwise always contains
  some value of that type.
\end{definition}

\begin{definition}[Run-Time Environment] 
  A run-time environment is a set of run-time bindings. A run-time
  binding is a pair of a name and a location.
\end{definition}

\N
There is a global run-time environment that maps names of types
(classes and interfaces) to their representations during execution.

\section{Values and Types}

\begin{definition}[Run-Time Type]
  A \emph{run-time type} is either a numeric or boolean type, or a function
  closure type, or a class.
\end{definition}

\begin{definition}[Class]
  A class carries a \nonterminal{ClassInheritance}, a
  \nonterminal{ClassBody}, and a run-time environment.
\end{definition}

\begin{definition}[Value]
  A \emph{value} is either a numeric or boolean value or an \emph{object}.
\end{definition}

\begin{definition}[Object]
  Every object carries a run-time type and a run-time environment.
\end{definition}

\begin{definition}[Box]
  A box is an object carrying a numeric or boolean value.
\end{definition}


\begin{definition}[Function closure]
  A function closure is an object carrying a run-time environment,
  and whose type carries a 
  \nonterminal{FunctionBody}.
\end{definition}

%\subsection{Classes}

% \begin{definition}[Metaclass]
% A \emph{metaclass} is a class that is an instance of {\tt Class}, and
% whose only instance is a class that is itself not a metaclass. A
% metaclass object is associated with the static block of a \nonterminal{ClassDefinition}.
% \end{definition}

%\subsection{Interfaces}

%\subsection{Functions}

%\subsection{Strings}

\begin{definition}[Array]
  An array is an object carrying a (fixed) length and a sequence of locations of that length.
\end{definition}

\begin{definition}[ArrayList]
  An array list is an object carrying a (variable) length and a sequence of locations of that length.
\end{definition}

\begin{definition} [String] A string is an object carrying a
  (fixed) length and a sequence of characters of that length in the Unicode
encoding.
\end{definition}

%\section{Types}

% \subsection{Class types}
% \label{sec-class-types}

% \N A \nonterminal{ClassDefinition} comprises property definitions and
% static initialization code.

% \begin{definition}[Property Definition]
%   The \emph{property definition} of a property is a \nonterminal{VarDefinition},
%   \nonterminal{NamespaceDefinition}, or \nonterminal{FunctionDefinition} within the
%   \nonterminal{ClassBody} of a \nonterminal{ClassDefinition}.
% \end{definition}

% \begin{definition}[Instance Property]
%   An \emph{instance property} of a class is defined by a
%   \nonterminal{VarDefinition} or \nonterminal{FunctionDefinition}
%   within the \nonterminal{ClassBody} of the class, when those
%   definitions do not carry the attribute \verb+static+.
% \end{definition}

% \begin{definition}[Metaclass Property]
%   A \emph{metaclass property} of a class is defined by a
%   \nonterminal{VarDefinition} or \nonterminal{FunctionDefinition}
%   within the \nonterminal{ClassBody} of the class, when those
%   definitions carry the attribute \verb+static+, or by a
%   \nonterminal{NamespaceDefinition} within the \nonterminal{ClassBody}
%   of the class.
% \end{definition}

% \begin{definition}[Static initialization code]
%   Any \nonterminal{Statement} occuring outside any
%   \nonterminal{FunctionDefinition} in the \nonterminal{ClassBody} of a
%   \nonterminal{ClassDefinition} is part of the class's {\em static
%     initialization code}.
% \end{definition}

% \begin{definition}[Class, Metaclass]
%   A \nonterminal{ClassDefinition} gives rise to two types.  One type,
%   called simply {\em the class}, comprises information about the
%   instance properties from the \nonterminal{ClassDefinition}.  The
%   other type, called {\em the metaclass}, comprises information about
%   the metaclass properties and the static initialization code.
% \end{definition}

% \N In this specification, the unqualified moniker ``class'' always
% means a class type, which is an internal concept.  The specification
% uses the phrases \nonterminal{ClassDefinition} and ``class object'' to
% talk about the syntactic and run-time entitites.

% \N Observe that a class never has any ``static'' members: The
% qualifier \verb+static+ is a syntactic construct used to place a
% property into the metaclass.

% \begin{definition}[Base Class]
%   A class $B$ is a \emph{base class} of $D$ if the
%   \nonterminal{ClassDefinition} of $D$ states that $D$ extends $B$, or
%   if the \nonterminal{ClassDefinition} of $D$ states that $D$ extends
%   some class $C$ and $B$ is a base class of $C$.  If the
%   \nonterminal{ClassDefinition} of $D$ states that $D$ extends $B$
%   then $B$ is $D$'s \emph{direct base class}.
% \end{definition}

% \N If a \nonterminal{ClassDefinition} does not state that it extends
% any class then it extends the built-in class \verb+Object+.

% \begin{definition}[Subclass]
%   A class $D$ is a \emph{subclass} of $B$ if $B$ is a base class of
%   $D$.  $D$ is a \emph{direct subclass} of $B$ if $B$ is the direct
%   base class of $D$.
% \end{definition}

% \begin{definition}[Inheritance]
%   A subclass {\em inherits} properties from its base class: properties
%   specified for the base class become properties in the subclass as
%   well.
% \end{definition}

% \N If the \nonterminal{ClassDefinition} has \verb+extends+ or
% \verb+implements+ clauses then it is the class, not the metaclass,
% that inherits properties, methods, and signatures from the base class
% and base interfaces.

% \N If $D$ is a subclass of $B$ then the metaclass of $D$ is {\em not}
% a subclass of the metaclass of $B$.  Thus static properties are not
% inherited.  A metaclass is always a subclass of the built-in class
% \verb+Class+, and implements no interfaces.

% \begin{definition}[Dynamic Class, Sealed Class]
%   A \emph{dynamic class} is a class whose
%   \nonterminal{ClassDefinition} carries the \verb+dynamic+ attribute.
%   A class that is not dynamic is \emph{sealed}.  A class is dynamic or
%   sealed independently of its base classes and subclasses.  Properties
%   can be added to instances of dynamic classes at run-time, but not to
%   instances of sealed classes.
% \end{definition}

% \N If the \nonterminal{ClassDefinition} has (or does not have) a
% \verb+dynamic+ attribute then it is the class, not the metaclass, that
% is dynamic (or sealed).  The metaclass is always dynamic.

% \begin{definition}[Final Class]
%   A \emph{final class} is a class whose \nonterminal{ClassDefinition}
%   carries the \verb+final+ attribute.  A final class has no
%   subclasses.
% \end{definition}

% \N If the \nonterminal{ClassDefinition} has (or does not have) a
% \verb+final+ attribute then it is the class, not the metaclass, that
% is final (or not).  The metaclass is always final.

% \begin{definition}[Metaclass constructor]
%   The \emph{metaclass constructor} is a constructor function for the
%   metaclass.  Its body comprises all initializers for metaclass
%   properties and the static initialization code in the
%   \nonterminal{ClassDefinition}.  The metaclass constructor takes no
%   arguments.
% \end{definition}


% \subsection{Interface types}
% \label{sec-interface-types}

% \begin{definition}[Interface, Metainterface]
%   An \nonterminal{InterfaceDefinition} gives rise to two types.  One
%   type, called simply {\em the interface}, comprises information about
%   the signatures defined in the \nonterminal{InterfaceBody} of the
%   \nonterminal{InterfaceDefinition}.  The other, called {\em the
%     metainterface}, is a class.
% \end{definition}

% \N In this specification, the unqualified moniker ``interface'' always
% means an interface type, which is an internal concept.  The
% specification uses the phrases \nonterminal{InterfaceDefinition} and
% ``interface object'' to talk about the syntactic and run-time
% entitites.

% \N There are no instances of interfaces.  Instead, classes {\em
%   implement} interfaces and provide methods that match the signatures
% in the interfaces they implement.

% \N The metainterface is a subclass of the built-in class \verb+Class+.
% It has no methods or properties other than those it inherits from
% \verb+Class+.  The purpose of the metainterface is to provide a class
% for the run-time representation of the interface.

% \begin{definition}[Base Interface]
%   An interface $I$ is a \emph{base interface} of $J$ if the
%   \nonterminal{InterfaceDefinition} of $J$ states that $J$ extends
%   $I$, or if the \nonterminal{InterfaceDefinition} of $J$ states that
%   $J$ extends some interface $K$ and $I$ is a base interface of $K$.
%   If the \nonterminal{InterfaceDefinition} of $J$ states that $J$
%   extends $I$ then $I$ is $J$'s \emph{direct base interface}.
% \end{definition}

% \begin{definition}[Subinterface]
%   An interface $J$ is a \emph{subinterface} of $I$ if $I$ is a base
%   interface of $J$.  $J$ is a \emph{direct subinterface} of $I$ if $I$ is
%   the direct base interface of $J$.
% \end{definition}


% \subsection{Null Type}

% \begin{definition}[Null type]
%   There is a type called {\em Null} that is neither a class nor an
%   interface.
% \end{definition}

% \subsection{Undefined Type}

% \begin{definition}[Undefined type]
%   There is a type called {\em Undefined} that is neither a class nor
%   an interface.
% \end{definition}

% \N {\em Null} and {\em Undefined} are distinct.

% \N {\em Null} and {\em Undefined} are not directly nameable in AS3
% programs, but it is possible to write programs that recognize values
% of these types by means of the \verb+===+ and \verb+typeof+ operators.

% \subsection{Any Type}

% \begin{definition}[Any type]
%   There is a type called {\em Any} that is neither a class nor an
%   interface, and which is distinct from {\em Null} and {\em
%     Undefined}.
% \end{definition}

% \N There are no values of type {\em Any}, it is useful only as a type
% constraint.  A \nonterminal{Type} written as {\tt *} denotes {\em
%   Any}.

% \subsection{Function Type}

% \begin{definition}[Function type]
%   A {\em function type} describes the signature of a function.
%   \lars{Are there other attributes?  For example, for bound functions,
%     is the type of the bound object an attribute on the type?}
% \end{definition}

% \N The function type is used for strict-mode type checking.  It
% comprises the tuple of argument types and the return type.

% \N Function types are not directly expressible in AS3.  Every function
% value has an implied function type but the only function type that may
% be used as a type constraint is the class type \verb+Function+.



% \begin{definition}[Subtype relation]
%   A type $T$ may be a {\em subtype} of another type $U$.  If $T$ is a
%   subtype of $U$ and there is no type $V$ such that that $T$ is a
%   subtype of $V$ and $V$ is a subtype of $U$ then $T$ is a {\em direct
%     subtype} of $U$.
% \end{definition}


% \N The following are the subtype rules.

% \begin{enumerate}
% \item Any type is a subtype of itself.

% \item If a class A is a subclass of B then A is a subtype of B.

% \item If a class A implements an interface I then A is a subtype of I.

% \item If an interface I is a subinterface of J then I is a subtype of J.

% \item {\em Null} is a subtype of the type of every class and interface
%   except for the built-in classes \verb+Boolean+, \verb+Number+,
%   \verb+int+, and \verb+uint+.

% \item There are no subtypes of {\em Null} (apart from {\em Null} itself).

% \item There are no subtypes of {\em void} (apart from {\em void} itself).

% \item {\em void} and {\em Object} are direct subtypes of {\em Any}.

% \item Function types are direct subtypes of \verb+Function+.
% \end{enumerate}

% \begin{definition}[Nullable classes and interfaces]
%   Classes and interfaces that have {\em Null} as a subtype are {\em
%     nullable}, and those that don't have {\em Null} as a subtype are
%   {\em non-nullable}.
% \end{definition}

\section{Instrinsic Operations}

\N
To simplify the presentation of dynamic evaluation semantics, code is
transformed to the following
intrinsic operations, as described in the next chapter.


\subsection{GetLocal}

\N
The operation {\bf GetLocal}$(x)$ finds
the location mapped to $x$ in the run-time environment of the
enclosing function closure, gets
the value contained in the location and returns it. 

\subsection{SetLocal}

\N
The operation {\bf SetLocal}$(x = e)$ finds
the location mapped to $x$ in the run-time environment of the
enclosing function closure, evaluates $e$ to a value $v$, and puts $v$ into the location. 

\subsection{GetStaticLex}

\N
The operation {\bf GetStaticLex}$({\bf static.}x)$ finds
the location mapped to $x$ in the run-time environment of the enclosing class, gets
the value contained in the location, and returns it. 

\subsection{SetStaticLex}

\N
The operation {\bf SetStaticLex}$({\bf static.}x = e)$  finds
the location mapped to $x$ in the run-time environment of the enclosing class, evaluates
$e$ to a value $v$, and puts $v$ into the location. 

\subsection{GetStaticMember}

\N
The operation {\bf GetStaticMember}$(C.x)$ finds
the location mapped to $x$ in the run-time environment of $C$, gets
the value contained in the location, and returns it. 

\subsection{SetStaticMember}

\N
The operation {\bf SetStaticMember}$(C.x = e)$  finds
the location mapped to $x$ in the run-time environment of $C$, evaluates
$e$ to a value $v$, and puts $v$ into the location. 

\subsection{GetInstanceField}

\N
The operation {\bf GetInstanceField}$(e_0.x)$ evaluates $e$ to an object
$o$, 
finds
the location mapped to $x$ in run-time environment of $o$, gets
the value contained in the location, and returns it.

\subsection{SetInstanceField}

\N
The operation {\bf SetInstanceField}$(e_0.x = e)$  evaluates $e_0$ to an object
$o$,  finds
the location mapped to $x$ in run-time environment of 
$o$, evaluates $e$ to the value $v$, and puts
$v$ into the location.

\subsection{GetInstanceMethod}

\N
The operation {\bf GetInstanceMethod}$(e_0.x)$ evaluates $e_0$ to an
object $o$, performs {\bf GetType} on $o$ to obtain $C$, then performs
{\bf GetStaticMember}$C.x$ to obtain $f$, and finally performs
{\bf Call}$(f(o))$.

\subsection{GetSuperMethod}

\N
The operation {\bf GetSuperMethod}$({\tt super}.x)$ performs {\bf
  GetStaticMember}$C.x$ where $C$ is the super class of the
enclosing class to obtain $f$, finally performs
{\bf Call}$(f({\tt this}))$.

\subsection{{\tt *}::GetInstanceMember}

\N
The operation {\bf {\tt *}::GetInstanceMember}$(e_0.x)$ evaluates $e_0$ to an
object $o$. Next, it performs {\bf GetType} on $o$ to obtain $C$, and looks up
$x$ in the instance scope of $C$ yielding a definition \emph{def} of type
$T$. Enforce access control on the definition: \emph{def}'s
immediately enclosing scope must be the instance scope of a
  \nonterminal{ClassDefinition} named \emph{name}, such that \emph{name} is
  the name of the enclosing \nonterminal{ClassDefinition}, or \emph{def}
  is marked {\tt public}, or \emph{def} is marked
  {\tt protected} and \emph{name} is the name of a base class of the
  enclosing \nonterminal{ClassDefinition}, or \emph{def} is marked
  {\tt internal} and \emph{name} is the name of a
  \nonterminal{ClassDefinition} in a package with the same 
  name as the package of the enclosing unit.
\begin{enumerate}
\item If the definition is a variable definition, perform {\bf
    GetInstanceField}$(o.x)$
\item If the definition is a getter, perform {\bf Call}$(${\bf
    GetInstanceMethod}$(o.x)())$.
\item Otherwise the definition is any other function definition, perform {\bf
    GetInstanceMethod}$(o.x)$.
\end{enumerate}
Perform {\bf $T$::Op}$(v~{\tt coerce}~*)$ on the result $v$,
  and return it.

\subsection{{\tt *}::SetInstanceMember}

\N
The operation {\bf {\tt *}::SetInstanceMember}$(e_0.x = e)$ evaluates $e_0$ to an 
object $o$. Next, it performs {\bf GetType} on $o$ to obtain $C$, and looks up
$x$ in the instance scope of $C$ yielding a definition \emph{def}. Enforce the access control on the definition: \emph{def}'s
immediately enclosing scope must be the instance scope of a
  \nonterminal{ClassDefinition} named \emph{name}, such that \emph{name} is
  the name of the enclosing \nonterminal{ClassDefinition}, or \emph{def}
  is marked {\tt public}, or \emph{def} is marked
  {\tt protected} and \emph{name} is the name of a base class of the
  enclosing \nonterminal{ClassDefinition}, or \emph{def} is marked
  {\tt internal} and \emph{name} is the name of a
  \nonterminal{ClassDefinition} in a package with the same 
  name as the package of the enclosing unit. Also, $e$ is
evaluated to an object $v$.

\begin{enumerate}
\item If the definition is a variable definition, then it must not be marked
\verb'let', let $T$
  be its type.
Perform {\bf {\tt *}::Op}($v ~{\tt coerce}~T$) to obtain $v'$, and perform {\bf
    SetInstanceField}$(o.x = v')$.
\item Otherwise the definition must be a setter, let $T$
  be its type.
Perform {\bf {\tt *}::Op}($v ~{\tt coerce}~T$) to obtain $v'$, and then perform {\bf Call}$(${\bf
    GetInstanceMethod}$(o.x)(v'))$.
\end{enumerate}



\subsection{Call}

\N
The operation {\bf Call}$(e_0(e_1,\dots,e_k))$ evaluates $e_0$ to a
function closure $f$ and $e_1,\dots,e_k$ to values $v_1,\dots,v_k$.
\begin{enumerate}
\item Allocation is performed for the invocation of $f$.
\item The locations corresponding to the parameters in the run-time
  environment built during allocation are initialized with
  $v_1,\dots,v_k$.
\item The function body of $f$ is run, switching to its run-time
  environment.
\item Any return jump or error is caught.
\item The run-time environment is switched back to the current run-time environment.
\item The return value, if it exists, is returned, or the error,
  if it exists, is re-thrown.
\end{enumerate}

\subsection{{\tt *}::CallReturn}

\N
The operation {\bf Call}$(e_0(e_1,\dots,e_{i+k}))$ evaluates $e_0$ to a
function closure $f$. Next, it looks up the function signature of
$f$, whose non-optional parameter types are $T_1,\dots,T_i$, optional
parameter types are $T_{i+1},\dots,T_{i+j}$ with default values
$v''_{i+1},\dots,v''_{i+j}$, and result type is $T$. Next, it evaluates
$e_1,\dots,e_{i+k}$ to objects $v_1,\dots,v_{i+k}$, and performs {\bf
  $*$::Op}$(v_m ~{\tt coerce}~T_m)$ for each $m \in 1..i+k$ to obtain values
$v'_1,\dots,v'_{i+k}$. Finally, it performs {\bf
  Call}$(f(v'_1,\dots,v'_{i+k},v''_{i+k+1},\dots,v''_{i+j}))$, performs {\bf $T$::Op}($v~{\tt coerce}~*$) on the
result, and returns it.

\subsection{{\tt *}::Call}

\N
The operation {\bf Call}$(e_0(e_1,\dots,e_{i+k}))$ evaluates $e_0$ to a
function closure $f$. Next, it looks up the function signature of
$f$, whose non-optional parameter types are $T_1,\dots,T_i$, optional
parameter types are $T_{i+1},\dots,T_{i+j}$ with default values
$v''_{i+1},\dots,v''_{i+j}$. Next, it evaluates
$e_1,\dots,e_{i+k}$ to objects $v_1,\dots,v_{i+k}$, and performs {\bf
  $*$::Op}$(v_m ~{\tt coerce}~T_m)$ for each $m \in 1..i+k$ to obtain values
$v'_1,\dots,v'_{i+k}$. Finally, it performs {\bf
  Call}$(f(v'_1,\dots,v'_{i+k},v''_{i+k+1},\dots,v''_{i+j}))$.



\subsection{NewInstance}

\N The operation ${\bf NewInstance}({\tt new }~C(e_1,\dots,e_k))$
evaluates $e_1,\dots,e_k$ to values $v_1,\dots,v_k$, 
creates a new object $o$ of type $C$, performs allocation for $o$,
performs {\bf GetInstanceMethod}$(o.$\verb'%init%'$)$ to obtain the constructor
$f$, and finally performs ${\bf Call}(f(v_1,\dots,v_k)())$ and returns
$o$.

\subsection{NewFunction}

\N The operation ${\bf NewFunction}(F)$ where $F$ is a function
expression makes a new function closure whose function body is derived from the function, and whose
run-time environment is the current run-time environment (which is
empty in a global scope).

\subsection{NewArray}

\N The operation ${\bf NewArray}({\tt new} []T\{e_1,\dots,e_k\})$
evaluates $e_1,\dots,e_k$ to values $v_1,\dots,v_k$, and 
creates a new array whose length is $k$ and whose sequence of
locations are initialized with $v_1,\dots,v_k$.

\subsection{GetType}

\N
The operation ${\bf GetType}(o)$ evaluates $o$ to an object and
returns it type.

\subsection{Unbox}

\N
The operation ${\bf Unbox}(o)$ evaluates $o$ to a box, and returns the boolean or numeric value carried by the box.

\subsection{<type>::GetIndex}

\N
The operation {\bf $T$::GetIndex}$(a[i])$
evaluates $a$ to an object $a'$ and $i$ to an int $i'$. 
\begin{enumerate}
\item Either $T$ is an array type or array list type. Assert that
$i'$ is between $0$ and $n-1$ where $n$ is $a'{\tt.length}$, find
the location at that index, and get
the value contained in the location.
\item Or $T$ is \verb'*'. Perform ${\bf GetType}(a')$ to obtain $T'$. Assert
  that $T'$ is an array type or array list type whose element type is $T''$, perform {\bf
    $T'$::GetIndex}$(a'[i'])$ to obtain $v'$, perform {\bf $T''$::Op}$(v'~{\tt coerce}~*)$ and return it.
\end{enumerate}



\subsection{<type>::SetIndex}

\N
The operation {\bf $T$::SetIndex}$(a[i] = e)$
evaluates $a$ to an object $a'$, $i$ to an int $i'$, and $e$ to a
value $v$. 
\begin{enumerate}
\item Either $T$ is an array type or array list type. Assert that
$i'$ is between $0$ and $n-1$ where $n$ is $a'{\tt.length}$, find
the location at that index, and put
$v$ into the location.
\item Or $T$ is \verb'*'. Perform ${\bf GetType}(a')$ to obtain $T'$. Assert
  that $T'$ is an array type or array list type whose element type is
  $T''$, perform ${\bf {\tt *}::Op}(v~{\tt coerce}~T'')$ to obtain $v'$, and perform {\bf
    $T'$::SetIndex}$(a'[i'] = v')$.
\end{enumerate}


\subsection{<type>::Op}

\N
The operation {\bf $T$::Op}$($\verb'~'$e)$ evaluates $e$ to a value $v$.
\begin{enumerate}
\item Either $T$ is integral but not byte. Perform \verb'~' (bitwise
  not) on $v:T$ and return
  the result of type $T$.
\item Or $T$ is \verb'*'. Perform ${\bf GetType}(v)$ to obtain $T'$. Assert
  that $T'$ is integral but not byte, perform ${\bf Unbox}(v)$ to
  obtain $v'$, perform {\bf $T'$::Op}$($\verb'~'$v')$ to obtain $r$, perform {\bf $T'$::Op}$(r~{\tt coerce}~*)$ and return it.
\end{enumerate}

\N
The operation ${\bf {\tt bool}::Op}($\verb'!'$e)$ evaluates $e$ to a value
$v$. Perform \verb'!' (logical not) on $v:{\tt bool}$ and return
  the result of type {\tt bool}.

\N
The operation {\bf $T$::Op}$(e_1$~\emph{op}~$e_2)$, where \emph{op} is
\verb'*', \verb'/', \verb'%', \verb'-', \verb'<', \verb'<=', \verb'>',
                         or \verb'>=', evaluates $e_1$ and
$e_2$ to values $v_1$ and $v_2$.
\begin{enumerate}
\item Either $T$ is numeric but not byte. Perform \emph{op}
  (multiplicative operation, subtraction, or
                         relational operation) on
  $v_1:T$ and $v_2:T$ and return
  the result of type $T$.
\item Or $T$ is \verb'*'. Perform ${\bf GetType}(v_1)$ and ${\bf
    GetType}(v_2)$ to obtain $T'_1$ and $T'_2$. Compute $\mathsf{LUB}(T'_1,T'_2)$ to
  obtain $T'$, assert
  that $T'$ is numeric but not byte, perform ${\bf Unbox}(v_1)$ and ${\bf Unbox}(v_2)$ to
  obtain $v'_1$ and $v'_2$, perform {\bf $T'_1$::Op}$(v'_1~{\tt coerce}~T')$ and
  {\bf $T'_2$::Op}$(v'_2~{\tt coerce}~T')$ to obtain $v''_1$ and $v''_2$, perform {\bf $T'$::Op}$(v''_1$~\emph{op}~$v''_2)$ to obtain $r$, perform {\bf $T'$::Op}$(r~{\tt coerce}~*)$ and return it.
\end{enumerate}

\N
The operation {\bf $T$::Op}$(e_1$\verb'+'$e_2)$ evaluates $e_1$ and
$e_2$ to values $v_1$ and $v_2$.
\begin{enumerate}
\item Either $T$ is numeric but not byte. Perform \verb'+' (addition) on
  $v_1:T$ and $v_2:T$ and return
  the result of type $T$.
\item Or $T$ is \verb'String'. Perform $v_1{\tt .concat}(v_2)$ and return
  the result of type {\tt String}.
\item Or $T$ is \verb'*'. Perform ${\bf GetType}(v_1)$ and ${\bf
    GetType}(v_2)$ to obtain $T'_1$ and $T'_2$. Compute $\mathsf{add}(T'_1,T'_2)$ to
  obtain $T'$. Assert
  that $T'$ is either numeric but not byte, in which case perform ${\bf Unbox}(v_1)$ and ${\bf Unbox}(v_2)$ to
  obtain $v'_1$ and $v'_2$, or  \verb'String', in which case let
  $v'_1$ and $v'_2$ be $v_1$ and $v_2$. Perform {\bf $T'_1$::Op}$(v'_1~{\tt coerce}~T')$ and
  {\bf $T'_2$::Op}$(v'_2~{\tt coerce}~T')$ to obtain $v''_1$ and $v''_2$, perform {\bf $T'$::Op}$(v''_1$\verb'+'$v''_2)$ to obtain $r$, perform {\bf $T'$::Op}$(r~{\tt coerce}~*)$ and return it.
\end{enumerate}

\N
The operation {\bf $T$::Op}$(e_1$~\emph{op}~$e_2)$, where \emph{op} is
\verb'==' or
\verb'!=', evaluates $e_1$ and
$e_2$ to values $v_1$ and $v_2$.
\begin{enumerate}
\item Either $T$ is a value type. Perform \emph{op} (structural
  equality or inequality) on
  $v_1:T$ and $v_2:T$ and return
  the result of type {\tt bool}.
\item Or $T$ is a subtype of \verb'Object'. Perform 
  $v_1{\tt.equal}(v_2)$ or ${\tt !}v_1{\tt.equal}(v_2)$ and return
  the result of type {\tt bool}.
\item Or $T$ is \verb'*'. Perform ${\bf GetType}(v_1)$ and ${\bf
    GetType}(v_2)$ to obtain $T'_1$ and $T'_2$. Compute $\mathsf{LUB}(T'_1,T'_2)$ to
  obtain $T'$. Assert
  that $T'$ is not \verb'*', and perform ${\bf Unbox}(v_1)$ and ${\bf Unbox}(v_2)$ to
  obtain $v'_1$ and $v'_2$. Perform {\bf $T'_1$::Op}$(v'_1~{\tt coerce}~T')$ and
  {\bf $T'_2$::Op}$(v'_2~{\tt coerce}~T')$ to obtain $v''_1$ and $v''_2$, perform
  {\bf $T'$::Op}$(v''_1$~\emph{op}~$v''_2)$ and return the result.
\end{enumerate}

\N
The operation {\bf $T$::Op}$(e_1$~\emph{op}~$e_2)$, where \emph{op} is \verb'===' or \verb'!==', evaluates $e_1$ and
$e_2$ to values $v_1$ and $v_2$.
\begin{enumerate}
\item Either $T$ is a value type. Perform \emph{op} (physical
  equality or inequality) on
  $v_1:T$ and $v_2:T$ and return
  the result of type {\tt bool}.
\item Or $T$ is a subtype of \verb'Object'. Perform 
  $v_1{\tt.identical}(v_2)$ or ${\tt !}v_1{\tt.identical}(v_2)$ and return
  the result of type {\tt bool}.
\item Or $T$ is \verb'*'. Perform ${\bf GetType}(v_1)$ and ${\bf
    GetType}(v_2)$ to obtain $T'_1$ and $T'_2$. Compute $\mathsf{LUB}(T'_1,T'_2)$ to
  obtain $T'$. Assert
  that $T'$ is not \verb'*', and perform ${\bf Unbox}(v_1)$ and ${\bf Unbox}(v_2)$ to
  obtain $v'_1$ and $v'_2$. Perform {\bf $T'_1$::Op}$(v'_1~{\tt coerce}~T')$ and
  {\bf $T'_2$::Op}$(v'_2~{\tt coerce}~T')$ to obtain $v''_1$ and $v''_2$, perform
  {\bf $T'$::Op}$(v''_1$~\emph{op}~$v''_2)$ and return the result.
\end{enumerate}


\N
The operation {\bf $T$::Op}$(e_1$~\emph{op}~$e_2)$, where \emph{op} is \verb'<<', \verb'>>', \verb'&', \verb'|', or \verb'^', evaluates $e_1$ and
$e_2$ to values $v_1$ and $v_2$.
\begin{enumerate}
\item Either $T$ is integral but not byte. Perform \emph{op} (shift
  operation or bitwise arithmetic operation) on
  $v_1:T$ and $v_2:T$ and return
  the result of type $T$.
\item Or $T$ is \verb'*'. Perform ${\bf GetType}(v_1)$ and ${\bf
    GetType}(v_2)$ to obtain $T'_1$ and $T'_2$. Compute $\mathsf{LUB}(T'_1,T'_2)$ to
  obtain $T'$. Assert
  that $T'$ is integral but not byte. Perform ${\bf Unbox}(v_1)$ and ${\bf Unbox}(v_2)$ to
  obtain $v'_1$ and $v'_2$. Perform {\bf $T'_1$::Op}$(v'_1~{\tt coerce}~T')$ and
  {\bf $T'_2$::Op}$(v'_2~{\tt coerce}~T')$ to obtain $v''_1$ and $v''_2$, perform {\bf $T'$::Op}$(v''_1$~\emph{op}~$v''_2)$ to obtain $r$, perform {\bf $T'$::Op}$(r~{\tt coerce}~*)$ and return it.
\end{enumerate}


\N
The operation ${\bf {\tt bool}::Op}(e_1$~\emph{op}~$e_2)$, where \emph{op} is \verb'&&' or \verb'||', evaluates $e_1$ and
$e_2$ to values $v_1$ and $v_2$. Perform \emph{op} (logical conjuction
or disjunction) on
  $v_1:T$ and $v_2:T$ and return
  the result.

\N
The operation {\bf $T'$::Op}$(e~\verb'is'~T)$
evaluates $e$ to a value $v$.
\begin{enumerate}
\item If $T'$ is a value type, then return whether $T$ is the same as $T'$.
\item Otherwise, perform ${\bf GetType}(v)$ to obtain $T''$, and return whether $T''$ is a subtype of $T$.
\end{enumerate}

\N
The operation {\bf $T'$::Op}$(e~{\tt as}~T)$
evaluates $e$ to a value $v$.
\begin{enumerate}
\item If $T$ is \verb'*', return $v$ if it is an object, otherwise 
return a box carrying the (numeric or boolean) value with type $T$.
\item If $T'$ is a value type,
\begin{enumerate}
\item If $T$ is a value type,
  convert $v:T'$ to $T$, and
  return the result.
\item If $T$ is {\tt String}
  convert $v:T'$ to {\tt String}, and
  return the result.
\end{enumerate}
\item Otherwise, perform ${\bf GetType}(v)$ to obtain $T''$.
\begin{enumerate}
\item If $T''$ is a value type, perform ${\bf Unbox}(v)$
to obtain $v'$, perform {\bf $T''$::Op}$(v'~{\tt as}~T)$, and return the result.
\item If $T''$ is a subclass of $T$, return $v$.
\item Otherwise, assert that $T$ is \verb'String', perform
  $v{\tt.toString()}$ and return the result.
\end{enumerate}
\end{enumerate}

\N
The operation {\bf $T'$::Op}$(e~{\tt coerce}~T)$
evaluates $e$ to a value $v$.
\begin{enumerate}
\item If $T$ is \verb'*', return $v$ if it is an object, otherwise 
return a box carrying the (numeric or boolean) value with type $T$.
\item If $T'$ is a value type and $v:T'$ is promotable or implicitly
  convertible to $T$, perform the promotion or implicit conversion and
  return the result.
\item Otherwise, perform ${\bf GetType}(v)$ to obtain $T''$.
\begin{enumerate}
\item If $T''$ is a value type, perform ${\bf Unbox}(v)$
to obtain $v'$, perform {\bf $T''$::Op}$(v'~{\tt coerce}~T)$, and return the result.
\item Otherwise, assert that $T''$ is a subclass of $T$, and return $v$.
\end{enumerate}
\end{enumerate}



% \subsection{Domains and Programs}

% \begin{definition}[Domain]
% A \emph{domain} is an object that is associated with an environment
% table (which is initially empty) and a list of
% programs (which is initially empty). It also has an unnamed property that contains an optional ``parent'' domain.
% \end{definition}

% \begin{definition}[Program]
% A \emph{program} is an object that is associated with a \nonterminal{Program}.
% \end{definition}

% \N
% A \nonterminal{Program} is evaluated in a domain as follows. Let $\emph{EnvTable}$ be the
% environment table of the \nonterminal{Program}. 
% \begin{enumerate}
% \item Create a new program object $O$.
% \item Let \emph{Frame} consist of $O$ and \emph{EnvTable}.
% \item Let \emph{GlobalScopeChain} contain a frame consisting of
%   the domain and its environment table, followed by a frame consisting
%   of $O$ and $\star^\dagger$.
% \item Allocate \emph{Frame} under \emph{GlobalScopeChain}.
% \item Constant-initialize \emph{Frame}.
% \item Let
%   \emph{ScopeChain} be \emph{Frame} followed by \emph{GlobalScopeChain}.
% \item For each definition in order at the top of the \nonterminal{Program}:
% \begin{enumerate}
% \item If the definition is a \nonterminal{ClassDefinition},
%   \begin{enumerate}
% \item Create a new class object for the
%   \nonterminal{ClassDefinition} with \emph{ScopeChain}.
% \item A property is created in $O$, mapping the class
%   name to the class object.
% \end{enumerate}
% \item If the definition is an \nonterminal{InterfaceDefinition},
%   \begin{enumerate}
% \item Create a new interface object for the
%   \nonterminal{InterfaceDefinition}.
% \item A property is created in $O$, mapping the interface
%   name to the interface object.
% \end{enumerate}
% \end{enumerate}
% \item {\tt this} is bound to
% the program. 
% \item The initialization code in the \nonterminal{Program} is
%   executed.
% \item Add the program to the list of programs in the domain.
% \end{enumerate}


\section{Allocation}

\N
Allocation is the process of building run-time environments.

\begin{definition}[Default value]
The default value for a type is as follows:
\begin{enumerate}
\item If the type is \verb'*' or any other reference type, the default value is
  \verb'null'.
\item If the type is numeric, the default value is the zero of that
  numeric type.
\item If the type is bool, the default value is false.
\end{enumerate}
\end{definition}

\N
Allocation of a class $C$ proceeds as follows:
\begin{enumerate}
\item A run-time environment is built, pairing names to locations for
  the (instance and) static methods and static variables of the class,
  and copying the non-conflicting run-time bindings of the base class.
\item Those locations corresponding to the (instance and) static
  methods defined in this class are initialized by 
  corresponding function closures  constructed by {\bf
  NewFunction} with empty run-time environments.
\item Those locations
that correspond to static variables marked \verb'var' defined in this class are initialized
with their default values based on their types.
\end{enumerate}

\N
Allocation of an instance of class $C$ proceeds as follows:
\begin{enumerate}
\item A run-time environment is built, pairing names to
locations for the instance variables of the class and its super classes.
\item Those locations
that correspond to instance variables marked \verb'var' are initialized
with their default values based on their types.
\end{enumerate}

\N
Allocation of a function invocation of function $F$ proceeds as follows:
\begin{enumerate}
\item A run-time environment is built, pairing names to
locations for the parameters, local variables, and local functions of the function, and
copying the run-time bindings of the enclosing local scope, if any.
\item Those locations
that correspond to local functions defined in the
function are initialized
with their corresponding function closures constructed by {\bf
  NewFunction} with the current
run-time environment.
\item Those locations
that correspond to local variables marked \verb'var' defined in the
function are initialized
with their default values based on their types.
\end{enumerate}

\N
Allocation for a block proceeds as follows:
\begin{enumerate}
\item A run-time environment is built, pairing names to
locations for the local variables and local functions of the function, and
copying the run-time bindings of the enclosing local scope, if any.
\item Those locations
that correspond to local functions defined in the
function are initialized
with their corresponding function closures constructed by {\bf
  NewFunction} with the current
run-time environment.
\item Those locations
that correspond to local variables marked \verb'var' defined in the
function are initialized
with their default values based on their types.
\end{enumerate}




% \section{Lookup Structure}


% % \begin{definition}[Property corresponding to QName in object] The
% %   property corresponding to a QName \emph{QName} in an object whose
% %   run-time class is $C$ is the property in
% %   the object whose QName, upon renaming
% %   $\mathbf{Protected}_{C}$ by $\mathbf{Protected}_{C'}$ where $C'$ is
% %   some recursive base class of $C$, is the same as \emph{QName}.
% % \end{definition}

% % \begin{definition}[Method corresponding to QName in object defined in
% %   closest superclass of
% %   $C$] 
% % Let $M$ be the property of a method object corresponding to QName in
% % the object. Then traverse $M$ as follows: If the function in $M$ is defined in a recursive
% % superclass of $C$, return that property. Otherwise, traverse the
% % super method object of $M$ if it exists, else throw an error.
% % \end{definition}



% \begin{definition}[Finding a property] The function {\sf find}(\emph{QName},
%   (\emph{EnvTable}, \emph{Object}), \emph{super}, \emph{write}) is defined as follows:
% \begin{enumerate}
% \item If there is a lexical binding \emph{LexBinding} corresponding to QName in
%   the environment table that is part of an accessor
%   pair, then \emph{LexBinding} must be a getter or setter based on
%   whether \emph{write} is false or true; otherwise, report an error.
% \begin{enumerate}
% \item If the environment table is associated with the instance block of a
% \nonterminal{ClassDefinition}, then let $C$ be the QName of the
% \nonterminal{ClassDefinition} if \emph{super} is true, the
% run-time class of \emph{Object} otherwise. Based
%   on whether \emph{write} is false or true, return the getter or setter property corresponding to QName in
%   the object that is defined in the closest superclass of $C$.
% \item
% Otherwise, based
%   on whether \emph{write} is false or true, return the getter or setter property corresponding to QName in
%   the object.
% \end{enumerate}

% \item Otherwise:
% \begin{enumerate}
% \item If the environment table is associated with the instance block of a
% \nonterminal{ClassDefinition}, then let $C$ be the QName of the
% \nonterminal{ClassDefinition} if \emph{super} is true, the
% run-time class of \emph{Object} otherwise. Let
% \emph{LexBinding} be the lexical binding corresponding to QName in the
% environment table.
% \begin{enumerate}
% \item If the definition of \emph{LexBinding} is a \nonterminal{VariableDefinition}, then return the variable property corresponding QName
%   in the object.
% \item Otherwise, the definition of \emph{LexBinding} is a \nonterminal{FunctionDefinition}; return the function property corresponding to QName
%   in the object that is defined in the closest superclass of $C$.
% \end{enumerate}
% \item
% Otherwise, return the property corresponding to QName in the object.
% \end{enumerate}
% \end{enumerate}
% \end{definition}

% \begin{definition}[Traits] 
% The function \emph{traits}({\sf object}, \emph{ScopeChain}, {\bf super}) is defined
% as follows:
% \begin{enumerate}
% \item Let $\lexenv$ be the lexical environment projected by \emph{ScopeChain}.
% \item If $\mathsf{object}$ is {\bf null}, report an error.
% \item If $\mathsf{object}$ is {\bf undefined}, report an error.
% \item If {\bf super} = {\bf true}, then \emph{ScopeChain} is associated with some defining scope nested by a
%   \nonterminal{ClassDefinition} whose base class is $C$. 
% If the run-time class of {\sf object} 
%   is not compatible with $C$, report a ``type incompatibility''
%   error. Otherwise, let the
%   instance environment table of $C$ be
%   $\mathsf{baseclass}$. Return $\mathsf{baseclass}$.
% \item If {\sf object} is a program, return
%   $\emph{envtable}^\star$ where
%   \emph{envtable} is the environment table of the program.
% \item If the run-time class of {\sf object} is $C$, then let the
%   instance environment table of $C$ be $\mathsf{class}$.
% \begin{enumerate}
% \item If the {\sf dynamic} field of \emph{classInfo} is {\bf true},
%   return $\mathsf{class}^\star$.
% \item Otherwise, return $\mathsf{class}$.
% \end{enumerate}
% \item If {\sf object} is a class $C$, then let
%   $\mathsf{metaclass}$ be the
%   static environment table of $C$. Return $\mathsf{metaclass}^\star$.
% \end{enumerate}
% \end{definition}

% \begin{definition}[Lookup structure for dynamic evaluation of expressions] Evaluation of names for
% dynamic evaluation of expressions is characterized by the following lookup
% structure.
% \begin{enumerate}
% \item {\bf Result}s are values
% \item {\bf Binding}s are properties, with: 
% \begin{enumerate}
% \item the function {\sf
%     read}(\emph{Property}) defined as follows:
% \begin{enumerate}
% \item If the \emph{Property} is a getter property, invoke the getter
%   (a bound function)
%   with no arguments and return its result.
% \item Otherwise, return the value of \emph{Property}.
% \end{enumerate}
% \item the function {\sf
%     write}(\emph{Property}, \emph{Result}) defined as follows:
% \begin{enumerate}
% \item If the \emph{Property} is a setter property, invoke the setter
%   (a bound function)
%   with \emph{Result} and return.
% \item If the \emph{Property} is constant and its initialization
%   attribute is false,
%   report an error.
% \item Otherwise, coerce \emph{Result} to the type of \emph{Property},
%   yielding a value; store the value in \emph{Property}.
% \end{enumerate}

% \item the function {\sf
%     call}(\emph{Property}, \emph{Results}) defined as follows.
% \begin{enumerate}
% \item Let $V_0$ be the object to which \emph{Property} belongs, unless
%   the object is an activation object, in which case $V_0$ is the program.
% \item Let $f$ be the result of invoking {\sf read}(\emph{Property}).
% \item Let \emph{Results} be $V_1,\dots,V_k$.
% \item If $f$ is a class $C$, then: 
% \begin{enumerate}
% \item If $C$ is
%   a value type, then
%   return whatever is yielded by constructing $C$ with $V_1,\dots,V_k$.
% \item If $k = 1$, coerce $V_1$ to $C$ and return the result.
% \item Otherwise, report an error.
% \end{enumerate}
% \item If $f$ is a function and the type of the 
%   \emph{Property} is $([T'_1,\dots,T'_i],[T'_{i+1},\dots,T'_{i+j}],\emph{rest})
%   \rightarrow T'$:
% \begin{enumerate}
% \item Create a new activation object based on the environment table
%   associated with the \nonterminal{FunctionBody}.
% \item If $f$ is bound to an object, let $V_0$ be that object.
% \item Let $T_1,\dots,T_k$ be the run-time classes of
%   $V_1,\dots,V_k$. 
% \item If $i \leq k \leq i+j$ and $T_1$,
%   \dots, $T_k$ are respectively \emph{compatible} with
%   $T'_1,\dots,T'_k$, then coerce the values $V_1,\dots,V_k$ to the
%   types $T'_1,\dots,T'_k$ yielding $V'_1,\dots,V'_k$, update the properties corresponding to the
%   arguments $1,\dots,k$ with $V'_1,\dots,V'_k$. If \emph{rest} is
%   true, update the \emph{rest} property with a new empty array;
%   otherwise update the \emph{arguments} property
%   with a new array initialized with $V'_1,\dots,V'_k$.
% \item If \emph{rest} is true, $i+j < k$, and $T_1$,
%   \dots, $T_{i+j}$ are respectively \emph{compatible} with
%   $T'_1,\dots,T'_{i+j}$, then coerce the values $V_1,\dots,V_{i+j}$ to the
%   types $T'_1,\dots,T'_{i+j}$ yielding $V'_1,\dots,V'_{i+j}$, update the properties corresponding to the
%   arguments $1,\dots,i+j$ with $V'_1,\dots,V'_{i+j}$. Update the
%   \emph{rest} property with a new array initialized with
%   $V_{i+j+1},\dots,V_k$.
% \item Try executing the \nonterminal{FunctionBody} with the scope
%   chain extended with the activation object, and {\bf this} bound to $V_0$.
% \item If a ``return'' jump is thrown with value $V$, coerce $V$ to $T$
%   and return $V$.
% \end{enumerate}
% \item Otherwise, if $f$ is a function and $f$ has $i+j$
%   non-rest parameters and \emph{rest} holds whether it has a rest parameter:
% \begin{enumerate}
% \item Create a new activation object based on the environment table
%   associated with the \nonterminal{FunctionBody}.
% \item If $k \leq i+j$, update the properties corresponding to the
%   arguments $1,\dots,k$ with $V_1,\dots,V_k$. If \emph{rest} is
%   true, update the \emph{rest} property with a new empty array;
%   otherwise update the \emph{arguments} property
%   with a new array initialized with $V_1,\dots,V_k$.
% \item If $i+j < k$, update the properties corresponding to the
%   arguments $1,\dots,i+j$ with $V_1,\dots,V_{i+j}$. If \emph{rest} is
%   true, update the
%   \emph{rest} property with a new array initialized with
%   $V_{i+j+1},\dots,V_k$; otherwise  update the \emph{arguments} property
%   with a new array initialized with $V_1,\dots,V_k$.
% \item Try executing the \nonterminal{FunctionBody}  with the scope
%   chain extended with the activation object, and {\bf this} bound to $V_0$.
% \item If a ``return'' jump is thrown with value $V$, return $V$.
% \end{enumerate}
% \item Otherwise report an error.
% \end{enumerate}

% \end{enumerate}
% \item {\bf Container}s are frames (and {\bf Container} lists are scope chains)
% \item The function {\sf lookup}(\emph{Name}, (\emph{EnvTable},
%   \emph{Object}), \emph{super}, \emph{write}) is
%   defined as follows, where \emph{Name} must be a Multiname. 
% \begin{enumerate}

% \item Let \emph{Names} be the set of QNames corresponding
%   to the Multiname, and let \emph{FixedEnvTable} be such that
%   $\emph{EnvTable} = \emph{FixedEnvTable}^\star$ if \emph{EnvTable} is
%   dynamic, $\emph{EnvTable} = \emph{FixedEnvTable}$ otherwise.

% \item Let \emph{Fixed} be the set of QNames that are bound in the
%   \emph{FixedEnvTable}.
% \item Let \emph{Candidates} be the intersection of \emph{Names} and
%   \emph{Fixed}.
% \item If \emph{Candidates} has a single QName, then 
%  invoke {\sf
%     find}(\emph{QName}, (\emph{FixedEnvTable}, \emph{Object}),
%   {\bf super}, \emph{write}); if found, return the result.
% \item If \emph{Candidates} has multiple QNames, then report an
%   ``ambiguous reference'' error.

% \item If \emph{Object} is a domain:
% \begin{enumerate}
% \item Let \emph{domain'} be the value of the {\bf parent} property of
%   the domain. If \emph{domain'} is not null and its environment table
%   is \emph{EnvTable'}, invoke
%   {\sf lookup}(\emph{Name}, (\emph{domain'}, \emph{EnvTable'}), {\bf
%     super}, \emph{write}). If
%   found, add the property to \emph{domain} and its lexical binding to 
%   its environment table, and
%   return the result.
% \item For each program \emph{program} in the list of programs of this domain, invoke
%   {\sf lookup}(\emph{Name}, (\emph{program}, \emph{programEnvTable}) , {\bf
%     super}, \emph{write})
%   where \emph{programEnvTable} is the environment table of
%   the program. If found, add the property to \emph{domain} and its lexical binding to 
%   its environment table, and
%   return the result.
% \item Otherwise, report an error.
% \end{enumerate}


% \item If \emph{FixedEnvTable} is the instance environment table of a class,
%   let \emph{EnvTable'} be the base of \emph{FixedEnvTable}. Let
%   \emph{Name'} be \emph{Name} with any {\bf Protected} namespace value
%   renamed by its base. Invoke {\sf lookup}(\emph{Name'},
%   (\emph{EnvTable'}, \emph{Object}), {\bf
%     super}, \emph{write}) and return the result, if found.
% \item If \emph{EnvTable} is dynamic, \emph{Names} contains a QName
%   whose namespace is {\bf Public}, and there is a dynamic property of
%   \emph{Object} with that QName, then return the pair consisting of
%   a dummy lexical binding and that dynamic property.
% \item If \emph{write} is false: 
% \begin{enumerate}
% \item If \emph{EnvTable} is dynamic or final and the \emph{Prototype} property of the
%   object is not {\bf null}, let $O'$ be the \emph{Prototype} property
%   of $O$. Invoke {\sf
%     lookup}(\emph{Name}, ($\star$, $O'$)), yielding $(\emph{LexBinding},\emph{Property})$. Return
%   a pair consisting of \emph{LexicalBinding} and a dummy property 
%   belonging to \emph{Object} whose value is the value of \emph{Property}.
% \item If \emph{EnvTable} is dynamic and final, return a dummy lexical binding
%   and a dummy property belonging to \emph{Object} whose
%   value is {\bf undefined}.
% \item Otherwise, report an error.
% \end{enumerate}

% \item If \emph{write} is true:
% \begin{enumerate}
% \item If \emph{EnvTable} is dynamic and final and \emph{Names} contains a QName
%   whose namespace is {\bf Public}, add a new dynamic property
%   belonging to \emph{Object} in \emph{Object}, with
%   that QName whose initial value is \emph{Result}, and return a dummy lexical binding and
%  that property. (All
%   dynamic properties are enumerable and writable and have no type constraint.)
% \item Otherwise, report an error.
% \end{enumerate}

% \end{enumerate}
% \item The function {\sf extract}(\emph{Result}, 
%   \emph{ScopeChain}, {\bf super}) is defined as follows:
% \begin{enumerate}
% \item Invoke {\sf traits}(\emph{Result}, \emph{ScopeChain}, {\bf super}),
%   yielding an environment table \emph{EnvTable}.
% \item Return $(\emph{Result}, \emph{EnvTable}^\dagger)$.
% \end{enumerate}

% % \item The function {\sf constructor}(\emph{Result}, \emph{ScopeChain}) is
% %   defined as follows:

% % \begin{enumerate}
% % \item If the run-time class of \emph{Result} is {\tt Function}, return
% %   \emph{Result}.
% % \item If the run-time class of \emph{Result} is {\bf meta}($C$),
% %   return the constructor method of $C$.
% % \item Otherwise, report an error.
% % \end{enumerate}





% \item the {\sf eval} function is defined in the next chapter; for every
%   \nonterminal{Expression} in the \nonterminal{Program}, we invoke
%   {\sf eval} on the \nonterminal{Expression} and  the lexical
%   environment of the binding scope enclosing the
%   \nonterminal{Expression} paired with the current scope chain.
% \end{enumerate}
% \end{definition}


% \section{Property Expressions}

% \N
% Property expressions evaluate to property names before they are used in property lookup. Some
% property expressions are constants and can be evaluated to property names at compile time, but
% others are dynamic and are evaluated under an execution context.

% \subsection{Property Names}

% \begin{definition}[Wildcard name] A \emph{wildcard name} is of the form \verb'*' or $\nsval \verb'::' \verb'*'$ 
% or $\verb'*' \verb'::' \id$, where $\nsval$ is a namespace value and $\id$ is a \emph{string literal}.
% \end{definition}

% \jeff{The term \emph{string literal} is not to be confused with the syntactic \nonterminal{StringLiteral}. The
% former consists only of a sequence of characters while the latter includes the surrounding quotes possibly
% embedded escape sequences. See the definition of \emph{string literal}
% for more.}

% \avik{Elsewhere in this specification, we have used ``identifier''
%   instead of ``string literal'': unfortunately, that is equally confusing, since
%   ``identifier'' may represent {\tt''*''} or really any character
%   sequence that is not syntactically an
%   \lexicalnonterminal{Identifier}. Throughout, I would prefer
%   renaming ``string literal'' to something neutral, like ``character
%   sequence.'' In fact, what we really want is to express ``interned string,''
%   which is alternatively called ``symbol'' in some
%   languages. Another neutral possibility is ``index.''}

% \begin{definition}[Name] A \emph{name} is a \emph{multiname} or a \emph{wildcard name}.
% \end{definition}

% \begin{definition}[Property name] A \emph{property name} is of the form $\name$ or $\verb'@' \name$, 
% where $\name$ is a \emph{name}.
% \end{definition}

% \N
% A property expression is evaluated to a property name as follows.

% \begin{enumerate}
% \item If the property expression is a multiname, return
%   the multiname.

% \item If the property expression is a LMultiname of the form
%   $\{\nsval_1,\dots,\nsval_k\}\verb'::'[\mathsf{strexp}]$, then:
% \begin{enumerate}
% \item Evaluate
%   $\mathsf{strexp}$ to a string literal $\id$.
% \item Return the multiname
%   $\{\nsval_1,\dots,\nsval_k\}\verb'::'\mathsf{id}$.
% \end{enumerate}

% \item If the property expression is \verb'*', return \verb'*'.

% \item If the property expression is of the form $\mathsf{nsexp}\verb'::'\mathsf{id}$, then:
% \begin{enumerate} 
% \item Evaluate
%   $\mathsf{nsexp}$ to a namespace value $\nsval$ or \verb'*'.
% \item Return the multiname $\{\nsval\}
%   \verb'::' \mathsf{id}$ or the wildcard name $\verb'{\tt *}::'\id$.
% \end{enumerate}

% \item If the property expression is of the form $\mathsf{nsexp}\verb'::*'$, then:
% \begin{enumerate} 
% \item Evaluate
%   $\mathsf{nsexp}$ to a namespace value $\nsval$ or \verb'*'.
% \item Return the wildcard name $\nsval
%   \verb'::*'$ or $\verb'*'$.
% \end{enumerate}

% \item If the property expression is of the form
%   $\mathsf{nsexp}\verb'::'[\mathsf{strexp}]$, then:
% \begin{enumerate}
% \item Evaluate
%   $\mathsf{nsexp}$ to a namespace value $\nsval$ or \verb'*'.
% \item Evaluate
%   $\mathsf{strexp}$ to a string literal $\id$.
% \item Return the multiname $\{\nsval\}
%   \verb'::' \mathsf{id}$ or the wildcard name $\verb'{\tt *}::'\id$.
% \end{enumerate}

% \item If the property expression is of the form
%   $\verb'@'\mathsf{nameexp}$, then:
% \begin{enumerate}
% \item Evaluate
%   $\mathsf{nameexp}$ to a name $\mathsf{name}$.
% \item Return the property name $\verb'@'\mathsf{name}$.
% \end{enumerate}


% \end{enumerate}

 

\chapter{Linking, Verification, and Evaluation}\label{chap:evaluation}

\makeatletter{}% Copyright 2010-2011 Adobe Systems Inc.  All rights reserved.

This chapter describes the processes of linking and initialization of
classes that serve to regenerate lexical envionments and trigger
execution of an executable. It also describes the
processes of verification and execution of statements
and expressions; in particular, verification involves the transformation of expressions to
intrinsic operations, whose evaluation semantics are defined in the previous chapter.

\section{Linking and Initialization of Classes}

\N
Execution of an executable is triggered by the \emph{initialization}
of the class that contains the static method that serves as the entry
point, followed by \emph{calling} the static method itself. (The entry
point's type is asserted to be \verb'() => void'.)

\N
A class must be \emph{linked} before it is initialized.

\N
The linking of a class or interface proceeds as follows:

\begin{enumerate}
\item The base class and the base interfaces must be linked (if they have not
  already been linked).
\item The class or interface is visited to build lexical environments,
  as prescribed for compilation, and the definition is added to the
  global lexical environment.
\end{enumerate}

\N
Linking a type must not recursively trigger linking of the same
type: this indicates that the type recursively extends itself, which
results in an error.

\N
Calling a function must be preceded by the verification of the body of
that function (if it has not already been verified). 

\N
Any types that appear in some code, and are thus required for
verification of that code, must be linked
before verification proceeds.

\N
Initialization of a class $C$ proceeds as follows:
\begin{enumerate}
\item The base class must be initialized (if it has not already been
  initialized).
\item A constructor of the form
\begin{verbatim}
function C(params) {
  super(args); 
  ...; 
  defer stmt;
}
\end{verbatim}
 is
  translated to an instance method of the form 
\begin{verbatim}
function %init%(params) { 
  let k:()=>void = super.%init%(args); 
  ...;
  return function() { k(); stmt; }; } 
}
\end{verbatim}


\item Any instance method of the form 
\begin{verbatim}
function f(params) {...}
\end{verbatim}
is
  translated to a static method of the form 
\begin{verbatim}
static function f(this:C) { return function(params) {...}; }
\end{verbatim}

\item Allocation for the class is performed.
\item A class is built that carries the
  \nonterminal{ClassInheritance} and the \nonterminal{ClassBody}, as
  well as the maps built by allocation, and is added to the global
 run-time environment.
\item The static constructor of the class is found by {\bf
    GetStaticMember}$(C.{\bf static})$, yielding a function closure $f$
  that is called by {\bf Call}$(f())$.
\end{enumerate}

\N
Initialization of a class must not recursively trigger initialization of the same
class: this indicates that the class recursively depends on itself, which
results in an error.



\section{Verification}

\N
Dynamic verification closely mimics static verification, except that
there is no promotability or implicit coercibility. 
In addition to type constraints, enforcement of access control and
\verb'let' semantics is carried out as prescribed for compilation.

\subsection{References}

\N
A local read of the form $x$ is verified and translated as follows:
\begin{enumerate}
\item Look up $x$ in the lexical
  environment, yielding a definition; let its type be $T_1$.
\item Translate the expression to {\bf
  GetLocal}($x$) and return its type as $T_1$.
\end{enumerate}

\N
A local write of the form $x = e$ is verified and translated as follows:
\begin{enumerate}
\item Look up $x$ in the lexical
  environment, yielding a definition; let the type of the
  variable definition be $T_1$.
\item Verify and translate $e$ to $e'$, let its type be $T_2$.
\item Assert that $T_2$ is a subtype of $T_1$.
\item Translate the expression to {\bf
  SetLocal}($x = e'$).
\end{enumerate}

\N
An instance member read of the form $o.x$ is verified and translated
as follows:
\begin{enumerate}
\item Verify and translate $o$ to $o'$, let its type be $T$.
\item If $T$ is \verb'*', translate the expression to {\bf
    {\tt *}::GetInstanceMember}($o'.x$) and return its type as \verb'*'.
\item Otherwise, look up \verb'x'
  in the lexical environment associated with type $T$,
  yielding a definition. Let $T_1$ be the type of the definition. If the definition is of
  a variable, translate the expression as the operation {\bf
    GetInstanceField}$(o'.x)$; otherwise the definition is of a
  function, translate the expression as  
 {\bf
  GetInstanceMethod}$(o'.x)$. Return its type as $T_1$.
\end{enumerate}

\N
An instance member write of the form $o.x = e$ is verified and
translated as follows:
\begin{enumerate}
\item Verify and translate $o$ to $o'$, let its type be $T$.
\item Verify and translate $e$ to $e'$, let its type be $T_2$.
\item If $T$ is \verb'*', assert that $T_2$ is \verb'*', and translate the expression to {\bf
    {\tt *}::SetInstanceMember}($o'.x = e'$).
\item Otherwise, look up \verb'x'
  in the lexical environment associated with type $T$,
  yielding a variable definition. Let $T_1$ be the type of the definition. Assert that $T_2$ is a
  subtype of $T_1$ and the definition is of
  a variable, translate the expression as {\bf
    SetInstanceField}$(o'.x = e')$.
\end{enumerate}

\N
A super method read of the form ${\tt super}.x$ is verified and
translated as follows:
\begin{enumerate}
\item Look up $x$ in
  the
  lexical environment of the instance scope of the base class of the enclosing class
  definition, yielding a function definition.
\item Let $T$ be the type
  of the definition.
\item Translate the expression as {\bf
  GetSuperMethod}(${\tt super}.x$) and return its type as $T$.
\end{enumerate}


\N
A static member read of the form ${\bf static}.x$ is verified and
translated as follows:
\begin{enumerate}
\item Look up $x$ in
  the
  lexical environment of the static scope of the enclosing class
  definition, yielding a definition.
\item Let $T_1$ be its type.
\item Translate the expression as {\bf
  GetStaticLex}(${\bf static}.x$) and return $T_1$ as its type.
\end{enumerate}

\N
A static field write of the form ${\bf static}.x = e$ is verified and
translated as follows:
\begin{enumerate}
\item Look up $x$ in
  the
  lexical environment of the static scope of the enclosing class
  definition, yielding a variable definition.
\item Let $T_1$ be its type.
\item Verify and translate $e$ to $e'$, let its type be $T_2$.
\item Assert that $T_2$ is a subtype of $T_1$.
\item Translate the expression as {\bf
  SetStaticLex}(${\bf static}.x = e'$).
\end{enumerate}

\N
A static member read of the form $C.x$ is verified and
translated as follows:
\begin{enumerate}
\item Look up $x$ in
  the
  lexical environment of the static scope of the class
  definition $C$, yielding a definition.
\item Assert that the definition appears in the class body of $C$.
\item Let $T_1$ be its type.
\item Translate the expression as {\bf
  GetStaticMember}($C.x$) and return $T_1$ as its type.
\end{enumerate}

\N
A static field write of the form $C.x = e$ is verified and
translated as follows:
\begin{enumerate}
\item Look up $x$ in
  the
  lexical environment of the static scope of the class
  definition $C$, yielding a variable definition.
\item Assert that the definition appears in the class body of $C$.
\item Let $T_1$ be its type.
\item Verify and translate $e$ to $e'$, let its type be $T_2$.
\item Assert that $T_2$ is a subtype of $T_1$.
\item Translate the expression as {\bf
  SetStaticMember}($C.x = e'$).
\end{enumerate}

\N
An element read of the form  \verb'a[i]' is verified and translated as
follows:
\begin{enumerate}
\item Verify and translate $a$ to $a'$, let its type be $T$.
\item Verify and translate $i$ to $i'$, and assert that its type is
  \verb'int'. 
\item If $T$ is \verb'*' then translate the expression as  {\bf {\tt *}::GetIndex}$(a'[i'])$ and return its type as \verb'*'.
\item Otherwise, assert that $T$ is \verb'[]'$T_1$ or \verb'ArrayList<'$T_1$\verb'>',
  translate the expression as {\bf $T$::GetIndex}$(a'[i'])$, and return its type as $T_1$.
\end{enumerate} 

\N
An element write of the form  \verb'a[i] = e' is verified and translated as
follows:
\begin{enumerate}
\item Verify and translate $a$ to $a'$, let its type be $T$.
\item Verify and translate $i$ to $i'$, and assert that its type is
  \verb'int'. 
\item Verify and translate $e$ to $e'$, let its type be $T_2$.
\item If $T$ is \verb'*' then assert that $T_2$ is \verb'*' and translate the expression as  {\bf {\tt *}::SetIndex}$(a'[i'] = e')$.
\item Otherwise, assert that $T$ is \verb'[]'$T_1$ or \verb'ArrayList<'$T_1$\verb'>',
  and that $T_2$ is a subtype of $T$, and
  translate the expression as {\bf $T$::SetIndex}$(a'[i'] = e')$.
\end{enumerate} 

% \N \todo{move}

% Evaluate a \nonterminal{LeftHandSideExpression} to a reference, as follows.
% \begin{enumerate}
% \item If the reference is a name, look up the name in the scope
%   object, yielding a slot; return the value of the slot.
% \item If the reference is of the form \verb'super.m', look up \verb'm'
%   as an instance method of the
%   superclass; assert that it is a function
%   closure, assert that its declaration is marked \verb'public' or
%   \verb'protected', or it is marked \verb'internal' and the reference
%   is enclosed in the same package as the base class; return the
%   function closure with \verb'this' bound to the result of evaluating \verb'this'.
% \item If the reference is of the form \verb'(P.C).x', look up \verb'x'
%   as a static field or static method of \verb'P.C'; assert that its declaration is marked \verb'public', or
%   it is marked \verb'protected' and the reference is enclosed in a subclass
%   of \verb'P.C', or it is marked \verb'private' and the reference is
%   enclosed in the same class \verb'P.C', or it is marked
%   \verb'internal' and the reference is enclosed in the same package as
%   the class \verb'P.C'; return the value.
% \item If the reference is of the form \verb'o.x', compute the type $T$
%   of $o$.
% \begin{enumerate}
% \item If $T$ is \verb'*', unbox $o$ to type $T$; look up \verb'x'
%   as an instance field or method of $T$; assert that its declaration is marked \verb'public', or
%   it is marked \verb'protected' and the reference is enclosed in a superclass
%   of  $T$, or it is marked \verb'private' and the reference is
%   enclosed in the same class $T$, or it is marked
%   \verb'internal' and the reference is enclosed in the same package as
%   $T$; return the value.
% \item Otherwise, look up \verb'x'
%   as an instance field or method of $T$; return the value.
% \end{enumerate}
% \item If the reference is of the form \verb'o[x]', compute the type $T$
%   of $o$.
% \begin{enumerate}
% \item If $T$ is \verb'*', unbox $o$ to \verb'[]T' or \verb'Vector<T>', and \verb'x'
%   must be \verb'int' or \verb'long' or unboxable to such. Look up
%   index \verb'x' on $o$.
% \item Unbox $o$ to \verb'[]T' or \verb'Vector<T>', and \verb'x'
%   must be \verb'int' or \verb'long'. Look up
%   index \verb'x' on $o$.
% \end{enumerate}
% \end{enumerate}

\subsection{Literals}

\subsubsection{Null Literal}

\N
Evaluate \verb'null' to the value \verb'null' of type $\{{\tt null}\}$.

\subsubsection{Boolean Literals}

\N
Evaluate \verb'true' or \verb'false' to the corresponding value of
type \verb'bool'.


\subsubsection{Number Literals}

\N
Evaluate an integral \nonterminal{NumericLiteral} to a value of type
\verb'int' (32-bit signed integer).

\N
Evaluate a non-integral \nonterminal{NumericLiteral} to a value of type
\verb'double' (double precision floating point number as defined in
IEEE 754).


\subsubsection{String Literals}

% \begin{definition}[Escape sequence translation] The process of \emph{escape sequence translation} 
% rewrites a \emph{string value} containing escape sequences to a \emph{string value} containing no
% escape sequences. \emph{Escape sequence translation} is performed by translating each character 
% sequence $chars$ of the original \emph{string value} as follows:

% \begin{enumerate}
% \item If $chars$ is of the form \verb'\xNN', where NN is a sequence of two hex digits:
%     \begin{enumerate}
%     \item Compute the \emph{number value} of the hexidecimal number NN, yielding $num$.
%     \item Return the Unicode character with the code point of $num$.
%     \end{enumerate}
% \item If $chars$ is of the form \verb'\uNNNN', where \verb'NNNN' is a sequence of four hex digits:
%     \begin{enumerate}
%     \item Compute the \emph{number value} of the hexidecimal number \verb'NNNN', yielding $num$.
%     \item Return the Unicode character with the code point of $num$.
%     \end{enumerate}
% \item If $chars$ is of the form \lexicalnonterminal{LineContinuation}, return the single space character.
% \item If $chars$ is of the form \verb'\'{\tt '}, return the \emph{single quote} character {\tt '}.
% \item If $chars$ is of the form \verb'\"', return the \emph{double quote} character \verb'"'.
% \item If $chars$ is of the form \verb'\\', return the \emph{backslash} character \verb'\'.
% \item If $chars$ is of the form \verb'\b', return the \emph{backspace} character {\bf U+0008}.
% \item If $chars$ is of the form \verb'\t', return the \emph{tab} character {\bf U+0009}.
% \item If $chars$ is of the form \verb'\n', return the \emph{newline} character {\bf U+000A}.
% \item If $chars$ is of the form \verb'\v', return the \emph{vertical tab} character {\bf U+000B}.
% \item If $chars$ is of the form \verb'\f', return the \emph{form feed} character {\bf U+000C}.
% \item If $chars$ is of the form \verb'\r', return the \emph{carriage return} character {\bf U+000D}.
% \item Return \lexicalnonterminal{SourceCharacter}.
% \end{enumerate}

% \end{definition}

% \N
% The syntactic nonterminal \nonterminal{PrimaryExpression} of the form \lexicalnonterminal{StringLiteral}
% denotes a \emph{string literal} with the \emph{string value} denoted by \lexicalnonterminal{SingleStringCharacter}
% and \lexicalnonterminal{DoubleStringCharacter} after \emph{escape sequence translation} of the corresponding 
% lexeme.

\N
Evaluate a \nonterminal{StringLiteral} to a string.

\subsection{Primary Expressions}
\label{sec:primary-expressions}

\subsubsection{Regular Expression Initializers}

\N
Verify and translate a \emph{regular expression initializer} of the form 
$\verb'/' {\sf pattern} \verb'/' {\sf flags}$, as follows:

\begin{enumerate}
\item Assert that {\sf pattern} and
{\sf flags} are strings.
\item Translate the expression to  
      {\tt new RegExp(}${\sf pattern}${\tt,}${\sf flags}${\tt)} of
      type {\tt RegExp}.
\end{enumerate}

\subsubsection{Array Initializers}

\N 
An \emph{array initializer} of the form ${\tt new []} T\{\expr_1, \dots, 
\expr_k\}$, where $T$ is a type and $\expr_1, \dots, \expr_k$ is a
sequence of expressions, is verified and translated as follows:

\begin{enumerate}
\item Verify and translate the sequence of expressions $\expr_1,
  \dots, \expr_k$ to $\expr'_1, \dots, \expr'_k$.
\item Assert that the types of $\expr'_1, \dots, \expr'_k$ are
  subtypes of \verb'T'.
\item Translate the expression to {\bf NewArray}$({\tt new}
  []T\{\expr'_1, \dots, \expr'_k\})$ of type \verb'[]T'.
\end{enumerate}

% \subsection{PropertyMap Initializers}

% \begin{definition}[Property map initializer] An \emph{property map initializer} is of the form 
% $\{\field_1, \dots, \field_k\}$, where $\field_1, \dots, \field_k$ represents a sequence of 
% \emph{fields}, where a \emph{field} is of the form $\str : \expr$, where $\str$ is a 
% \emph{string value} and $\expr$ is an expression.
% \end{definition}

% \N
% Evaluate an \emph{property map initializer} as follows:

% \begin{enumerate}
% \item Construct a value of type \subr{PropertyMap} denoted by {\tt new PropertyMap()}, yielding $obj$.
% \item For each field $\str:\expr$ of the \emph{property map initializer}:
%       \begin{enumerate}
%       \item Evaluate $\str$ yielding $str$ (verified to be of type \verb'String').
%       \item Evaluate $\expr$ yielding the value $val$ (verified to be
%         of type \verb'*').
%       \item Call $obj.put(str,val)$.
%       \end{enumerate}
% \item Return $obj$.
% \end{enumerate}


\subsubsection{Function Initializers}

% \jeff{Definitions like the following, which define purely static constructs, should be moved to an earlier
% chapter of the spec along with the translation from syntax. This leaves only the definition of function expression
% and function closure here.}

% \begin{definition}[Function signature] A \emph{function signature} is of the form
% $(\id_1:\ty_1, ..., \id_i:\ty_i, \id_j:\ty_j=\val_j, ..., \id_k:\ty_k=\val_k, \id_l:\ty_l)$ $\verb':'$ $\ty_r$ where
% $\id_1:\ty_1, ..., \id_i:\ty_i$ is a sequence of zero or more (identifier, type value) pairs,
% $\id_j:\ty_j=\val_j, ..., \id_k:\ty_k=val_k$ is a sequence of zero or more (identifer, type value, value) triples,
% $\id_l:\ty_l$ is a possibly missing (identifier, type value) pair, and $\ty_r$ is a possibly missing type value.
% \end{definition}

% \begin{definition} [Function info] A \emph{function info} is of the form $\verb'('\sig, \body\verb')'$,
% where $sig$ is a \emph{function signature} and $body$ is a \emph{function body}.
% \end{definition}

% \begin{definition} [Function expression] A \emph{function expression} is of the form $\verb'('\id, 
% \info \verb')'$, where $\id$ is an identifier and $\info$ is a \emph{function info}.
% \end{definition}

% \N
% The syntactic nonterminal \nonterminal{FunctionSignature} represents a \emph{function signature}
% where each \nonterminal{Parameter} represents the corresponding element of the sequence $\id_1:\ty_1, ..., \id_i:\ty_i$,
% and each \nonterminal{OptionalParameter} represents the corresponding element of the sequence
% $\id_j:\ty_j=\val_j, ..., \id_k:\ty_k=\val_k$, and a \nonterminal{RestParameter} represents $\id_l:\ty_l$,
% and \nonterminal{ResultType}\tag{opt} represents $\ty_r$.

% \N
% A syntactic nonterminal \nonterminal{FunctionExpression} denotes a \emph{function expression}, where
% \nonterminal{Identifier} denotes $\id$ and \nonterminal{FunctionSignature} $\sig$ and 
% \nonterminal{FunctionBody} denote a \emph{function info}.

\N
A \nonterminal{FunctionInitializer} is verified and translated as follows:

\begin{enumerate}
\item Translate the expression to {\bf
    NewFunction}(\nonterminal{FunctionBody}).
\item Return the function type derived from the \nonterminal{FunctionSignature}.
\end{enumerate}

\subsubsection{This}

\N
Verify and translate {\tt this} as follows:

\begin{enumerate}
\item Assert that it is enclosed by the instance scope of some class
  $C$.
\item Translate the expression as {\bf GetLocal}({\tt this}) of type $C$.
\end{enumerate}
 
\makeatletter{}% Copyright 2010-2011 Adobe Systems Inc.  All rights reserved.

\subsection{Call Expression}

\N
Verify and translate a \emph{call expression} of the form $\expr_0 \verb'(' \expr_1, ..., \expr_k \verb')'$, 
where $\expr_0$ is an expression and $\expr_1, ..., \expr_k$  is a
sequence of expressions, as follows:
\begin{enumerate}
\item Verify and translate $\expr_0$ to $f$ of type $T$.
\item Verify and translate $\expr_1,\dots,\expr_k$ to
  $\expr'_1,\dots,\expr'_k$ of types $T'_1,\dots,T'_k$. 
\item If $T$ is \verb'*', then assert that $T'_1,\dots,T_k$ are
  \verb'*'. If the expression is not a statement, translate the expression to {\bf
    {\tt *}::CallReturn}$(f(\expr'_1,\dots,\expr'_k))$; otherwise translate the expression to {\bf
    {\tt *}::Call}$(f(\expr'_1,\dots,\expr'_k))$. Return \verb'*'.
\item Otherwise $T$ is a function type
  $(T_1,\dots,T_k) \Rightarrow T'$. Assert that $T'_1,\dots,T_k$ are
  subtypes of $T_1,\dots,T_k$. Translate the expression to {\bf
    Call}$(f(\expr'_1,\dots,\expr'_k))$ and return $T'$.
\end{enumerate}


% \N \todo{move}

% \begin{enumerate}
% \item Evaluate $\expr_0$ yielding $val$.
% \item Evaluate $\expr_1, ..., \expr_k$ yielding the sequence of values $args$.
% \item If $\val$ is of type \verb'*':
% \begin{enumerate}
% \item Unbox $\val$ to a function closure, throwing a run-time error on
%   failure.
% \item Let $\lexenv$ be the lexical environment of the function
%   closure.
% \item Create a new scope object based on the lexical environment.
% \item Copy any properties of the scope object carried by the function
%   closure into the new scope object.
% \item Initialize \verb'this' with the \verb'this' binding in the
%   function closure if and only if (verifiably) there is a \verb'this' identifier in the lexical environment.
% \item Initialize
%   the identifier with the function closure if and only if (verifiably)
%   there is a
%   identifier for the function closure.
% \item Unbox the $args$ to the types of the parameters, and initialize
%   the parameters with those unboxed arguments, throwing a run-time error on
%   failure.
% \item Execute the \nonterminal{FunctionBody}, either return a
%   value $v$ upon boxing, or terminating, or throwing an exception.
% \end{enumerate}
% \item If $\val$ is a function closure, then:
% \begin{enumerate}
% \item Let $\lexenv$ be the lexical environment of the function
%   closure.
% \item Create a new scope object based on the lexical environment.
% \item Copy any properties of the scope object carried by the function
%   closure into the new scope object.
% \item Initialize \verb'this' with the \verb'this' binding in the
%   function closure if and only if (verifiably) there is a \verb'this' identifier in the lexical environment.
% \item Initialize
%   the identifier with the function closure if and only if (verifiably)
%   there is a
%   identifier for the function closure.
% \item Initialize the parameters with the arguments $args$.
% \item Execute the \nonterminal{FunctionBody}, either returning a
%   value $v$, or terminating, or throwing an exception.
% \end{enumerate}
% \end{enumerate}


\subsection{New Expression}

% \begin{definition}[Construct] A construction \emph{Construct}($val$, $args$) is
%   defined as follows:
% \begin{enumerate}
% \item If \emph{val} is a {\tt Function} whose scope chain is $scope
%   chain$ and
%   \nonterminal{FunctionBody} is \emph{body}, then:
% \begin{enumerate}
% \item Create a new object $obj$.
% \item Create a new activation object $activationobj$ from the environment table
%   \emph{EnvTable} associated with the \nonterminal{FunctionBody}.
% \item Extend $scopechain$ with $(activationobj, envtable)$.
% \item Initialize the properties of $activationobj$ corresponding to
%   the \nonterminal{FunctionSignature} of the
%   \nonterminal{FunctionBody} with $args$.
% \item If {\tt this} is bound in \emph{val}, report an error.
% \item Otherwise, run
%   \nonterminal{FunctionBody} with {\tt this} bound to $obj$, and the
%   extended $scopechain$.
% \item Return $obj$, unless the \nonterminal{FunctionBody} itself
%   returns an {\tt Object}, in which case return that {\tt Object}.
% \end{enumerate}
% \item If \emph{val} is a {\tt Class}, create a new instance of $val$
%   with $args$.
% \end{enumerate}
% \end{definition}

\N
Verify and translate a \emph{new expression}  of the form $\verb'new'$ $C\verb'('\expr_1, ..., \expr_k \verb')'$, 
where $\expr_0$ is an expression and $\expr_1, ..., \expr_k$ is a
sequence of expressions, as follows:
\begin{enumerate}
\item Let the function type
  $(T_1,\dots,T_k) \Rightarrow T'$ be the type of the constructor of
  $C$. 
\item Verify and translate $\expr_1, \dots, \expr_k$ to $\expr'_1,
  \dots, \expr'_k$ of types $T'_1,\dots,T'_k$.
\item Assert that $T'_1,\dots,T_k$ are
  subtypes of $T_1,\dots,T_k$. Translate the expression to {\bf
    NewInstance}$({\tt new}~C\allowbreak (\expr'_1,\dots,\expr'_k))$ and return $C$.
\end{enumerate}

% \N \todo{move}

% \begin{enumerate}
% \item Evaluate $\expr_1, ..., \expr_k$ yielding the sequence of values $args$.
% \item Create a new instance $obj$ of class $C$, allocating its \verb'var'
%   and \verb'const' fields, and initializing
%   its \verb'var' fields to default values based on their types.
% \item Look up the constructor of $C$, yielding the function closure $f$.
% \item Evaluate $f(obj,args)$.
% \item Return $obj$.
% \end{enumerate}

% \section{XML Expressions}

% \subsection{Descendants Operator}

% \begin{definition}[Descendants expression] An \emph{descendants expression} is of the form $\expr \verb'..' \name$,
% where $\expr$ is an expression and $\name$ is a name expression.
% \end{definition}

% \N
% The syntactic nonterminal \nonterminal{DescendentOperator} containing
% the immediate punctuator \operator{..} represents part of a 
% \emph{descendants expression} where $\val$ is denoted by the preceeding expression, and $\name$ is the result of 
% evaluating \nonterminal{PropertyName}.

% \N
% A \emph{descendants expression} is evaluated as follows:

% \begin{enumerate}
% \item Evaluate $\expr$ yielding the value $val$.
% \item Evaluate $\name$ yielding the property name $name$.
% \item Call \emph{Type}($val$) yielding $type$.
% \item If $type$ is neither \asvalue{XML} nor \asvalue{XMLList}, then throw a \asvalue{TypeError} exception.
% \item Call $val$.\subr{descendants}($name$) yielding $v$.
% \item Return $v$.
% \end{enumerate}

% \subsection{Filter Operator}

% \begin{definition}[Filter expression] A \emph{filter expression} is of the form $\expr_o \verb'.(' \expr_p \verb')'$
% where $\expr_o$ and $\expr_p$ are expressions.
% \end{definition}

% \N
% The syntactic nonterminal \nonterminal{FilterOperator} of the form \operator{.} \nonterminal{ParenExpression} 
% represents part of a \emph{filter expression} where $\expr_o$ is denoted by the immediately
% preceding expression, and $\expr_p$ is denoted by the syntactic nonterminal 
% \nonterminal{ParenExpression}.

% \N
% Evaluate \emph{filter expression} as follows:

% \begin{enumerate}
% \item Evaluate $\expr$ and $\name$ yielding $val$ and $name$, respectively.
% \item If the type of $val$ is neither \asvalue{XML} nor \asvalue{XMLList}, then throw a \asvalue{TypeError} exception.
% \item Call \emph{ToXMLList}($val$) yielding $x$.
% \item Construct a value of type \asvalue{XMLList} denoted by {\tt new XMLList()}, yielding $xml$. ($xml.TargetObject$ = \asvalue{null})
% \item Let $scopechain$ be the current scope chain.
% \item For each element $e$ of $x$:
% \begin{enumerate}
%    \item Create a \emph{frame} with and dynamic empty environment table and the object $e$, yielding $rec$
%    \item Push $frame$ onto $scopechain$.
%    \item Evaluate $\expr$ in the runtime environment $scopechain$, yielding $w$.
%    \item Pop $frame$ from $scopechain$.
%    \item Call \emph{ToBoolean}($w$) yielding $b$.
%    \item If $b$ equals {\bf true}, then call \emph{append}($xml$, $e$).
% \end{enumerate}
% \item Return $xml$.
% \end{enumerate}
 
\makeatletter{}% Copyright 2010-2011 Adobe Systems Inc.  All rights reserved.


\subsection{Unary Expressions}
\label{sec-unary-expressions}



% \subsubsection{Plus Expression and Minus Expression}

% \N
% The type of a plus or minus expression of the form
% $\mathtt{+}\mathsf{argexp}$ or $\mathtt{-}\mathsf{argexp}$ is computed
% as follows:
% \begin{enumerate}
% \item Compute the type of $\mathsf{argexp}$ under $\lexenv$, yielding $T$.
% \item Constrain $T$ to be numeric but not \verb'byte'.
% \item Return
%  $T$, and if the expression at type $T$ has a constant value then also return the
%  result of applying \verb'+' or \verb'-' on it.
% % \begin{enumerate}
% % \item If $T$ is \verb'int', return
% %  $\verb'int'$.
% % \item Otherwise, return
% %  $\verb'Number'$.
% % \end{enumerate}
% \end{enumerate}


 
 
\subsubsection{Bitwise Not Expression}

\N
An expression of the form
\verb'~'$\mathsf{argexp}$ is verified and translated as follows:
\begin{enumerate}
\item Verify and translate $\mathsf{argexp}$ to $e$, let its type be $T$.
\item Assert that $T$ is either integral but not \verb'byte' or \verb'*'.
\item Translate the expression to {\bf
    $T$::Op}(\verb'~'$e$), and return $T$.
\end{enumerate}

 
\subsubsection{Logical Not Expression}

\N
An expression of the form
\verb'!'$\mathsf{argexp}$ is verified and translated as follows:
\begin{enumerate}
\item Verify and translate $\mathsf{argexp}$ to $e$, let its type be $T$.
\item Assert that $T$ is \verb'bool'.
\item Translate the expression to {\bf
    {\tt bool}::Op}(\verb'!'$e$), and return \verb'bool'.
\end{enumerate}
 

% \begin{definition}[Binary expression] A \emph{binary expression} is of
%   the form $\expr_1$ ${\op}$ $\expr_2$, 
% where $\expr_1$ and $\expr_2$ are expressions and ${\op}$ is \verb'*', \verb'/', \verb'%',
% \verb'+', \verb'-', \verb'<<', \verb'>>', \verb'>>>', \verb'<', \verb'>', \verb'<=', \verb'>=', \verb'in', \verb'as', 
% \verb'instanceof', \verb'is', \verb'==', \verb'!=', \verb'===', \verb'!==', \verb'&', \verb'~', \verb'|',
% \verb'&&', or \verb'||'.
% \end{definition}

% \N
% A \nonterminal{MutliplicativeExpression}, \nonterminal{AdditiveExpression}, 
% \nonterminal{ShiftExpression}, \nonterminal{RelationalExpression},
% \nonterminal{EqualityExpression}, \nonterminal{BitwiseANDExpression},
% \nonterminal{BitwiseXORExpression}, \nonterminal{BitwiseORExpression},
% \nonterminal{LogicalANDExpression}, or
% \nonterminal{LogicalORExpression} is represented by a binary
% expression where the embedded \nonterminal{UnaryExpression}s, \nonterminal{MutliplicativeExpression}s, \nonterminal{AdditiveExpression}s, 
% \nonterminal{ShiftExpression}s, \nonterminal{RelationalExpression}s,
% \nonterminal{EqualityExpression}s, \nonterminal{BitwiseANDExpression}s,
% \nonterminal{BitwiseXORExpression}s, \nonterminal{BitwiseORExpression}s,
% \nonterminal{LogicalANDExpression}s, or
% \nonterminal{LogicalORExpression}s are represented by expressions.





% \todo{move}





% % \subsection{Postfix Operators}

% % \begin{definition}[Postfix expression] A \emph{postfix expression} is of the form ${\expr}$ ${\op}$ 
% % where ${\expr}$ is an expression and ${\op}$ is a unary operator: $\verb'++'$, $\verb'--'$
% % \end{definition}

% % The syntactic nonterminal \nonterminal{PostfixExpression} that is not of the form 
% % \nonterminal{NewExpression} or \nonterminal{CallExpression} represents a \emph{postfix expression}
% % where $\op$ is given by the syntax and $\expr$ is denoted by \nonterminal{LeftHandSideExpression}.

% % % \N
% % % Evaluate a \emph{postfix expression} as follows:

% % % \begin{enumerate}
% % % \item Evaluate $\expr$ yielding the reference $ref$ of the form ($\obj$, $\name$).
% % % \item If $ref$ is not writable, then throw a {\bf ReferenceError}.
% % % \item Call $\obj.getProperty$($\name$) yielding $val$.
% % % \item Evaluate \emph{ToNumber}($val$) yielding $num$.
% % % \item If $\op$ is \verb'++', compute the \emph{sum} of $num$ and \expression{1}, yielding $v$;
% % % \item Otherwise, compute the \emph{difference} of $num$ and \expression{1}, yielding $v$.
% % % \item Call $\obj.putProperty$($\name$, $v$).
% % % \item Return $v$.
% % % \end{enumerate}

% % \subsection{Prefix Operators}

% % \begin{definition}[Prefix expression] An \emph{prefix expression} is of the form $\op$ $\expr$
% % where $\expr$ is a value and $\op$ is one of the operators: $\delete$, $\verb'++'$, $\verb'--'$.
% % \end{definition}

% % The syntactic nonterminal \nonterminal{PrefixExpression} denotes a \emph{prefix expression} where 
% % $\op$ is given by the syntax and $\expr$ is denoted by \nonterminal{LeftHandSideExpression}.

% % \subsubsection{Delete Operator}

% % \N
% % Evaluate a \terminal{delete} \emph{prefix expression} as follows:

% % \begin{enumerate}
% % \item Evaluate $\expr$ yielding the value or reference $val$.
% % \item If $val$ is not a \emph{reference}, return \asvalue{true}.
% % \item Otherwise, $val$ is a \emph{reference} of the form ($\obj$, $\name$).
% % \item Call $\obj$.$deleteProperty$($\name$) yielding $v$.
% % \item Return $v$.
% % \end{enumerate}


% % \subsubsection{Prefix Increment and Decrement Operators}

% % \begin{definition}[Sum] The \emph{sum} of two numbers is defined by IEEE 754 double arithmentic.
% % \end{definition}

% % \begin{definition}[Difference] The \emph{difference} of two numbers is defined by IEEE 754 double arithmentic.
% % \end{definition}

% % \N
% % Evaluate a \emph{prefix expression} as follows:

% % \begin{enumerate}
% % \item Evaluate $\expr$ yielding the reference $ref$ of the form ($\obj$, $\name$).
% % \item If $ref$ is not writable, then throw a {\bf ReferenceError}.
% % \item Call $\obj.getProperty$($\name$) yielding $val$.
% % \item Evaluate \emph{ToNumber}($val$) yielding $num$.
% % \item If $\op$ is \verb'++', compute the \emph{sum} of $num$ and \asvalue{1}, yielding $v$.
% % \item Otherwise, compute the \emph{difference} of $num$ and \asvalue{1}, yielding $v$.
% % \item Call $\obj.putProperty$($\name$, $v$).
% % \item Return $v$.
% % \end{enumerate}

% \subsection{Unary Operators}

% \begin{definition}[Unary expression] A \emph{unary expression} is of the form ${\op}$ $\expr$
% where $\expr$ is a value and $\op$ is a unary operator: $\verb'~'$, $\verb'!'$
% \end{definition}


% \subsubsection{Bitwise Not Operator}

% \N
% Evaluate a \verb'~' \emph{unary expression} as follows:

% \begin{enumerate}
% \item Evaluate $\expr$ yielding the value $val$.
% \item If $val$ is of type \verb'*':
% \begin{enumerate}
% \item Unbox it  to an integral but not byte value  $val$
%   (throwing a run-time error upon failure). 
% \item Return the \emph{bitwise complement} of $val$ upon boxing.
% \end{enumerate}
% \item Otherwise it is verifiably integral but not byte.
% \begin{enumerate}
% \item Return the \emph{bitwise complement} of $val$.
% \end{enumerate}
% \end{enumerate}

% \subsubsection{Logical Not Operator}

% \N
% Evaluate a \terminal{!} \emph{unary expression} as follows:

% \begin{enumerate}
% \item Evaluate $\expr$ yielding the value $val$.
% \item If $val$ is of type \verb'*':
% \begin{enumerate}
% \item Unbox it  to a bool value $val$
%   (throwing a run-time error upon failure). 
% \item Return the \emph{logical complement} of $val$ upon boxing.
% \end{enumerate}
% \item Otherwise it is verifiably bool.
% \begin{enumerate}
% \item Return the \emph{logical complement} of $val$.
% \end{enumerate}
% \end{enumerate}

 
\makeatletter{}% Copyright 2010-2011 Adobe Systems Inc.  All rights reserved.

\subsection{Binary Expressions}
\label{sec-binary-expressions}


\subsubsection{Multiplicative Expression, Subtract Expression, Relational Expression}

\N
An expression of the form
$\mathsf{exp}_1$ \emph{op} $\mathsf{exp}_2$, where \emph{op} is
\verb'*', \verb'/', \verb'%', \verb'-', \verb'<', \verb'<=', \verb'>', or \verb'>=' is verified and translated as follows:
\begin{enumerate}
\item Verify and translate $\mathsf{exp}_1$ and $\mathsf{exp}_2$ to
  $e_1$ and $e_2$, let
  their types be
 $T$.
\item Assert that $T$ is either numeric but not \verb'byte', or \verb'*'.
\item Translate the expression to {\bf $T$::Op}$(e_1 ~\emph{op}~ e_2)$ and return $T$.
% \begin{enumerate}
% \item If $T_1$ and $T_2$ are integer-like then
%   return \verb'int'.
% \item Otherwise, return \verb'Number'.
% \end{enumerate}
\end{enumerate}

\subsubsection{Add Expression}

\N
An expression of the form
$\mathsf{exp}_1$ \verb'+' $\mathsf{exp}_2$ is verified and translated
as follows:
\begin{enumerate}
\item Verify and translate $\mathsf{exp}_1$ and $\mathsf{exp}_2$ to
  $e_1$ and $e_2$, let
  their types be
 $T$.
\item Assert that $T$ is either numeric but not \verb'byte', or
  \verb'String', or \verb'*'.
\item Translate the expression to {\bf $T$::Op}$(e_1 + e_2)$ and return $T$.
\end{enumerate}

\subsubsection{Equality Expression}

\N
An expression of the form
$\mathsf{exp}_1~\emph{op}~\mathsf{exp}_2$, where
$\emph{op}$ is \verb'==',
\verb'!=', \verb'===', or \verb'!==',  is verified and translated
as follows:
\begin{enumerate}
\item Verify and translate $\mathsf{exp}_1$ and $\mathsf{exp}_2$ to
  $e_1$ and $e_2$, let
  their types be
 $T$.
\item Translate the expression to {\bf $T$::Op}$(e_1 ~\emph{op}~ e_2)$ and return \verb'bool'.
\end{enumerate}

% \avik{Maybe it is enough to say that this or that type has to be compatible
%   with the other. Everything seems to be compatible with {\tt *} or
%   {\tt Boolean}, and {\tt *} seems to be compatible with everything,
%   and {\tt null} seems to be compatible with everything other than
%   numeric or {\tt Boolean}.}

\subsubsection{Shift Expression, Bit Arithmetic Expression}

\N
An expression of the form
$\mathsf{exp}_1~\emph{op}~\mathsf{exp}_2$, where
$\emph{op}$ is \verb'<<',
\verb'>>', \verb'&', \verb'|', or \verb'^',  is verified and translated
as follows:
\begin{enumerate}
\item Verify and translate $\mathsf{exp}_1$ and $\mathsf{exp}_2$ to
  $e_1$ and $e_2$, let
  their types be
 $T$.
\item Assert that $T$ is either integral but not \verb'byte', or \verb'*'.
\item Translate the expression to {\bf $T$::Op}$(e_1 ~\emph{op}~ e_2)$ and return $T$.
\end{enumerate}

\subsubsection{Logical Expression}

\N
An expression of the form
$\mathsf{exp}_1$ \emph{op} $\mathsf{exp}_2$, where \emph{op} is
\verb'&&' or \verb'||', is verified and translated as follows:
\begin{enumerate}
\item Verify and translate $\mathsf{exp}_1$ and $\mathsf{exp}_2$ to
  $e_1$ and $e_2$, let
  their types be
 $T$.
\item Assert that $T$ is \verb'bool'.
\item Translate the expression to {\bf {\tt bool}::Op}$(e_1 ~\emph{op}~ e_2)$ and return \verb'bool'.
\end{enumerate}

\subsubsection{Is Expression}

\N
An expression of the form
$\mathsf{exp}$ \verb'is' $T$ is verified and translated as follows:
\begin{enumerate}
\item Verify and translate $\mathsf{exp}$ to
  $e$, let
 its type be
 $T'$.
\item Translate the expression to {\bf $T'$::Op}$(e~{\tt is}~T)$ and return \verb'bool'.
\end{enumerate}

\subsubsection{As Expression}

\N
An expression of the form
$\mathsf{exp}$ \verb'as' $T$ is verified and translated as follows:
\begin{enumerate}
\item Verify and translate $\mathsf{exp}$ to
  $e$, let
 its type be
 $T'$.
\item Translate the expression to {\bf $T'$::Op}$(e~{\tt as}~T)$ and return $T$.
\end{enumerate}



% \todo{move}


% \begin{definition}[Binary expression] A \emph{binary expression} is of the form ${\expr_1}$ ${\op}$ ${\expr_2}$
% where ${\expr_1}$ and ${\expr_2}$ are expressions and ${\op}$ is one of the binary operators: \verb'*', \verb'/', \verb'%',
% \verb'+', \verb'-', \verb'<<', \verb'>>', \verb'<', \verb'>', \verb'<=', \verb'>=', \verb'as', 
% \verb'is', \verb'==', \verb'!=', \verb'===', \verb'!==', \verb'&', \verb'~', \verb'|'.
% \end{definition}

% \subsection{Multiplicative Operators}

% \N
% The syntactic nonterminal \nonterminal{MultiplicativeExpression} denotes the \emph{binary expression} 
% where ${\op}$ is denoted by the immediate infix punctuator: \verb'*', \verb'/' or \verb'%', and 
% ${\expr_1}$ and ${\expr_2}$ are denoted by the syntactic nonterminals \nonterminal{MultiplicativeExpression} 
% and \nonterminal{UnaryExpression}, respectively.

% \N
% A multiplicative \emph{binary expression} is evaluated as follows:

% \begin{enumerate}
% \item Evaluate $\expr_1$ and $\expr_2$ yielding the values $val_1$ and $val_2$, respectively.
% \item If $val_1$ and $val_2$ are of type \verb'*':
% \begin{enumerate}
% \item Unbox and promote $val_1$ and $val_2$ to equi-typed numeric  but not byte  values $val_1$ and
%   $val_2$.
% \item If ${\op}$ is the \verb'*' operator, return the \emph{product}
%   of $val_1$ and $val_2$ upon boxing.
% \item If ${\op}$ is the \verb'/' operator, return the \emph{quotient}
%   of $val_1$ and $val_2$ upon boxing.
% \item If ${\op}$ is the \verb'%' operator, return the \emph{remainder}
%                               of $val_1$ and $val_2$ upon boxing.
% \end{enumerate}
% \item Otherwise they are verifiably equi-typed as numeric but not byte.
% \begin{enumerate}
% \item If ${\op}$ is the \verb'*' operator, return the \emph{product} of $val_1$ and $val_2$.
% \item If ${\op}$ is the \verb'/' operator, return the \emph{quotient} of $val_1$ and $val_2$.
% \item If ${\op}$ is the \verb'%' operator, return the \emph{remainder}
%                               of $val_1$ and $val_2$.
% \end{enumerate}
% \end{enumerate}

% \subsection{Additive Operators}

% \N
% The syntactic nonterminal \nonterminal{AdditiveExpression} denotes the \emph{binary expression} 
% where ${\op}$ is the corresponding operator \verb'+' or \verb'-', and $\expr_1$ and $\expr_2$ are 
% denoted by the syntactic nonterminals \nonterminal{AdditiveExpression} and 
% \nonterminal{MultiplicativeExpression}, respectively.

% \subsubsection{Plus Operator}

% \N
% A binary expression with the operator \verb'+' is evaluated as follows:

% \begin{enumerate}
% \item Evaluate $\expr_1$ and $\expr_2$ yielding the values $val_1$ and $val_2$, respectively.
% \item If $val_1$ and $val_2$ are of type \verb'*':
% \begin{enumerate}
% \item Unbox $val_1$ and $val_2$.
% \item If they are numeric  but not both byte  values, promote them to
%   the same numeric but not byte values $val_1$ and
%   $val_2$, and return the \emph{addition}
%   of $val_1$ and $val_2$ upon boxing.
% \item If one of them is of type \verb'String', coerce the other to \verb'String', yielding $val_1$ and
%   $val_2$; return the \emph{concatenation}
%   of $val_1$ and $val_2$ upon boxing.
% \item Otherwise throw an error.
% \end{enumerate}
% \item Otherwise they are verifiably equi-typed as numeric but not
%   byte, or as \verb'String'.
% \begin{enumerate}
% \item If they are both equi-typed as numeric  but not byte  values $val_1$ and
%   $val_2$, return the \emph{addition}
%   of $val_1$ and $val_2$.
% \item If they are both equi-typed as \verb'String', return the \emph{concatenation}
%   of $val_1$ and $val_2$ upon boxing.
% \end{enumerate}
% \end{enumerate}

% \subsubsection{Minus Operator}

% \N
% A binary expression with the operator \verb'-' is evaluated as follows:

% \begin{enumerate}
% \item Evaluate $\expr_1$ and $\expr_2$ yielding the values $val_1$ and $val_2$, respectively.
% \item If $val_1$ and $val_2$ are of type \verb'*':
% \begin{enumerate}
% \item Unbox  and promote $val_1$ and $val_2$ to equi-typed numeric  but not byte  values $val_1$ and
%   $val_2$.
% \item Return the \emph{subtraction}
%   of $val_1$ and $val_2$ upon boxing.
% \end{enumerate}
% \item Otherwise they are verifiably equi-typed as numeric but not byte.
% \begin{enumerate}
% \item Return the \emph{subtraction} of $val_1$ and $val_2$.
% \end{enumerate}
% \end{enumerate}

% \subsection{Shift Operators}


% \N
% The syntactic nonterminal \nonterminal{ShiftExpression} denotes the \emph{binary expression} where 
% ${\op}$ is the immediate punctuator denoted by one of: \verb'<<' or \verb'>>', and $\expr_1$ 
% and $\expr_2$ are denoted by the syntactic nonterminals \nonterminal{ShiftExpression} and 
% \nonterminal{AdditiveExpression}, respectively.

% \subsubsection{Left Shift Operator}

% \N
% Evaluate a left shift ($\verb'<<'$) \emph{binary expression} as follows:

% \begin{enumerate}
% \item Evaluate $\expr_1$ and $\expr_2$ yielding the values $val_1$ and $val_2$, respectively.
% \item If $val_1$ and $val_2$ are of type \verb'*':
% \begin{enumerate}
% \item Unbox  and promote $val_1$ and $val_2$ to equi-typed  integral  but not byte  values $val_1$ and
%   $val_2$.
% \item Return the \emph{left shift}
%   of $val_1$ and $val_2$ upon boxing.
% \end{enumerate}
% \item Otherwise they are verifiably equi-typed as integral but not byte.
% \begin{enumerate}
% \item Return the \emph{left shift} of $val_1$ and $val_2$.
% \end{enumerate}
% \end{enumerate}

% \subsubsection{Right Shift Operator}

% \N
% Evaluate a right shift ($\verb'>>'$) \emph{binary expression} as follows:

% \begin{enumerate}
% \item Evaluate $\expr_1$ and $\expr_2$ yielding the values $val_1$ and $val_2$, respectively.
% \item If $val_1$ and $val_2$ are of type \verb'*':
% \begin{enumerate}
% \item Unbox  and promote $val_1$ and $val_2$ to equi-typed  integral but not byte  values $val_1$ and
%   $val_2$.
% \item Return the \emph{right shift}
%   of $val_1$ and $val_2$ upon boxing.
% \end{enumerate}
% \item Otherwise they are equi-typed as integral but not byte.
% \begin{enumerate}
% \item Return the \emph{right shift} of $val_1$ and $val_2$.
% \end{enumerate}
% \end{enumerate}

% \subsection{Relational and Typing Operators}

% \N
% The syntactic nonterminal \nonterminal{RelationalExpression} denotes the \emph{binary expression} 
% where ${\op}$ is an operator corresponding to one of: \verb'<' or \verb'>' or \verb'<=' or \verb'>=', and $\val_1$ and $\val_2$ are denoted 
% by the syntactic nonterminals \nonterminal{RelationalExpression} and \nonterminal{ShiftExpression}, 
% respectively.

% \N
% Evaluate a relation binary expression as follows:

% \begin{enumerate}
% \item Evaluate $\expr_1$ and $\expr_2$ yielding the values $val_1$ and $val_2$, respectively.
% \item If $val_1$ and $val_2$ are of type \verb'*':
% \begin{enumerate}
% \item Unbox  and promote $val_1$ and $val_2$ to equi-typed  numeric  but not byte  values $val_1$ and
%   $val_2$.
% \item If ${\op}$ is the \verb'<' operator, return the \emph{less than comparison}
%   of $val_1$ and $val_2$.
% \item If ${\op}$ is the \verb'<=' operator, return the \emph{less than
%     or equals comparison}
%   of $val_1$ and $val_2$.
% \item If ${\op}$ is the \verb'>' operator, return the \emph{greater than}
%   of $val_1$ and $val_2$.
% \item If ${\op}$ is the \verb'>=' operator, return the \emph{greater
%     than or equals comparison}
%   of $val_1$ and $val_2$.
% \end{enumerate}
% \item Otherwise they are verifiably equi-typed as numeric but not byte.
% \begin{enumerate}
% \item If ${\op}$ is the \verb'<' operator, return the \emph{less than comparison}
%   of $val_1$ and $val_2$.
% \item If ${\op}$ is the \verb'<=' operator, return the \emph{less than
%     or equals comparison}
%   of $val_1$ and $val_2$.
% \item If ${\op}$ is the \verb'>' operator, return the \emph{greater than}
%   of $val_1$ and $val_2$.
% \item If ${\op}$ is the \verb'>=' operator, return the \emph{greater
%     than or equals comparison}
%   of $val_1$ and $val_2$.
% \end{enumerate}
% \end{enumerate}





% \subsubsection{As Operator}

% \N
% Evaluate an \operator{as} \emph{binary expression} as follows:

% \begin{enumerate}
% \item Evaluate $\expr$ yielding the value $val$.
% \item If $val$ is of type \verb'*', unbox it to $val$.
% \item If $T$ is \verb'String':
% \begin{enumerate}
% \item If $val$ is a primitive value, return its literal form as a
%   \verb'String'.
% \item Otherwise, return $val.toString()$.
% \end{enumerate}
% \item If $T$ is \verb'Symbol':
% \begin{enumerate}
% \item If $val$ is a primitive value, return its literal form as a
%   \verb'Symbol'.
% \item Otherwise, return $val.toString()$ as an instance of
%   \verb'Symbol' upon interning.
% \end{enumerate}
% \item If $T$ is \verb'Symbol' and $val$ is of type \verb'String',
%   return a new instance of \verb'Symbol' that denotes an interned copy
%   of $val$.
% \item If $T$ is numeric:
% \begin{enumerate}
% \item If $val$ is of numeric type, return a value of type $T$ by
%   converting $val$.
% \item If $val$ is of type \verb'String' or \verb'Symbol' and is the
%   literal form of a numeric value, convert that value to a value of
%   type $T$ and return it.
% \end{enumerate}
% \item If $T$ is any other type and the type of $val$ is a subtype,
%   return $val$.
% \item Otherwise throw an error.
% \end{enumerate}

% \subsubsection{Is Operator}

% \N
% Evaluate an \operator{is} \emph{binary expression} as follows:

% \begin{enumerate}
% \item Evaluate $\expr$ yielding the value $val$.
% \item If $val$ is of type \verb'*', unbox it to $val$.
% \item Return true if the type of $val$ is a subtype of $T$, and false otherwise.
% \end{enumerate}

% \subsection{Equality Operators}

% \N
% The syntactic nonterminal \nonterminal{EqualityExpression} denotes the \emph{binary expression} 
% where $\op$ is an operator corresponding to one of: \verb'==' or \verb'!=' or \verb'===' or 
% \verb'!==', and $\expr_1$ and $\expr_2$ are denoted by the syntactic nonterminals 
% \nonterminal{EqualityExpression} and \nonterminal{RelationalExpression}, 
% respectively.

% \subsubsection{Equality Operators}

% \N
% Evaluate a $\verb'=='$ \emph{binary expression} as follows:

% \begin{enumerate}
% \item Evaluate $\expr_1$ and $\expr_2$ yielding the values $val_1$ and
%   $val_2$, respectively.
% \item If $val_1$ and $val_2$ are of type \verb'*':
% \begin{enumerate}
% \item Unbox them to
%   $val_1$ and $val_2$.
% \item Let $T$ be the LUB of the types of $val_1$ and $val_2$.
% \item If the type of $val_1$ and $val_2$ is a value type, return the result of
%   comparing them for structural equality.
% \item If the type of $val_1$ and $val_2$ is a reference type (but not
%   \verb'*'):
% \begin{enumerate}
% \item If $val_1$ is \verb'null' then return true if $val_2$ is
%   \verb'null', false otherwise.
% \item Otherwise return the result of
%   $val_1.equals(val_2)$.
% \end{enumerate}
% \item Otherwise throw an error.
% \end{enumerate}
% \item Otherwise they are verifiably equi-typed.
% \begin{enumerate}
% \item If the type of $val_1$ and $val_2$ is a value type, return the result of
%   comparing them for structural equality.
% \item If the type of $val_1$ and $val_2$ is a reference type:
% \begin{enumerate}
% \item If $val_1$ is \verb'null' then return true if $val_2$ is
%   \verb'null', false otherwise.
% \item Otherwise return the result of
%   $val_1.equals(val_2)$.
% \end{enumerate}
% \end{enumerate}
% \end{enumerate}

% \N
% Evaluate a $\verb'!='$ \emph{binary expression} as follows:

% \begin{enumerate}
% \item Evaluate a $\verb'=='$ \emph{binary expression}, yielding a
%   bool value $b$.
% \item Return the logical complement of $b$.
% \end{enumerate}

% \subsubsection{Strict Equality Operators}

% \N
% Evaluate a $\verb'==='$ \emph{binary expression} as follows:

% \begin{enumerate}
% \item Evaluate $\expr_1$ and $\expr_2$ yielding the values $val_1$ and
%   $val_2$, respectively.
% \item If $val_1$ and $val_2$ are of type \verb'*':
% \begin{enumerate}
% \item Unbox them to
%   $val_1$ and $val_2$.
% \item Let $T$ be the LUB of the types of $val_1$ and $val_2$.
% \item If the type of $val_1$ and $val_2$ is a value type, return the result of
%   comparing them for structural equality.
% \item If the type of $val_1$ and $val_2$ is a reference type (but not \verb'*'), return the result of
%   comparing them for pointer equality.
% \item Otherwise throw an error.
% \end{enumerate}
% \item Otherwise they are verifiably equi-typed.
% \begin{enumerate}
% \item If the type of $val_1$ and $val_2$ is a value type, return the result of
%   comparing them for structural equality.
% \item If the type of $val_1$ and $val_2$ is a reference type, return the result of
%   comparing them for pointer equality.
% \end{enumerate}
% \end{enumerate}

% \N
% Evaluate a $\verb'!=='$ \emph{binary expression} as follows:

% \begin{enumerate}
% \item Evaluate a $\verb'==='$ \emph{binary expression}, yielding a
%   bool value $b$.
% \item Return the logical complement of $b$.
% \end{enumerate}





% \subsection{Bitwise Operators}

% \subsubsection{Bitwise AND Operator}

% \N
% Evaluate a $\verb'&'$ \emph{binary expression} as follows:

% \begin{enumerate}
% \item Evaluate $\expr_1$ and $\expr_2$ yielding the values $val_1$ and $val_2$, respectively.
% \item If $val_1$ and $val_2$ are of type \verb'*':
% \begin{enumerate}
% \item Unbox  and promote $val_1$ and $val_2$ to equi-typed  integral but not byte  values $val_1$ and
%   $val_2$.
% \item Return the \emph{bitwise conjunction}
%   of $val_1$ and $val_2$ upon boxing.
% \end{enumerate}
% \item Otherwise they are verifiably equi-typed as integral but not byte.
% \begin{enumerate}
% \item Return the \emph{bitwise conjunction} of $val_1$ and $val_2$.
% \end{enumerate}
% \end{enumerate}

% \subsubsection{Bitwise XOR Operator}

% \N
% Evaluate a $\verb'^'$ \emph{binary expression} as follows:

% \begin{enumerate}
% \item Evaluate $\expr_1$ and $\expr_2$ yielding the values $val_1$ and $val_2$, respectively.
% \item If $val_1$ and $val_2$ are of type \verb'*':
% \begin{enumerate}
% \item Unbox  and promote $val_1$ and $val_2$ to equi-typed integral  but not byte  values $val_1$ and
%   $val_2$.
% \item Return the \emph{bitwise exclusive disjunction}
%   of $val_1$ and $val_2$ upon boxing.
% \end{enumerate}
% \item Otherwise they are verifiably equi-typed as integral but not byte.
% \begin{enumerate}
% \item Return the \emph{bitwise exclusive disjunction} of $val_1$ and $val_2$.
% \end{enumerate}
% \end{enumerate}

% \subsubsection{Bitwise OR Operator}

% \N
% Evaluate a $\verb'|'$ \emph{binary expression} as follows:

% \begin{enumerate}
% \item Evaluate $\expr_1$ and $\expr_2$ yielding the values $val_1$ and $val_2$, respectively.
% \item If $val_1$ and $val_2$ are of type \verb'*':
% \begin{enumerate}
% \item Unbox and promote  $val_1$ and $val_2$ to equi-typed  integral  but not byte  values $val_1$ and
%   $val_2$.
% \item Return the \emph{bitwise disjunction}
%   of $val_1$ and $val_2$ upon boxing.
% \end{enumerate}
% \item Otherwise they are verifiably equi-typed as integral but not byte.
% \begin{enumerate}
% \item Return the \emph{bitwise disjunction} of $val_1$ and $val_2$.
% \end{enumerate}
% \end{enumerate}

% \subsection{Logical Operators}

% \subsubsection{Logical AND Operator}

% \N
% Evaluate a $\verb'&&'$ \emph{logical expression} as follows:

% \begin{enumerate}
% \item Evaluate $\expr_1$ and $\expr_2$ yielding the values $val_1$ and $val_2$, respectively.
% \item If $val_1$ and $val_2$ are of type \verb'*':
% \begin{enumerate}
% \item Unbox $val_1$ and $val_2$ to the bool  values $val_1$ and
%   $val_2$.
% \item Return the \emph{logical conjuction}
%   of $val_1$ and $val_2$ upon boxing.
% \end{enumerate}
% \item Otherwise they are bool.
% \begin{enumerate}
% \item Return the \emph{logical conjunction} of $val_1$ and $val_2$.
% \end{enumerate}
% \end{enumerate}

% \subsubsection{Logical OR Operator}

% \N
% Evaluate a $\verb'||'$ \emph{logical expression} as follows:

% \begin{enumerate}
% \item Evaluate $\expr_1$ and $\expr_2$ yielding the values $val_1$ and $val_2$, respectively.
% \item If $val_1$ and $val_2$ are of type \verb'*':
% \begin{enumerate}
% \item Unbox $val_1$ and $val_2$ to the bool  values $val_1$ and
%   $val_2$.
% \item Return the \emph{logical disjunction}
%   of $val_1$ and $val_2$ upon boxing.
% \end{enumerate}
% \item Otherwise they are bool.
% \begin{enumerate}
% \item Return the \emph{logical disjunction} of $val_1$ and $val_2$.
% \end{enumerate}
% \end{enumerate}

% \subsection{Conditional Operator}

% \begin{definition}[Conditional expression] A \emph{conditional expression} is of the form 
% $\expr_0$ $\verb'?'$ $\expr_1$ $\verb':'$ $\expr_2$, where $\expr_0$, $\expr_1$ and $\expr_2$ are
% expressions.
% \end{definition}

% \N
% Evaluate a \emph{conditional expression} as follows:

% \begin{enumerate}
% \item Evaluate $\expr_0$ yielding $val_0$.
% \item If the type of $val_0$ is \verb'*':
% \begin{enumerate}
% \item Unbox $val_0$ to a bool value $val_0$.
% \item If $val_0$ is {\bf true}, return the result of evaluating $\expr_1$.
% \item Otherwise, return the result of evaluating $\expr_2$.
% \end{enumerate}
% \item Otherwise $val_0$ is verifiably bool.
% \begin{enumerate}
% \item If $val_0$ is {\bf true}, return the result of evaluating $\expr_1$.
% \item Otherwise, return the result of evaluating $\expr_2$.
% \end{enumerate}
% \item In any case the type of the result is verifiably the same.
% \end{enumerate}


% \subsection{Assignment Operators}

% \begin{definition}[Assignment expression] An \emph{assignment expression} is of the form $\expr_1$ $\verb'='$ $\expr_2$,
% where $\expr_1$ and $\expr_2$ are expressions.
% \end{definition}

% \begin{definition}[Compound assignment expression] A \emph{compound assignment expression} is of the form $\expr_1$ $\verb'='$ $\expr_2$,
% where $\expr_1$ and $\expr_2$ are expressions, and $\op$ is one of the binary operators ($\verb'*'$, $\verb'/'$, $\verb'%'$, 
% $\verb'+'$, $\verb'-'$, $\verb'<<'$, $\verb'>>'$, $\verb'>>>'$, $\verb'&'$, $\verb'^'$, $\verb'|'$, 
% $\verb'&&'$, $\verb'||'$).
% \end{definition}

% \N
% The syntactic nonterminal \nonterminal{AssignmentExpression} with operator $\verb'='$ represents an 
% \emph{assignment expression} where the left expression and right expression are denoted by $\expr_1$ 
% and $\expr_2$, respectively. The syntactic nonterminal \nonterminal{AssignmentExpression} with an operator 
% other than $\verb'='$ represents a \emph{compound assignment expression} where the $\op$ corresponds 
% to the operator, and the left expression and right expression are evaluated to $\expr_1$ and $\expr_2$, 
% respectively.

% \subsubsection{Assignment Expressions}

% \N
% Evaluate an \emph{assignment expression} as follows:

% \begin{enumerate}
% \item Evaluate the \nonterminal{LeftHandSideExpression}, which is a
%   reference expression, to a reference, which consists of an object $O$, a name
%   $name$, and an optional class $super$.
% \item Evaluate the right hand side expression to a value $V$.
% \item Call $O.\emph{setProperty}(name,V,super)$.
% \end{enumerate}

% \todo{handle wildcard names and attribute names}

% \subsubsection{Compound Assignment Expressions}

% \N
% Evaluate a \emph{compound assignment expression} as follows:

% \begin{enumerate}
% \item Evaluate the \nonterminal{LeftHandSideExpression}, which is a
%   reference expression, to a reference, which consists of an object $O$, a name
%   $name$, and an optional class $super$.
% \item Call $O.\emph{getProperty}(name,super)$, yielding $R$.
% \item Evaluate the binary
%   operation on $R$ and the right hand side expression, yielding value $V$.
% \item Call $O.\emph{setProperty}(name,V,super)$.
% \end{enumerate}

% \todo{handle wildcard names and attribute names}


 
\makeatletter{}
\subsection{Statements}

\subsubsection{If Statements}

\N
An \nonterminal{IfStatement} is verified by ensuring that the type of
its ``condition'' \nonterminal{Expression} is {\tt bool}.


\subsubsection{Switch Statements}

\N
A \nonterminal{SwitchStatement} is verified by ensuring that the types
of the \nonterminal{ParenExpression} and each \nonterminal{Expression}
in the \nonterminal{CaseClauses} is the same.

\subsubsection{While Statements}

\N
An \nonterminal{WhileStatement} is verified by ensuring that the type of
its ``condition'' \nonterminal{Expression} is {\tt bool}.

\subsubsection{Return Statements}

\N
A \nonterminal{ReturnStatement} is verified by ensuring that the type
of its \nonterminal{Expression} matches the return type of the
enclosing function.


\section{Execution}

% \subsection{Assignment Statements}

% \N
% An \nonterminal{AssignmentStatement} of the form
% \verb'r = e' is run as follows:
% \begin{enumerate}
% \item Let $ref$ be the value of the left hand side reference.
% \item Let $val$ be the value of the right hand side expression.
% \item If $ref$ is of type \verb'*', then unbox $ref$ and check that it
%   is not declared \verb'const'.
% \item Write $val$ to $ref$.
% \end{enumerate}

\subsection{Labeled Statements}

\begin{definition}[Next iteration] The next iteration of an iteration
  statement is defined as follows:
\begin{enumerate}
\item If the iteration statement is a \nonterminal{LabeledStatement},
  return the next iteration of the \nonterminal{Statement} of the \nonterminal{LabeledStatement}.
% \item If the iteration statement is a \nonterminal{DoStatement} whose
%   \emph{Statement} is $S$ and whose \nonterminal{Expression} is $E$,
%   return a \nonterminal{WhileStatement} whose \emph{Statement} is $S$ and whose \nonterminal{Expression} is $E$.
\item Otherwise, return the iteration statement.
\end{enumerate}
\end{definition}

\N
A \nonterminal{LabeledStatement} is executed as follows:

\begin{enumerate}
\item Try executing its \nonterminal{Statement}.
\item If execution completes, return.
\item Otherwise:
\begin{enumerate}
\item If a ``break'' jump is thrown whose label is that of the
  \nonterminal{LabeledStatement}, return.
\item If a ``continue'' jump is thrown whose label is that of the
  \nonterminal{LabeledStatement}, execute the next iteration of the
  \nonterminal{Statement} of the \nonterminal{LabeledStatement}.
\end{enumerate}
\end{enumerate}

\subsection{Block Statements}

\N
A \nonterminal{BlockStatement} is executed as follows:
\begin{enumerate}
\item Allocation is performed for the scope.
\item Execute each \nonterminal{Statement} in turn.
\end{enumerate}

\subsection{If Statements}

\N
An \nonterminal{IfStatement} is executed as follows:

\begin{enumerate}
\item Evaluate the ``condition'' \nonterminal{Expression}, yielding a boolean value.
\item If the value is {\tt true}, execute the ``then'' \nonterminal{Statement}.
\item Otherwise, the value is {\tt false}; execute the ``else'' \nonterminal{Statement}.
\end{enumerate}

\subsection{Switch Statements}

\N
A \nonterminal{SwitchStatement} is executed as follows:

\begin{enumerate}
\item Evaluate the ``switch'' \nonterminal{Expression}, yielding a
  value $V$.
\item Let \emph{matched} be false.
\item For each \nonterminal{CaseClause} in \nonterminal{CaseClauses}:
\begin{enumerate}
\item If \emph{matched} is false, evaluate the ``case''
  \nonterminal{Expression}, yielding a value. If the value compares by
  {\tt==} to $V$, let \emph{matched} be true.
\item If \emph{matched} is true, try executing the ``case''
  \nonterminal{Statement}; if a ``break'' jump is thrown without a label, return.
\end{enumerate}
\item If there is a \nonterminal{DefaultClause}, try executing the ``case''
  \nonterminal{Statement}; if a ``break'' jump is thrown without a label, return.
\end{enumerate}



\subsection{While Statements}

\N
A \nonterminal{WhileStatement} is executed as follows:

\begin{enumerate}
\item Repeat:
\begin{enumerate}
\item Evaluate the ``condition'' \nonterminal{Expression}, yielding a boolean value.

\item If false, return.
\item Otherwise, try executing the ``body'' \nonterminal{Statement}.
\item If a ``break'' jump is thrown without a label, return.
\item if a ``continue'' jump is thrown without a label, skip.
\end{enumerate}
\end{enumerate}

\subsection{Break Statements}

\N
A \nonterminal{BreakStatement} is executed as follows:

\begin{enumerate}
\item Throw a ``break'' jump, with the \nonterminal{Label} of the
  \nonterminal{BreakStatement} if it exists.
\end{enumerate}

\subsection{Continue Statements}

\N
A \nonterminal{ContinueStatement} is executed as follows:

\begin{enumerate}
\item Throw a ``continue'' jump, with the \nonterminal{Label} of the
  \nonterminal{ContinueStatement} if it exists.
\end{enumerate}

\subsubsection{Return Statements}

\N
A \nonterminal{ReturnStatement} is executed as follows:

\begin{enumerate}
\item If the \nonterminal{ReturnStatement} has an \emph{Expression},
  evaluate it to a value; throw a ``return'' jump with the value.
\item Otherwise, throw a ``return'' jump.
\end{enumerate}

\subsection{Throw Statements}

\N
A \nonterminal{ThrowStatement} is executed as follows:
\begin{enumerate}
\item Evaluate the \emph{Expression} of the
  \nonterminal{ThrowStatement}, yielding a value.
\item Throw an exception with the value.
\end{enumerate}

\subsection{Try Statements}

\begin{enumerate}
\item Try executing the ``try'' \nonterminal{Block}.
\item If there is no exception, execute the ``finally'' \nonterminal{Block}. 
\item Otherwise, let there be an exception with value $V$. For each \nonterminal{CatchClause} in
  \nonterminal{CatchClauses}, if $V$ is coercible via {\tt is} to the type of the
  \nonterminal{TypedBinding}, then try executing the
  \nonterminal{Block}.
\begin{enumerate}
\item If there is an exception with value $V$, execute the ``finally''
  \nonterminal{Block} and throw $V$.
\item Otherwise, execute the ``finally''
  \nonterminal{Block} and return.
\end{enumerate}
\item Throw $V$.
\end{enumerate}



 

\end{document}
