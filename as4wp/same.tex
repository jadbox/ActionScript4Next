% Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.

% Licensed under the Apache License, Version 2.0 (the "License");
% you may not use this file except in compliance with the License.
% You may obtain a copy of the License at

% http://www.apache.org/licenses/LICENSE-2.0

% Unless required by applicable law or agreed to in writing, software
% distributed under the License is distributed on an "AS IS" BASIS,
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
% See the License for the specific language governing permissions and
% limitations under the License.

\section{Implementation Notes}
\label{impl}
\subsection{Automatic Boxing and Unboxing}

In AS4 we distinguish between value types, reference types, and \code{*}.
Inhabitants of value types are directly
laid out in memory, registers, and on the stack, and are compared by
value; and furthermore, their types are tracked by the compiler.
Inhabitants of reference types are represented by pointers into memory, and are
compared by reference; and furthermore,  their types are manifest in
the payload.

The \code{*} type is a (tagged) union of value types and reference
types. Inhabitants of \code{*} are represented by a pointer into
memory (``boxing''). (Crucially, this means that unlike in AS3,
inhabitants of value types and inhabitants of \code{*} always have
distinct representations, and are never confused. Type inference at
the source-code level ``unboxes'' as many inhabitants of \code{*} as
possible, but the run-time does not need to worry about such type inference.)
Boxing a value makes the type manifest, and boxing a reference is a
no-op. Furthermore, inhabitants of \code{*} behave exactly like their unboxed versions modulo boxing.

Subtyping and conversion are distinct notions in AS4. Subtyping
	does not change representation and semantics;
	e.g., class $B$ is a subtype of class $A$ if $B$ is a subclass
        of $A$, so a reference of type $B$ can be freely passed to a
        context of type $A$.

Implicit conversion, on the other hand,
changes representation or semantics;
	e.g., \code{int} is implicitly convertible to \code{double} or
        \code{*}. Crucially, the
	compiler makes all implicit conversions explicit (via
        coercions). This means that the
	runtime works on explicitly typed code (possibly with
        coercions): it never needs to know about implicit conversions.
In particular, the compiler cleanly separates fast paths and slow paths.
So the runtime can generate fast machine code for statically typed parts
        of the source code without any type inference (and is \emph{not} obligated to
        generate optimized machine code for dynamically typed parts of the
        source code).

\subsection{Verification}

As a result of the above separation of duties of the compiler and the
run-time, a bytecode verifier for AS4 (unlike AS3) need not do any
type inference and/or bytecode rewriting. All it does is typecheck the
bytecode, following the typechecking performed by the source-level
compiler.

This model enables a source-level compiler to freely and aggressively perform
type-based optimizations: for example, it can rely on the types of
library classes that a program is compiled against, even those such
classes may not be included in the generated bytecode. At run time,
those type assumptions are validated by the verifier, which means that
different versions of such library classes can be dynamically loaded
and the generated bytecode continues to run as long as the types it
relies on at compile-time remain invariant at run-time.
